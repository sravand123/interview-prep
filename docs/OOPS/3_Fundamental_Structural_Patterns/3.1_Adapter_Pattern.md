---
topic: OOPS
section: Fundamental Structural Patterns
subtopic: Adapter Pattern
level: Intermediate
---

## Adapter Pattern
### Core Concepts

*   **Purpose:** To allow objects with incompatible interfaces to collaborate.
*   **Mechanism:** Creates a "wrapper" or "shim" around an existing object with an incompatible interface, exposing a compatible interface that clients expect.
*   **Structural Pattern:** Deals with object composition and relationships rather than behavior or creation.
*   **Analogy:** A universal adapter for electrical plugs in different countries.

### Key Details & Nuances

*   **Intent:** Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.
*   **Two Main Types:**
    *   **Object Adapter (Composition):** Uses composition to adapt an interface. The adapter holds an instance of the adaptee and delegates calls to it.
        *   **Advantage:** Allows adapting multiple classes (if the adaptee is an interface with multiple implementations). Can introduce new functionality not present in the adaptee.
    *   **Class Adapter (Inheritance):** Uses multiple inheritance (or single inheritance with interface implementation) to adapt an interface. The adapter inherits from both the target interface and the adaptee.
        *   **Advantage:** Tighter coupling. Can override some of the adaptee's behavior.
        *   **Disadvantage:** Less flexible; only works for classes, not interfaces. Not supported in languages like Java or C# without specific mechanisms.
*   **Participants:**
    *   **Target:** The interface that the client code uses.
    *   **Client:** The class that uses the Target interface.
    *   **Adaptee:** The existing class with an incompatible interface.
    *   **Adapter:** The class that implements the Target interface and contains an instance of the Adaptee.

### Practical Examples

Consider a system that needs to log messages, but has an existing logging library with a different method signature.

```typescript
// Adaptee: Existing logging library
class OldLogger {
  logMessage(msg: string): void {
    console.log(`[OLD LOG] ${msg}`);
  }
}

// Target: The interface our client code expects
interface NewLogger {
  info(message: string): void;
  error(message: string): void;
}

// Adapter: Implements the Target interface and uses the Adaptee
class LoggerAdapter implements NewLogger {
  private oldLogger: OldLogger;

  constructor(oldLogger: OldLogger) {
    this.oldLogger = oldLogger;
  }

  info(message: string): void {
    this.oldLogger.logMessage(`INFO: ${message}`);
  }

  error(message: string): void {
    this.oldLogger.logMessage(`ERROR: ${message}`);
  }
}

// Client code
class Application {
  private logger: NewLogger;

  constructor(logger: NewLogger) {
    this.logger = logger;
  }

  run() {
    this.logger.info("Application started.");
    // ... some operations ...
    this.logger.error("An error occurred.");
  }
}

// Usage
const oldLoggerInstance = new OldLogger();
const adapter = new LoggerAdapter(oldLoggerInstance);
const app = new Application(adapter);
app.run();
```

### Common Pitfalls & Trade-offs

*   **Over-adaptation:** Using the adapter pattern when a simple refactor of the client or adaptee would suffice.
*   **Complexity:** Can add an extra layer of indirection, potentially increasing complexity if overused.
*   **Class vs. Object Adapter:** Object adapters (composition) are generally preferred for flexibility and avoiding the limitations of multiple inheritance.
*   **Performance:** Minor overhead due to delegation, usually negligible.

### Interview Questions

1.  **When would you use the Adapter pattern, and what problem does it solve?**
    *   **Answer:** The Adapter pattern is used when you need to integrate two or more components with incompatible interfaces. It acts as a bridge, allowing objects that would otherwise be unable to collaborate to work together by converting the interface of one class into another interface that clients expect.

2.  **What is the difference between an object adapter and a class adapter? Which is generally preferred and why?**
    *   **Answer:** An object adapter uses composition by holding an instance of the adaptee, while a class adapter uses inheritance to adapt the adaptee. Object adapters are generally preferred because they are more flexible (can adapt multiple classes if the adaptee is an interface with multiple implementations) and don't tie the adapter to a specific implementation of the adaptee, promoting looser coupling. Class adapters, relying on inheritance, are less flexible and not supported in all object-oriented languages.

3.  **Can you explain the participants in the Adapter pattern?**
    *   **Answer:** The key participants are:
        *   **Target:** The interface that the client code expects and uses.
        *   **Client:** The class that uses the Target interface.
        *   **Adaptee:** The existing class with an incompatible interface that needs to be adapted.
        *   **Adapter:** The class that implements the Target interface and delegates requests to an instance of the Adaptee.

4.  **How does the Adapter pattern relate to the Facade pattern?**
    *   **Answer:** Both patterns provide new interfaces. However, the Adapter pattern's goal is to make existing interfaces compatible, often for third-party libraries or legacy code. It typically adapts one or a few classes. The Facade pattern, on the other hand, aims to simplify a complex subsystem by providing a single, unified interface, often composing multiple classes from that subsystem.