---
topic: OOPS
section: Fundamental Structural Patterns
subtopic: Proxy Pattern
level: Intermediate
---

## Proxy Pattern
### Core Concepts

*   **Intent:** Provide a surrogate or placeholder for another object to control access to it.
*   **Purpose:** Controls access to a *real subject* object.
*   **Real Subject:** The object that the proxy represents and provides access to.
*   **Proxy:** An object that exposes the same interface as the Real Subject, but also controls access to the Real Subject.

### Key Details & Nuances

*   **Interface Consistency:** The Proxy **must** implement the same interface as the Real Subject. This allows the client to interact with the Proxy without knowing it's not the actual object.
*   **Controlled Access:** The Proxy intercepts calls to the Real Subject. It can perform actions *before* delegating to the Real Subject, *after* the Real Subject returns, or even entirely *instead* of calling the Real Subject.
*   **When to Use:**
    *   **Virtual Proxies:** Lazy initialization (load object only when accessed).
    *   **Remote Proxies:** Represent an object in a different address space (e.g., network).
    *   **Protection Proxies:** Control access to the Real Subject based on permissions.
    *   **Smart References:** Perform additional actions when an object is accessed (e.g., reference counting, lazy loading).
    *   **Logging/Auditing:** Log method calls.
    *   **Caching:** Cache results of expensive operations.
*   **Composition over Inheritance:** Often implemented using composition to hold a reference to the Real Subject.

### Practical Examples

**Virtual Proxy (Lazy Loading)**

```typescript
// The Subject Interface
interface Image {
  display(): void;
}

// The Real Subject
class RealImage implements Image {
  private filename: string;

  constructor(filename: string) {
    this.filename = filename;
    this.loadImageFromDisk();
  }

  private loadImageFromDisk(): void {
    console.log(`Loading image from disk: ${this.filename}`);
    // Simulate expensive disk operation
  }

  display(): void {
    console.log(`Displaying image: ${this.filename}`);
  }
}

// The Proxy
class ProxyImage implements Image {
  private realImage: RealImage | null = null;
  private filename: string;

  constructor(filename: string) {
    this.filename = filename;
  }

  display(): void {
    if (this.realImage === null) {
      this.realImage = new RealImage(this.filename);
    }
    this.realImage.display();
  }
}

// Client Code
const image1: Image = new ProxyImage("photo1.jpg");
const image2: Image = new ProxyImage("photo2.jpg");

console.log("--- First display of image1 ---");
image1.display(); // Loads image1

console.log("\n--- Second display of image1 ---");
image1.display(); // Uses existing proxy, doesn't reload

console.log("\n--- First display of image2 ---");
image2.display(); // Loads image2
```

### Common Pitfalls & Trade-offs

*   **Performance Overhead:** Even simple proxies add a layer of indirection, which can introduce minor performance costs.
*   **Complexity:** Overusing proxies can make the system harder to understand and debug due to multiple layers of abstraction.
*   **Maintenance:** If the Real Subject's interface changes, the Proxy's interface must also change.
*   **Shared State Issues:** If multiple proxies refer to the same Real Subject, managing shared state (e.g., in smart proxies) can become complex.

### Interview Questions

1.  **Question:** When would you choose a Proxy pattern over a Decorator pattern?
    **Answer:** The Proxy pattern is primarily about *controlling access* to an object, often for reasons like lazy loading, security, or remote access. The Decorator pattern is about *adding responsibilities* to an object dynamically. While both add behavior, their core intent differs: Proxy manages access; Decorator enhances functionality. A proxy often represents *one* object, while a decorator can chain multiple decorators.

2.  **Question:** What are the different types of Proxies you are aware of, and in what scenarios would you use them?
    **Answer:**
    *   **Virtual Proxy:** For lazy initialization of heavy objects. Use when an object is expensive to create and might not be used immediately.
    *   **Remote Proxy:** To represent an object residing in a different address space (network). Use for distributed systems, allowing clients to interact with remote objects as if they were local.
    *   **Protection Proxy:** To enforce access rights. Use when different users have different permissions to access an object's methods.
    *   **Smart Reference Proxy:** To perform additional actions when an object is accessed, like reference counting or caching. Use for memory management or optimizing repeated access.

3.  **Question:** Explain how a Proxy can be used for logging API calls in a service.
    **Answer:** You would create a Proxy that implements the same interface as your service API. In the proxy's methods, you would log the method name, parameters, and potentially the timestamp before delegating the call to the actual service implementation. After the actual service returns, you could log the return value or any exceptions. This allows you to add logging without modifying the core service logic.

4.  **Question:** What are the advantages and disadvantages of using the Proxy pattern?
    **Answer:**
    *   **Advantages:** Controlled access, lazy initialization, enhanced security, abstraction of complex operations (like remote calls), added logging/auditing, caching.
    *   **Disadvantages:** Increased complexity, potential performance overhead due to indirection, tight coupling between proxy and subject if not carefully managed, can make debugging harder if not well-documented.