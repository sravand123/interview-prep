---
topic: OOPS
section: Fundamental Behavioral Patterns
subtopic: Strategy Pattern
level: Intermediate
---

## Strategy Pattern
### Core Concepts

*   **Strategy Pattern:** A behavioral design pattern that lets you define a family of algorithms, encapsulate each one, and make them interchangeable. It enables the algorithm to vary independently from clients that use it.
*   **Encapsulation of Algorithms:** Each algorithm (strategy) is implemented in a separate class, encapsulating the logic.
*   **Interchangeability:** The client code can choose and switch between different strategies at runtime without modifying the client itself.
*   **Decoupling:** Separates the context (which uses the strategy) from the concrete strategies.

### Key Details & Nuances

*   **Components:**
    *   **Context:** Maintains a reference to a Strategy object and delegates the behavior to it. The context does not know the concrete strategy class; it only knows about the strategy interface.
    *   **Strategy Interface/Abstract Class:** Declares a common interface for all supported algorithms. The Context uses this interface to call the algorithm defined by a ConcreteStrategy.
    *   **Concrete Strategies:** Implement the algorithm using the Strategy interface.
*   **When to Use:**
    *   When you have multiple related classes that differ only in their behavior (algorithms).
    *   When you need to swap algorithms at runtime.
    *   When an algorithm's variations are implemented in a class hierarchy, leading to many conditional statements.
    *   When you want to hide the complex variations of algorithms from the client.
*   **Flexibility vs. Boilerplate:** Offers significant flexibility but can introduce more classes and interfaces compared to simpler solutions.

### Practical Examples

**Scenario:** A payment processing system that supports different payment methods (Credit Card, PayPal, Bank Transfer).

```typescript
// Strategy Interface
interface PaymentStrategy {
    pay(amount: number): void;
}

// Concrete Strategies
class CreditCardPayment implements PaymentStrategy {
    private cardNumber: string;

    constructor(cardNumber: string) {
        this.cardNumber = cardNumber;
    }

    pay(amount: number): void {
        console.log(`Paying $${amount} using Credit Card ${this.cardNumber}`);
        // Actual credit card processing logic
    }
}

class PayPalPayment implements PaymentStrategy {
    private email: string;

    constructor(email: string) {
        this.email = email;
    }

    pay(amount: number): void {
        console.log(`Paying $${amount} using PayPal account ${this.email}`);
        // Actual PayPal processing logic
    }
}

class BankTransferPayment implements PaymentStrategy {
    private accountNumber: string;

    constructor(accountNumber: string) {
        this.accountNumber = accountNumber;
    }

    pay(amount: number): void {
        console.log(`Paying $${amount} via Bank Transfer to account ${this.accountNumber}`);
        // Actual bank transfer logic
    }
}

// Context
class ShoppingCart {
    private paymentStrategy: PaymentStrategy;
    private amount: number;

    constructor(amount: number) {
        this.amount = amount;
    }

    // Setter to change strategy at runtime
    setPaymentStrategy(strategy: PaymentStrategy): void {
        this.paymentStrategy = strategy;
    }

    checkout(): void {
        if (!this.paymentStrategy) {
            console.error("Please select a payment method.");
            return;
        }
        this.paymentStrategy.pay(this.amount);
    }
}

// Client Usage
const cart = new ShoppingCart(100);

// Using Credit Card
const creditCardStrategy = new CreditCardPayment("1234-5678-9012-3456");
cart.setPaymentStrategy(creditCardStrategy);
cart.checkout(); // Output: Paying $100 using Credit Card 1234-5678-9012-3456

// Switching to PayPal
const payPalStrategy = new PayPalPayment("user@example.com");
cart.setPaymentStrategy(payPalStrategy);
cart.checkout(); // Output: Paying $100 using PayPal account user@example.com
```

### Common Pitfalls & Trade-offs

*   **Increased Complexity:** Introduces more interfaces and classes, which can add boilerplate code and make the system harder to understand if overused.
*   **State Management:** If strategies have internal state, managing this state can become complex, especially when switching strategies. The context needs to handle passing necessary state or resetting it.
*   **Overuse:** Applying the Strategy pattern when a simple conditional (if-else or switch) would suffice can lead to unnecessary complexity. The benefit is in abstracting *families* of interchangeable algorithms, not just single algorithmic variations.

### Interview Questions

1.  **When would you choose the Strategy pattern over a simple if-else or switch statement?**
    *   **Answer:** When there are multiple, distinct algorithms that are likely to evolve independently, or when you need to select and swap algorithms at runtime. It's also beneficial when the algorithm logic is complex or when you want to avoid a large, monolithic conditional block that becomes hard to maintain. It promotes the Open/Closed Principle by allowing new strategies to be added without modifying the context.

2.  **Describe the main components of the Strategy pattern and their roles.**
    *   **Answer:**
        *   **Context:** The object that uses a strategy. It holds a reference to a Strategy object and delegates the execution of the algorithm to it. It doesn't know the concrete strategy's implementation.
        *   **Strategy Interface (or Abstract Class):** Defines the common interface for all concrete strategies, usually a single method representing the algorithm.
        *   **Concrete Strategies:** Implement the specific algorithms defined by the Strategy interface. Each concrete strategy provides a different behavior.

3.  **What are the advantages of using the Strategy pattern?**
    *   **Answer:**
        *   **Interchangeability of Algorithms:** Allows algorithms to be swapped dynamically at runtime.
        *   **Decoupling:** Separates the algorithm implementation from the context that uses it, reducing dependencies.
        *   **Open/Closed Principle:** New strategies can be added without modifying the existing context code.
        *   **Reduces Conditional Logic:** Eliminates complex conditional statements in the client or context by encapsulating algorithmic variations.
        *   **Encapsulates Algorithm Variations:** Hides the implementation details of different algorithms from the client.

4.  **Can you give an example of a situation where the Strategy pattern might be overkill?**
    *   **Answer:** If you only have two or three very simple, static algorithms that are unlikely to change or be swapped at runtime, a simple switch statement within the context class might be more appropriate. For instance, if a `Logger` class only supports writing to `Console` or `File` and these options are set at initialization and never changed, the overhead of creating separate strategy classes might not be justified.