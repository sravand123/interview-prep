---
topic: OOPS
section: Advanced Structural Patterns
subtopic: Composite Pattern
level: Advanced
---

## Composite Pattern
### Core Concepts

*   **Purpose:** Allows clients to treat individual objects and compositions of objects uniformly.
*   **Structure:** Organizes a hierarchy of objects where both individual objects (leaves) and composite objects (composites) share a common interface.
*   **Key Idea:** Enables recursion. Composites can contain other composites or leaves, forming a tree-like structure.

### Key Details & Nuances

*   **Common Interface/Abstract Class:** Defines operations applicable to both simple and complex objects. Crucially, this interface often includes methods that make sense only for composite objects (e.g., `add`, `remove`, `getChild`) but might throw exceptions or do nothing for leaf objects.
*   **Leaf Nodes:** Represents the simplest objects in the composition. They do not have children.
*   **Composite Nodes:** Represents objects that can have children (either other composites or leaves). They typically delegate operations to their children.
*   **Client Interaction:** The client code interacts with the common interface, unaware of whether it's dealing with a leaf or a composite. This promotes transparency and flexibility.
*   **"Principle of Least Astonishment":** Operations on leaf nodes that are intended for composites (like `add` or `remove`) should ideally do nothing or throw a specific error, rather than causing unexpected behavior.
*   **Recursion:** The pattern is inherently recursive, as composites contain other objects that can be either composites or leaves.

### Practical Examples

*   **File System Representation:**
    *   A file is a `Leaf`.
    *   A directory is a `Composite` that can contain files (`Leaf`) and other directories (`Composite`).
    *   An operation like `getSize()` could be called on any file or directory, recursively calculating the total size.

```typescript
// Common Interface
interface FileSystemComponent {
    getName(): string;
    getSize(): number;
    // Methods for composites, potentially do nothing/throw for leaves
    add(component: FileSystemComponent): void;
    remove(component: FileSystemComponent): void;
    getChild(index: number): FileSystemComponent;
}

// Leaf Node (File)
class File implements FileSystemComponent {
    private name: string;
    private size: number;

    constructor(name: string, size: number) {
        this.name = name;
        this.size = size;
    }

    getName(): string {
        return this.name;
    }

    getSize(): number {
        return this.size;
    }

    add(component: FileSystemComponent): void {
        // Files cannot have children
        throw new Error("Cannot add to a file.");
    }

    remove(component: FileSystemComponent): void {
        // Files cannot have children
        throw new Error("Cannot remove from a file.");
    }

    getChild(index: number): FileSystemComponent {
        // Files cannot have children
        throw new Error("Cannot get child from a file.");
    }
}

// Composite Node (Directory)
class Directory implements FileSystemComponent {
    private name: string;
    private children: FileSystemComponent[] = [];

    constructor(name: string) {
        this.name = name;
    }

    getName(): string {
        return this.name;
    }

    getSize(): number {
        return this.children.reduce((total, child) => total + child.getSize(), 0);
    }

    add(component: FileSystemComponent): void {
        this.children.push(component);
    }

    remove(component: FileSystemComponent): void {
        const index = this.children.indexOf(component);
        if (index !== -1) {
            this.children.splice(index, 1);
        }
    }

    getChild(index: number): FileSystemComponent {
        return this.children[index];
    }
}

// Client Usage
const rootDir = new Directory("Root");
const docsDir = new Directory("Documents");
const reportFile = new File("report.txt", 100);
const imageFile = new File("photo.jpg", 500);

docsDir.add(reportFile);
rootDir.add(docsDir);
rootDir.add(imageFile);

console.log(`Total size of ${rootDir.getName()}: ${rootDir.getSize()}`); // Output: Total size of Root: 600
```

### Common Pitfalls & Trade-offs

*   **Overly Generic Interface:** If the common interface includes many methods that are only meaningful for composites, leaf nodes might have to implement them with placeholder behavior (e.g., throwing errors), making the interface less clean.
*   **Performance:** For very deep or wide hierarchies, recursive operations can be costly. Consider memoization or iterative approaches if performance becomes an issue.
*   **Tight Coupling:** While the client is decoupled from specific concrete classes (File vs. Directory), the Composite class itself must know about the Leaf class to perform operations.
*   **Mutability:** Adding/removing elements from composites can lead to complex state management if not handled carefully.

### Interview Questions

1.  **Question:** When would you use the Composite pattern, and what problem does it solve?
    **Answer:** The Composite pattern is used when you need to represent a tree-like structure of objects where individual objects (leaves) and compositions of objects (composites) should be treated uniformly. It solves the problem of client code having to differentiate between these two types, allowing for a simpler, more flexible API. A classic example is a file system, where you can perform operations like `getSize()` on both files and directories without special handling.

2.  **Question:** What are the responsibilities of the Leaf and Composite classes in this pattern?
    **Answer:** The **Leaf** class represents the fundamental, primitive objects in the hierarchy. It implements the common interface but typically does not have children and may throw errors or do nothing for operations intended for composites (like `add` or `remove`). The **Composite** class represents objects that can contain other components (either leaves or other composites). It implements the common interface by delegating operations to its children and provides methods to manage its children (add, remove).

3.  **Question:** What are the potential drawbacks of the Composite pattern, particularly concerning the common interface?
    **Answer:** A significant drawback is the "Principle of Least Astonishment" issue with the common interface. If the interface includes methods primarily for composites (like `add`, `remove`), these methods often become non-operational or throw exceptions on leaf objects. This can make the interface overly broad and less intuitive for leaf nodes. Alternatively, one might introduce separate interfaces, breaking the uniformity the pattern aims to provide.

4.  **Question:** How does the Composite pattern promote flexibility and extensibility in a system?
    **Answer:** It promotes flexibility by allowing clients to work with a uniform interface, regardless of whether they are interacting with a single object or a complex structure. Extensibility is achieved because new types of components (e.g., a new kind of file or directory) can be added to the hierarchy without altering the existing client code, as long as they adhere to the common interface. The recursive nature also makes it easy to add new operations to the entire tree by simply defining them in the common interface.