---
topic: OOPS
section: Advanced Structural Patterns
subtopic: Bridge Pattern
level: Advanced
---

## Bridge Pattern
### Core Concepts

*   **Purpose:** Decouples an abstraction from its implementation so that the two can vary independently.
*   **Analogy:** Think of two separate entities that can work together. The abstraction is *what* you want to do, and the implementation is *how* you want to do it. The Bridge pattern allows you to swap the "how" without changing the "what."
*   **Structure:**
    *   **Abstraction:** Defines an abstract interface for the functionality. It holds a reference to an Implementor object.
    *   **Refined Abstraction:** Extends the Abstraction interface.
    *   **Implementor:** Defines an interface for the implementation classes.
    *   **Concrete Implementor:** Implements the Implementor interface.

### Key Details & Nuances

*   **Composition over Inheritance:** It favors composition by having the Abstraction *contain* an instance of the Implementor, rather than *inheriting* from it.
*   **Two-Tier Hierarchy:** Creates two independent class hierarchies (Abstraction and Implementor) that are linked together.
*   **Extensibility:** Allows for extending the abstraction and implementation independently. New abstractions can be created that use existing implementations, and new implementations can be created that are used by existing abstractions.
*   **"Handle-Body" Idiom:** Often described as a "handle-body" structure where the handle (Abstraction) delegates work to the body (Implementor).
*   **Use Cases:**
    *   When you want to avoid a permanent binding between an abstraction and its implementation.
    *   When changes to the implementation of an abstraction should not affect clients.
    *   When you want to hide the implementation details from clients.
    *   When you need to share an implementation among multiple objects.

### Practical Examples

Imagine a `RemoteControl` that can control different `TV` devices.

```typescript
// Implementor Interface
interface Device {
  turnOn(): void;
  turnOff(): void;
  setChannel(channel: number): void;
}

// Concrete Implementors
class Tv implements Device {
  private isOn = false;
  private currentChannel = 0;

  turnOn(): void {
    this.isOn = true;
    console.log("TV turned on");
  }

  turnOff(): void {
    this.isOn = false;
    console.log("TV turned off");
  }

  setChannel(channel: number): void {
    if (this.isOn) {
      this.currentChannel = channel;
      console.log(`TV channel set to ${channel}`);
    } else {
      console.log("TV is off, cannot set channel");
    }
  }
}

class Radio implements Device {
  private isOn = false;
  private currentFrequency = 0;

  turnOn(): void {
    this.isOn = true;
    console.log("Radio turned on");
  }

  turnOff(): void {
    this.isOn = false;
    console.log("Radio turned off");
  }

  setChannel(channel: number): void {
    if (this.isOn) {
      this.currentFrequency = channel; // Using channel to represent frequency
      console.log(`Radio frequency set to ${channel}`);
    } else {
      console.log("Radio is off, cannot set channel");
    }
  }
}

// Abstraction
abstract class RemoteControl {
  protected device: Device;

  constructor(device: Device) {
    this.device = device;
  }

  abstract turnOn(): void;
  abstract turnOff(): void;
  abstract nextChannel(): void;
  abstract prevChannel(): void;
}

// Refined Abstraction
class AdvancedRemoteControl extends RemoteControl {
  constructor(device: Device) {
    super(device);
  }

  turnOn(): void {
    this.device.turnOn();
  }

  turnOff(): void {
    this.device.turnOff();
  }

  nextChannel(): void {
    // Assuming setChannel can accept a new value representing "next"
    // In a real scenario, this might involve reading current channel from Device
    console.log("Moving to next channel...");
    this.device.setChannel(this.device.currentChannel + 1); // Simplified
  }

  prevChannel(): void {
    console.log("Moving to previous channel...");
    this.device.setChannel(this.device.currentChannel - 1); // Simplified
  }
}

// Client Usage
const tv = new Tv();
const radio = new Radio();

const tvRemote = new AdvancedRemoteControl(tv);
tvRemote.turnOn();
tvRemote.nextChannel(); // TV channel set to 1
tvRemote.nextChannel(); // TV channel set to 2
tvRemote.turnOff();

const radioRemote = new AdvancedRemoteControl(radio);
radioRemote.turnOn();
radioRemote.nextChannel(); // Radio frequency set to 1
radioRemote.turnOff();
```

### Common Pitfalls & Trade-offs

*   **Complexity:** Can increase the number of classes due to two hierarchies.
*   **Tight Coupling to Abstract:** While decoupling implementation, the abstraction is still tightly coupled to the *interface* of the implementor. Changes to the implementor's interface require changes in the abstraction.
*   **Overhead:** An extra level of indirection can sometimes introduce minor performance overhead compared to direct inheritance, though usually negligible in most applications.

### Interview Questions

1.  **Q: When would you choose the Bridge pattern over simple inheritance?**
    *   **A:** Use Bridge when you need to extend an abstraction and its implementation independently. If you have a large, complex hierarchy of abstractions that also have multiple, complex implementations, inheriting directly would lead to an explosion of subclasses (e.g., `AbstractShapeCircleRed`, `AbstractShapeCircleBlue`, `AbstractShapeSquareRed`, etc.). Bridge decouples these by creating two separate hierarchies, allowing you to combine any abstraction with any implementation. It's about avoiding combinatorial explosion.

2.  **Q: What is the primary advantage of the Bridge pattern?**
    *   **A:** The primary advantage is decoupling the abstraction from its implementation, allowing them to vary independently. This improves extensibility and maintainability, as you can add new implementations without altering the abstraction hierarchy, and vice-versa. It also promotes composition over inheritance.

3.  **Q: Can you explain the relationship between the Abstraction and Implementor in the Bridge pattern?**
    *   **A:** The Abstraction (or its refined versions) holds a reference to an Implementor object. The Abstraction delegates the actual work to this Implementor object. This creates a "has-a" relationship (composition) between the Abstraction and the Implementor. The Abstraction defines the high-level interface, while the Implementor provides the low-level details.

4.  **Q: How does the Bridge pattern address the problem of a growing class hierarchy?**
    *   **A:** It breaks down a single, large inheritance hierarchy into two smaller, independent hierarchies. One hierarchy represents the abstraction, and the other represents the implementation. By using composition, instances of the abstraction hierarchy can be coupled with instances of the implementation hierarchy, effectively "bridging" them. This avoids the combinatorial explosion of subclasses that would occur with direct inheritance.