---
topic: OOPS
section: Advanced Structural Patterns
subtopic: Flyweight Pattern
level: Advanced
---

## Flyweight Pattern
### Core Concepts

*   **Intent:** To support a large number of small objects efficiently by sharing common data among them.
*   **Problem:** When you have many objects that share identical or similar intrinsic state, creating a separate instance for each can lead to excessive memory consumption.
*   **Solution:** The Flyweight pattern identifies and extracts the *intrinsic state* (shared, immutable state) from objects and stores it in a central flyweight object. The extrinsic state (context-dependent, mutable state) remains with the client or the flyweight's context.

### Key Details & Nuances

*   **Intrinsic State:**
    *   Part of the object that can be shared among multiple client objects.
    *   Typically immutable.
    *   Examples: Character codes in text editors, font styles, color codes.
*   **Extrinsic State:**
    *   Part of the object that is unique to the client and cannot be shared.
    *   Must be passed to the flyweight object by the client for processing.
    *   Examples: Position of a character on the screen, formatting applied to a specific character instance.
*   **Flyweight Factory:**
    *   Manages the creation and reuse of flyweight objects.
    *   Clients request flyweight objects from the factory.
    *   If a flyweight with the requested intrinsic state already exists, the factory returns it; otherwise, it creates a new one, stores it, and returns it.
*   **Key Benefit:** Significant memory reduction when dealing with a vast number of objects with shared intrinsic state.
*   **Trade-off:** Increased complexity in managing the flyweight factory and passing extrinsic state. Potentially slightly higher processing overhead due to extrinsic state passing.

### Practical Examples

Consider a text editor where each character displayed on the screen is an object. Many characters might be identical (e.g., multiple 'a' characters with the same font and color).

```typescript
// Intrinsic State (shared)
interface CharacterStyle {
    fontFamily: string;
    fontSize: number;
    color: string;
}

// Flyweight Object
class Character {
    private style: CharacterStyle;
    private character: string;

    constructor(style: CharacterStyle, character: string) {
        this.style = style;
        this.character = character;
    }

    public display(x: number, y: number): void {
        // Extrinsic State: x, y position
        console.log(`Displaying character '${this.character}' with style {${this.style.fontFamily}, ${this.style.fontSize}, ${this.style.color}} at position (${x}, ${y})`);
    }
}

// Flyweight Factory
class CharacterFactory {
    private flyweights: Map<string, Character> = new Map();

    public getCharacter(style: CharacterStyle, character: string): Character {
        const key = `${character}-${style.fontFamily}-${style.fontSize}-${style.color}`;
        if (!this.flyweights.has(key)) {
            this.flyweights.set(key, new Character(style, character));
        }
        return this.flyweights.get(key)!;
    }

    public getFlyweightCount(): number {
        return this.flyweights.size;
    }
}

// Client Usage
const factory = new CharacterFactory();
const document: { char: Character, x: number, y: number }[] = [];

const style1: CharacterStyle = { fontFamily: "Arial", fontSize: 12, color: "black" };
const style2: CharacterStyle = { fontFamily: "Times New Roman", fontSize: 14, color: "blue" };

// Creating document characters
document.push({ char: factory.getCharacter(style1, 'H'), x: 0, y: 0 });
document.push({ char: factory.getCharacter(style1, 'e'), x: 10, y: 0 });
document.push({ char: factory.getCharacter(style1, 'l'), x: 20, y: 0 });
document.push({ char: factory.getCharacter(style1, 'l'), x: 30, y: 0 }); // Reused flyweight 'l'
document.push({ char: factory.getCharacter(style1, 'o'), x: 40, y: 0 });
document.push({ char: factory.getCharacter(style2, 'W'), x: 60, y: 0 });
document.push({ char: factory.getCharacter(style2, 'o'), x: 70, y: 0 }); // Reused flyweight 'o' (style2)

document.forEach(item => item.char.display(item.x, item.y));

console.log(`Total unique flyweight characters created: ${factory.getFlyweightCount()}`); // Should be less than total characters
```

### Common Pitfalls & Trade-offs

*   **Overhead of Extrinsic State:** If extrinsic state is complex or frequently modified, passing it around can become a performance bottleneck, potentially negating the memory benefits.
*   **Difficulty in Identification:** Properly identifying intrinsic vs. extrinsic state can be challenging and requires careful analysis of object properties.
*   **Factory Complexity:** The flyweight factory can become a complex piece of logic, especially with many types of flyweights or intricate sharing criteria.
*   **Mutable Intrinsic State:** If intrinsic state must be mutable, the pattern becomes much harder to implement correctly and can lead to race conditions or unexpected behavior if not managed carefully. The pattern is best suited for immutable intrinsic state.

### Interview Questions

1.  **Question:** When would you use the Flyweight pattern, and what are its primary benefits and drawbacks?
    *   **Answer:** Use Flyweight when an application uses a very large number of objects that consume significant memory, and these objects can be partially or wholly shared. The primary benefit is memory conservation. The main drawback is increased complexity in managing the flyweight factory and passing extrinsic state, which can also introduce a slight processing overhead.

2.  **Question:** How do you differentiate between intrinsic and extrinsic state in the context of the Flyweight pattern?
    *   **Answer:** Intrinsic state is data that is independent of the flyweight's context and can be shared among multiple objects (e.g., a font style for text). It's typically immutable. Extrinsic state is context-dependent and unique to each client object (e.g., the position of a character on a screen). It must be passed to the flyweight by the client.

3.  **Question:** Imagine you are building a game with thousands of identical trees. How would the Flyweight pattern help optimize memory usage?
    *   **Answer:** Each tree object would typically have properties like position, rotation, scale, and perhaps a reference to its visual mesh/model. The intrinsic state would be the shared visual mesh/model (geometry, textures). The extrinsic state would be the unique position, rotation, and scale for each tree instance. The Flyweight factory would manage a pool of shared tree models. Instead of storing the entire tree model data for every tree, only the intrinsic model reference and the extrinsic transformation data would be stored per tree instance, drastically reducing memory.