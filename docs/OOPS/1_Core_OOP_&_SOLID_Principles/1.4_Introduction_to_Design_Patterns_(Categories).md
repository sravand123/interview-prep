---
topic: OOPS
section: Core OOP & SOLID Principles
subtopic: Introduction to Design Patterns (Categories)
level: Beginner
---

## Introduction to Design Patterns (Categories)
### Core Concepts

*   **Object-Oriented Programming (OOP):** A programming paradigm based on the concept of "objects," which can contain data (fields, attributes, properties) and code (procedures, methods, functions).
    *   **Key Pillars:**
        *   **Encapsulation:** Bundling data and methods that operate on the data within a single unit (an object), and restricting direct access to some of the object's components. Hides implementation details.
        *   **Abstraction:** Hiding complex implementation details and showing only the essential features of the object. Deals with "what" an object does, not "how" it does it.
        *   **Inheritance:** A mechanism where a new class (subclass or derived class) inherits properties and behaviors from an existing class (superclass or base class). Promotes code reusability.
        *   **Polymorphism:** The ability of an object to take on many forms. Allows methods to perform the same action in different ways. Often achieved through method overriding and interfaces.

*   **SOLID Principles:** A set of five design principles intended to make software designs more understandable, flexible, and maintainable.
    *   **S**ingle Responsibility Principle (SRP): A class should have only one reason to change.
    *   **O**pen/Closed Principle (OCP): Software entities (classes, modules, functions) should be open for extension, but closed for modification.
    *   **L**iskov Substitution Principle (LSP): Subtypes must be substitutable for their base types without altering the correctness of the program.
    *   **I**nterface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they do not use. Prefer many client-specific interfaces over one general-purpose interface.
    *   **D**ependency Inversion Principle (DIP): High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.

*   **Design Patterns (Categories):** Reusable solutions to commonly occurring problems within a given context in software design. They are not finished designs that can be directly translated into code but rather descriptions or templates for how to solve a problem.
    *   **Creational Patterns:** Deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.
        *   *Examples:* Factory Method, Abstract Factory, Builder, Prototype, Singleton.
    *   **Structural Patterns:** Deal with class and object composition. They explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.
        *   *Examples:* Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.
    *   **Behavioral Patterns:** Deal with algorithms and the assignment of responsibilities between objects. They characterize how to model the ways that systems can be interacted with and how they distribute tasks.
        *   *Examples:* Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor.

### Key Details & Nuances

*   **Encapsulation:**
    *   Achieved via access modifiers (e.g., `public`, `private`, `protected`).
    *   Benefits: Data hiding, modularity, controlled access, reduced complexity.
*   **Abstraction:**
    *   Achieved via abstract classes and interfaces.
    *   Benefits: Simplifies complex systems by modeling classes appropriate to the problem, hides irrelevant details.
*   **Inheritance:**
    *   **"Is-a" relationship.**
    *   Consider composition over inheritance for greater flexibility.
    *   Potential issues: Tight coupling, brittle base classes, multiple inheritance complexities.
*   **Polymorphism:**
    *   **"Many forms."**
    *   **Compile-time (static):** Method overloading.
    *   **Run-time (dynamic):** Method overriding (virtual methods), interfaces.
    *   Allows treating objects of different classes in a uniform way.
*   **SOLID Principles in Practice:**
    *   **SRP:** A `User` class should handle user data, not also send emails. This separation prevents changes in email logic from breaking user data handling.
    *   **OCP:** Using an interface for a `PaymentProcessor`. To add a new payment method (e.g., PayPal), you create a new class implementing the interface, without modifying the existing `OrderProcessor` class.
    *   **LSP:** If a `Square` class inherits from `Rectangle`, and `Rectangle` has a `setWidth` and `setHeight` method, a `Square` instance might behave unexpectedly if `setWidth` also changes `height`. This violates LSP if a `Square` cannot be substituted for a `Rectangle` in all contexts.
    *   **ISP:** Don't force a `DocumentReader` interface to include `Write()` and `Save()` methods if the implementer only needs to read. Create separate `Readable` and `Writable` interfaces.
    *   **DIP:** Instead of `HighLevelModule` directly instantiating `LowLevelModule`, it should depend on an `ILowLevelModule` interface. A factory or dependency injection framework provides the concrete `LowLevelModule` implementation.
*   **Design Patterns - Purpose:**
    *   They provide a common vocabulary for developers.
    *   They represent established solutions to recurring design problems.
    *   They are not a silver bullet; use them judiciously when they solve a real problem.

### Practical Examples

*   **Polymorphism with Interfaces (TypeScript):**

    ```typescript
    interface Shape {
        getArea(): number;
    }

    class Circle implements Shape {
        constructor(private radius: number) {}
        getArea(): number {
            return Math.PI * this.radius ** 2;
        }
    }

    class Square implements Shape {
        constructor(private sideLength: number) {}
        getArea(): number {
            return this.sideLength ** 2;
        }
    }

    function printShapeArea(shape: Shape): void {
        console.log(`Area: ${shape.getArea()}`);
    }

    const myCircle = new Circle(5);
    const mySquare = new Square(4);

    printShapeArea(myCircle); // Output: Area: 78.5398...
    printShapeArea(mySquare); // Output: Area: 16
    ```

*   **OCP violation and fix (Conceptual):**

    ```mermaid
    graph TD;
        A["OrderProcessor"] --> B["ProcessCreditCard"];
        B --> C["PaymentGateway"];
        A --> D["ProcessDebitCard"];
        D --> C;
    ```
    *   **Violation:** `OrderProcessor` directly depends on specific payment card types. Adding a new payment method (e.g., PayPal) requires modifying `OrderProcessor`.
    *   **Fix:** Introduce a `PaymentStrategy` interface. `OrderProcessor` depends on `PaymentStrategy`. Specific payment classes (`CreditCardPayment`, `DebitCardPayment`, `PayPalPayment`) implement `PaymentStrategy`.

### Common Pitfalls & Trade-offs

*   **Overuse of Inheritance:** Can lead to tight coupling, making it difficult to change base classes and potentially creating deep, complex hierarchies. Composition often offers more flexibility.
*   **"God Objects" / Violating SRP:** Classes that do too much become hard to understand, test, and maintain. Changes in one area can unexpectedly impact others.
*   **Misapplying Design Patterns:** Using a pattern just because it's a pattern, without a clear problem it solves, can add unnecessary complexity.
*   **LSP Violations:** Can lead to runtime errors or unexpected behavior when subtypes are used in place of base types. Rigorous testing of subtype behavior is crucial.
*   **Abstractions too broad (ISP violation):** Can lead to classes implementing methods they don't need, making code less clean and potentially introducing errors if those unused methods are called.

### Interview Questions

1.  **Question:** Explain the Liskov Substitution Principle and provide an example of how it might be violated and what the consequences are.
    **Answer:** The Liskov Substitution Principle (LSP) states that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. A violation occurs when a subclass's behavior deviates from its superclass in a way that breaks expectations. For instance, if a `Rectangle` class has `setWidth` and `setHeight` methods, and a `Square` subclass inherits from `Rectangle` but enforces that `width` always equals `height`, calling `setWidth` might also change the `height`. If a client code expects to be able to set width and height independently, this `Square` implementation would violate LSP, potentially causing bugs when a `Square` is used where a `Rectangle` is expected.

2.  **Question:** How do the SOLID principles help in building maintainable and scalable software?
    **Answer:** SOLID principles promote modularity, flexibility, and understandability, which are key to maintainability and scalability.
    *   **SRP** (Single Responsibility Principle) makes modules easier to change and test because they have fewer reasons to change.
    *   **OCP** (Open/Closed Principle) allows adding new functionality without modifying existing, tested code, reducing the risk of introducing regressions.
    *   **LSP** (Liskov Substitution Principle) ensures that inheritance hierarchies are sound, preventing unexpected runtime behavior and increasing confidence in code reuse.
    *   **ISP** (Interface Segregation Principle) prevents bloated interfaces, making clients only dependent on what they actually need, leading to more cohesive and loosely coupled designs.
    *   **DIP** (Dependency Inversion Principle) decouples high-level modules from low-level implementation details through abstractions, making it easier to swap out dependencies and test components in isolation. Together, these principles reduce complexity and improve adaptability to change.

3.  **Question:** Differentiate between Composition and Inheritance. When would you favor one over the other?
    **Answer:**
    *   **Inheritance (Is-a relationship):** A subclass inherits properties and methods from a superclass. It creates a strong coupling between classes. It's good for when there's a clear hierarchical "is-a" relationship (e.g., `Dog` is an `Animal`).
    *   **Composition (Has-a relationship):** A class contains an instance of another class and delegates behavior to it. It promotes loose coupling and flexibility. It's good for when a class *uses* or *has* another object (e.g., a `Car` has an `Engine`).

    **Favor Composition over Inheritance** when:
    *   You want flexibility to change behavior at runtime.
    *   You want to avoid tight coupling or the complexities of deep inheritance hierarchies.
    *   The relationship is more about "has-a" or "uses-a" rather than "is-a".
    *   You need to inherit from multiple types (composition allows this through delegation).

    Inheritance is favored when the "is-a" relationship is strong, well-defined, and unlikely to change, and when you want to share common behavior across closely related types.