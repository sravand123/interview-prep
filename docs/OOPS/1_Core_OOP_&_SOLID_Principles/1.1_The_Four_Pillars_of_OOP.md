---
topic: OOPS
section: Core OOP & SOLID Principles
subtopic: The Four Pillars of OOP
level: Beginner
---

## The Four Pillars of OOP
### Core Concepts

*   **Object-Oriented Programming (OOP):** A programming paradigm based on the concept of "objects," which can contain data (in the form of fields, often known as attributes or properties) and code (in the form of procedures, often known as methods).
*   **Four Pillars of OOP:**
    *   **Encapsulation:** Bundling data (attributes) and methods that operate on the data within a single unit (an object/class). It controls access to the internal state of an object, often by making attributes private and providing public methods (getters/setters) to interact with them.
    *   **Abstraction:** Hiding complex implementation details and exposing only the essential features or functionalities to the user. Users interact with objects through a well-defined interface without needing to know *how* it works internally.
    *   **Inheritance:** A mechanism where a new class (subclass/derived class) inherits properties and behaviors (attributes and methods) from an existing class (superclass/base class). Promotes code reusability and establishes a hierarchical relationship.
    *   **Polymorphism:** The ability of an object to take on many forms. It allows objects of different classes to be treated as objects of a common superclass. Common forms include method overloading (compile-time) and method overriding (run-time).

### Key Details & Nuances

*   **Encapsulation:**
    *   **Data Hiding:** Protects an object's internal state from direct external modification, preventing unintended side effects.
    *   **Interface:** Provides a controlled way to access and modify the data, promoting maintainability and flexibility. Changes to internal implementation don't break external code if the interface remains the same.
*   **Abstraction:**
    *   **Abstract Classes vs. Interfaces:**
        *   **Abstract Classes:** Can have implemented methods and fields. A subclass must implement all abstract methods. Supports single inheritance.
        *   **Interfaces:** Define a contract (methods with no implementation). A class implements an interface. Supports multiple inheritance of type.
    *   **Reduces Complexity:** Simplifies interaction with objects by presenting a higher-level view.
*   **Inheritance:**
    *   **"Is-a" Relationship:** Represents a specialization (e.g., `Dog` "is a" `Animal`).
    *   **Code Reusability:** Avoids redundant code by sharing common functionality.
    *   **Composition vs. Inheritance:**
        *   **Composition:** "Has-a" relationship. An object contains another object. Favored over inheritance when flexibility and avoiding tight coupling are priorities. (e.g., `Car` "has an" `Engine`).
        *   **Inheritance:** Can lead to rigid hierarchies and the "fragile base class" problem where changes in the base class can break derived classes.
*   **Polymorphism:**
    *   **Method Overriding:** A subclass provides a specific implementation of a method that is already defined in its superclass. Requires the method signature to be the same.
    *   **Method Overloading:** Defining multiple methods in the same class with the same name but different parameter lists (number, type, or order of parameters). This is resolved at compile time.
    *   **Dynamic Dispatch:** The decision of which method implementation to call is made at runtime based on the actual type of the object, not its declared type.

### Practical Examples

*   **Encapsulation & Abstraction (TypeScript):**

```typescript
class BankAccount {
    private balance: number; // Encapsulation: Hides the balance

    constructor(initialBalance: number = 0) {
        this.balance = initialBalance;
    }

    // Abstraction: Provides a controlled way to get the balance
    getBalance(): number {
        return this.balance;
    }

    // Abstraction: Provides a controlled way to deposit
    deposit(amount: number): void {
        if (amount > 0) {
            this.balance += amount;
            console.log(`Deposited: ${amount}`);
        } else {
            console.log("Deposit amount must be positive.");
        }
    }

    // Abstraction: Provides a controlled way to withdraw
    withdraw(amount: number): boolean {
        if (amount > 0 && amount <= this.balance) {
            this.balance -= amount;
            console.log(`Withdrew: ${amount}`);
            return true;
        } else {
            console.log("Insufficient funds or invalid amount.");
            return false;
        }
    }
}

const myAccount = new BankAccount(1000);
console.log(myAccount.getBalance()); // Output: 1000
myAccount.deposit(500);             // Output: Deposited: 500
myAccount.withdraw(200);            // Output: Withdrew: 200
// console.log(myAccount.balance);  // Error: Property 'balance' is private
```

*   **Inheritance & Polymorphism (TypeScript):**

```typescript
// Base Class
class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }

    // Method that can be overridden
    makeSound(): void {
        console.log("Some generic animal sound");
    }
}

// Derived Class 1
class Dog extends Animal {
    constructor(name: string) {
        super(name); // Call base class constructor
    }

    // Overriding makeSound
    makeSound(): void {
        console.log("Woof! Woof!");
    }
}

// Derived Class 2
class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }

    // Overriding makeSound
    makeSound(): void {
        console.log("Meow!");
    }
}

function animalSound(animal: Animal): void {
    animal.makeSound(); // Polymorphism: Calls the appropriate makeSound based on the actual object type
}

const genericAnimal = new Animal("Creature");
const myDog = new Dog("Buddy");
const myCat = new Cat("Whiskers");

animalSound(genericAnimal); // Output: Some generic animal sound
animalSound(myDog);         // Output: Woof! Woof!
animalSound(myCat);         // Output: Meow!
```

### Common Pitfalls & Trade-offs

*   **Overuse of Inheritance:** Can lead to deep, rigid hierarchies that are hard to maintain and extend. Favor composition for flexibility and to avoid the "is-a" versus "has-a" confusion.
*   **Not Enforcing Encapsulation:** Exposing internal state directly (e.g., making all properties public) defeats the purpose of encapsulation, leading to brittle code.
*   **Forgetting Polymorphism:** Not designing methods to be overrideable in base classes means subclasses cannot provide specialized behavior, limiting the benefits of inheritance.
*   **Tight Coupling:** Inheritance creates a strong dependency between base and derived classes. Changes in the base class can break derived classes ("fragile base class problem"). Composition offers looser coupling.
*   **Abstraction Leakage:** When internal implementation details become visible or affect how a class is used, the abstraction is compromised.

### Interview Questions

1.  **Question:** Explain the four pillars of OOP with practical examples and discuss when you might prefer composition over inheritance.
    **Answer:** The four pillars are Encapsulation (bundling data/methods, data hiding via private members), Abstraction (hiding complexity, exposing interfaces), Inheritance (code reuse, "is-a" relationship), and Polymorphism (objects taking many forms, e.g., method overriding). Composition (an object "has-a" another object) is often preferred over inheritance when flexibility is key, to avoid tight coupling, and to prevent issues like the fragile base class problem. For example, a `Car` *has an* `Engine` (composition), rather than a `Car` *is a* `Engine` (inheritance).

2.  **Question:** What is the difference between abstract classes and interfaces, and in what scenarios would you use one over the other?
    **Answer:** An abstract class can contain both abstract (unimplemented) and concrete (implemented) methods, as well as fields. A subclass inherits from one abstract class (single inheritance). An interface, conversely, defines a contract—methods with no implementation—and a class can implement multiple interfaces (multiple inheritance of type). I'd use an abstract class when I want to provide a common base implementation and structure that subclasses can extend and specialize. I'd use an interface when I want to define a capability or a contract that unrelated classes can adhere to, enabling polymorphism without dictating implementation details.

3.  **Question:** Describe a situation where you encountered the "fragile base class" problem and how you resolved it.
    **Answer:** In a legacy system, a `PaymentProcessor` base class had a method `process()`. Derived classes like `CreditCardProcessor` and `PayPalProcessor` extended it. A change was made to the `process()` method in `PaymentProcessor` to add logging, but it inadvertently altered the expected behavior of subclasses that relied on specific internal calls or assumptions within `process()`. To resolve this, we could refactor the base class to use composition, extract common logic into helper classes, or ensure that the `process()` method was designed with clear extension points (e.g., using template method pattern) where subclasses could plug in their specific logic without being overly coupled to the base's internal implementation. Often, a better solution would involve using composition to delegate parts of the processing logic, rather than direct inheritance.

4.  **Question:** How does polymorphism aid in writing flexible and maintainable code? Provide an example.
    **Answer:** Polymorphism allows treating objects of different classes uniformly through a common superclass or interface. This means you can write code that operates on the supertype without knowing the specific subtype. When new subtypes are added, the existing code that uses the supertype doesn't need to be modified, promoting extensibility and reducing maintenance overhead. For example, a function that accepts an `Animal` type can process `Dog`, `Cat`, or any new `Bird` type without modification, as long as they all implement `makeSound()`. This is key for frameworks and plug-in architectures.