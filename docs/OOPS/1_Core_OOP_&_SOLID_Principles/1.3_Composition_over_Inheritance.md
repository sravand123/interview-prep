---
topic: OOPS
section: Core OOP & SOLID Principles
subtopic: Composition over Inheritance
level: Beginner
---

## Composition over Inheritance
### Core Concepts

*   **Composition over Inheritance:** A design principle that favors **"has-a"** relationships over **"is-a"** relationships. Instead of a class inheriting behavior from a parent class, it **contains** instances of other classes and **delegates** work to them.
*   **Favors Flexibility:** Promotes more modular, reusable, and adaptable code.
*   **Avoids Tight Coupling:** Reduces dependencies between classes, making them easier to change and maintain independently.

### Key Details & Nuances

*   **"Has-A" vs. "Is-A":**
    *   **Inheritance ("Is-A"):** `Dog` **is a** `Animal`. Represents a strict type hierarchy.
    *   **Composition ("Has-A"):** A `Car` **has an** `Engine`. A `Car` object contains an `Engine` object.
*   **Benefits of Composition:**
    *   **Flexibility:** Can change the behavior at runtime by swapping out component objects.
    *   **Reusability:** Components can be reused across different classes and hierarchies.
    *   **Maintainability:** Easier to modify or extend functionality without affecting unrelated parts of the system.
    *   **Testability:** Easier to mock or stub individual components for unit testing.
*   **When Inheritance Might Still Be Okay (but composition is often preferred):**
    *   When the relationship is truly an "is-a" and the subclass is a specialized version of the superclass (e.g., `Manager` is a `Employee`).
    *   When sharing implementation details that are unlikely to change and are fundamental to the derived class's identity.
    *   When dealing with abstract concepts where a clear hierarchy makes sense.
*   **Delegation:** The core mechanism in composition. An object that has another object as a component will call methods on that component object to perform certain tasks.

### Practical Examples

*   **Scenario:** Building a `Robot` that can perform actions like `walk` and `fly`.

*   **Inheritance (Less Flexible):**

    ```typescript
    // Less flexible: If a Robot needs to fly, it *is* a FlyingRobot
    class Flyer {
      fly() {
        console.log("Flying...");
      }
    }

    class Robot {
      walk() {
        console.log("Walking...");
      }
    }

    class FlyingRobot extends Robot {
      private flyer: Flyer; // Still needs composition if not inheriting flyer behavior directly

      constructor() {
        super();
        this.flyer = new Flyer();
      }

      fly() {
        this.flyer.fly();
      }
    }

    // Problem: What if a robot can BOTH walk and fly?
    // What if it needs to switch abilities?
    ```

*   **Composition (More Flexible):**

    ```typescript
    // Core components with specific behaviors
    class Walker {
      walk() {
        console.log("Walking...");
      }
    }

    class Flyer {
      fly() {
        console.log("Flying...");
      }
    }

    class Swimmer {
      swim() {
        console.log("Swimming...");
      }
    }

    // Robot class composed of behavioral components
    class Robot {
      private walker: Walker | null = null;
      private flyer: Flyer | null = null;
      private swimmer: Swimmer | null = null;

      constructor(behaviors: { walker?: boolean; flyer?: boolean; swimmer?: boolean }) {
        if (behaviors.walker) {
          this.walker = new Walker();
        }
        if (behaviors.flyer) {
          this.flyer = new Flyer();
        }
        if (behaviors.swimmer) {
          this.swimmer = new Swimmer();
        }
      }

      performWalk() {
        if (this.walker) {
          this.walker.walk();
        } else {
          console.log("Cannot walk.");
        }
      }

      performFly() {
        if (this.flyer) {
          this.flyer.fly();
        } else {
          console.log("Cannot fly.");
        }
      }

      performSwim() {
        if (this.swimmer) {
          this.swimmer.swim();
        } else {
          console.log("Cannot swim.");
        }
      }
    }

    // Creating different robots with different abilities
    const basicRobot = new Robot({ walker: true });
    basicRobot.performWalk(); // Outputs: Walking...
    basicRobot.performFly();  // Outputs: Cannot fly.

    const flyingRobot = new Robot({ walker: true, flyer: true });
    flyingRobot.performWalk(); // Outputs: Walking...
    flyingRobot.performFly();  // Outputs: Flying...

    const amphibiousRobot = new Robot({ walker: true, swimmer: true });
    amphibiousRobot.performWalk(); // Outputs: Walking...
    amphibiousRobot.performSwim(); // Outputs: Swimming...
    ```

*   **Mermaid Diagram illustrating composition:**

    ```mermaid
    graph TD;
        A["Robot Class"] --> B["Walker Component (has-a)"];
        A --> C["Flyer Component (has-a)"];
        A --> D["Swimmer Component (has-a)"];
        B --> E["walk() Method"];
        C --> F["fly() Method"];
        D --> G["swim() Method"];
    ```

### Common Pitfalls & Trade-offs

*   **Pitfall: Over-composition / Boilerplate:** If a composed object simply delegates every call to its component, it can lead to a lot of boilerplate code. This can sometimes be mitigated with patterns like the **Facade** or by carefully considering which methods truly need delegation.
*   **Pitfall: "Composition Over Inheritance" as a Dogma:** While generally good, there are still valid use cases for inheritance, especially for establishing clear type hierarchies or when dealing with framework base classes. The key is to choose the right tool for the job.
*   **Trade-off: Memory Overhead:** Composition often involves creating multiple small objects, which *can* have a slightly higher memory footprint compared to a single, large inherited class. However, this is usually a minor concern compared to the flexibility gained.
*   **Trade-off: Runtime Complexity:** Deciding which component to use might add a small amount of runtime overhead if not managed well (e.g., checking for `null` before calling a method), but this is typically negligible.

### Interview Questions

1.  **Question:** Explain the difference between composition and inheritance, and provide an example where composition is clearly superior.
    *   **Answer:** Inheritance models an "is-a" relationship, creating a tight coupling and a rigid type hierarchy. Composition models a "has-a" relationship, favoring flexible "is-capable-of" relationships. For example, a `Car` "is-a" `Vehicle` (inheritance might apply), but a `Car` "has-an" `Engine`, "has-wheels", and "has-a-color" (composition). If we need a `Car` that can switch its `Engine` type (e.g., from gasoline to electric) at runtime, composition is superior because we can swap the `Engine` object. Inheritance would require creating entirely new `ElectricCar` classes, leading to code duplication and inflexibility.

2.  **Question:** When might you choose inheritance over composition?
    *   **Answer:** Inheritance is suitable when a class is a true subtype of another and you want to enforce that subtype relationship, often for polymorphism (e.g., `ArrayList` and `LinkedList` both inherit from `List` in Java). It's also useful when the parent class's behavior is fundamental and unlikely to change, and the subclass is a specialized version that shares most of its identity. However, even in these cases, one should consider if composition with interfaces can achieve similar polymorphism with less coupling.

3.  **Question:** How does composition improve code maintainability and testability?
    *   **Answer:** Composition improves maintainability by reducing dependencies. If a component (e.g., a `Logger` class) needs to be changed, only the `Logger` class and the classes that directly use it need to be modified. Other parts of the system remain unaffected. For testability, composition allows for easy dependency injection and mocking. During unit testing, you can inject mock implementations of the composed components, isolating the class under test and verifying its logic without relying on the actual behavior of its dependencies.

4.  **Question:** Can you describe the concept of delegation in the context of composition?
    *   **Answer:** Delegation is the mechanism by which a composing object passes on a request to one of its contained objects (components). For instance, a `Robot` object might have a `Walker` object. When the `Robot`'s `walk()` method is called, it doesn't implement the walking logic itself; instead, it **delegates** the call to its `Walker` component by calling `this.walker.walk()`. This allows the `Robot` class to remain lean while leveraging the functionality of its components.