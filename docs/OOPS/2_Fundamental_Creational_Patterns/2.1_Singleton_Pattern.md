---
topic: OOPS
section: Fundamental Creational Patterns
subtopic: Singleton Pattern
level: Intermediate
---

## Singleton Pattern
### Core Concepts

*   **Purpose:** Ensures a class has only one instance and provides a global point of access to it.
*   **Use Cases:** Managing shared resources like database connections, configuration settings, or logging services.
*   **Creational Pattern:** Focuses on how objects are created.

### Key Details & Nuances

*   **Encapsulation:** The class controls its own instantiation.
*   **Private Constructor:** Prevents direct instantiation from outside the class.
*   **Static Instance:** Holds the single instance of the class.
*   **Static Access Method:** Provides a way to get the single instance, creating it if it doesn't exist yet (lazy initialization).
*   **Thread Safety:** Crucial in multi-threaded environments. Without proper synchronization, multiple threads might create multiple instances.

### Practical Examples

```typescript
class Singleton {
    private static instance: Singleton | null = null;
    private data: string;

    // Private constructor to prevent direct instantiation
    private constructor(data: string) {
        this.data = data;
        console.log("Singleton instance created.");
    }

    // Static method to get the single instance
    public static getInstance(data: string): Singleton {
        if (Singleton.instance === null) {
            Singleton.instance = new Singleton(data);
        }
        return Singleton.instance;
    }

    public getData(): string {
        return this.data;
    }
}

// Usage
const instance1 = Singleton.getInstance("Initial Data");
const instance2 = Singleton.getInstance("New Data"); // Data will not be updated, same instance

console.log(instance1.getData()); // Output: Initial Data
console.log(instance2.getData()); // Output: Initial Data
console.log(instance1 === instance2); // Output: true
```

### Common Pitfalls & Trade-offs

*   **Global State:** Can lead to tight coupling and make testing difficult. Dependencies become implicit.
*   **Testability:** Mocking or stubbing a Singleton for unit testing can be challenging.
*   **Lazy Initialization vs. Eager Initialization:**
    *   **Lazy:** Instance created only when first requested. May incur a slight performance overhead on the first access. Requires thread-safe checks.
    *   **Eager:** Instance created when the class is loaded. Simpler, inherently thread-safe in many languages (e.g., Java, C#), but the resource is always initialized.
*   **Concurrency Issues:** Without proper synchronization (e.g., `synchronized` keyword in Java, `lock` mechanisms, or atomic operations), multiple threads might create separate instances. In JavaScript, single-threaded nature simplifies this, but in environments like Node.js with worker threads, it's a concern.

### Interview Questions

1.  **"Explain the Singleton pattern and provide a real-world scenario where it's useful."**
    *   **Answer:** The Singleton pattern ensures a class has only one instance and provides a global access point. It's useful for managing shared resources like a database connection pool, a global configuration manager, or a logging service, where having multiple instances would be detrimental or inefficient.

2.  **"How do you implement a thread-safe Singleton?"**
    *   **Answer:** In languages with explicit threading models, thread safety is achieved using synchronization mechanisms. Common approaches include:
        *   **Double-Checked Locking:** Synchronize the check and creation, but it can be complex and prone to errors if not implemented perfectly.
        *   **Initialization on Demand Holder Idiom (Java):** A static inner class holds the instance, initialized only when the inner class is loaded.
        *   **Atomic operations or language-specific constructs:** Many modern languages offer simpler, built-in ways to ensure atomic initialization.
        *   In single-threaded environments like typical browser JavaScript, the basic implementation is often sufficient.

3.  **"What are the main drawbacks of using the Singleton pattern?"**
    *   **Answer:** The primary drawbacks are:
        *   **Increased Global State:** Makes code harder to reason about and can lead to hidden dependencies.
        *   **Reduced Testability:** Singletons are difficult to mock or stub in unit tests, making isolation challenging.
        *   **Violation of Single Responsibility Principle:** The class is responsible for both its core logic and managing its own lifecycle/uniqueness.
        *   **Can hide dependencies:** Instead of explicitly passing an instance, code might just rely on the global Singleton, making the true dependencies unclear.