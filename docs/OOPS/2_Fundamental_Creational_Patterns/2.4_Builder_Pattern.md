---
topic: OOPS
section: Fundamental Creational Patterns
subtopic: Builder Pattern
level: Intermediate
---

## Builder Pattern
### Core Concepts

*   **Intent:** To separate the construction of a complex object from its representation, allowing the same construction process to create different representations.
*   **Problem Solved:** Addresses the "telescoping constructor" anti-pattern where constructors have many parameters, or when an object requires a complex, multi-step initialization.
*   **Key Idea:** Uses a separate `Builder` object to manage the construction process. The `Builder` exposes methods to set individual components of the complex object, and a final `build()` method returns the constructed object.

### Key Details & Nuances

*   **Immutability:** Often used to create immutable objects, as all properties are set before the `build()` method is called.
*   **Readability:** Significantly improves code readability by making the object creation process explicit and self-documenting.
*   **Flexibility:** Allows for optional parameters and different combinations of parameters to be set easily without needing multiple constructors.
*   **Builder vs. Factory:**
    *   **Builder:** Focuses on step-by-step construction of a *single, complex object*. The client often controls the construction steps.
    *   **Factory:** Focuses on creating *instances of a family of objects* based on some criteria. The factory hides the instantiation logic.
*   **Fluent Interface:** Builders often implement a fluent interface (method chaining) for a more concise and readable construction syntax.

### Practical Examples

#### TypeScript Example

```typescript
// The complex object we want to build
class Burger {
    public readonly size: string;
    public readonly cheese: boolean;
    public readonly vegetables: string[];
    public readonly sauce: string | null;

    constructor(builder: BurgerBuilder) {
        this.size = builder.size;
        this.cheese = builder.cheese;
        this.vegetables = [...builder.vegetables]; // Defensive copy
        this.sauce = builder.sauce;
    }
}

// The Builder class
class BurgerBuilder {
    public size: string = "medium";
    public cheese: boolean = false;
    public vegetables: string[] = [];
    public sauce: string | null = null;

    public setSize(size: string): BurgerBuilder {
        this.size = size;
        return this;
    }

    public addCheese(): BurgerBuilder {
        this.cheese = true;
        return this;
    }

    public addVegetable(vegetable: string): BurgerBuilder {
        this.vegetables.push(vegetable);
        return this;
    }

    public setSauce(sauce: string): BurgerBuilder {
        this.sauce = sauce;
        return this;
    }

    public build(): Burger {
        return new Burger(this);
    }
}

// Usage
const myBurger = new BurgerBuilder()
    .setSize("large")
    .addCheese()
    .addVegetable("lettuce")
    .addVegetable("tomato")
    .setSauce("ketchup")
    .build();

console.log(myBurger);
```

### Common Pitfalls & Trade-offs

*   **Overhead:** For very simple objects, the Builder pattern can introduce unnecessary complexity and boilerplate code.
*   **Builder State:** Care must be taken to ensure the builder's state is managed correctly, especially if it's reused or mutable across different build operations.
*   **Readability vs. Number of Methods:** A builder with too many `set` methods can become verbose. Grouping related settings or using named parameters (if the language supports it) can help.
*   **Mandatory vs. Optional Parameters:** Clearly distinguish between parameters that *must* be set by the builder before `build()` is called and those that are optional.

### Interview Questions

1.  **When would you choose the Builder pattern over other creational patterns like Factory Method or Abstract Factory?**
    *   **Answer:** The Builder pattern is ideal when you need to construct a complex object step-by-step, and the process might vary or involve many optional parameters. It excels at creating immutable objects and improving the readability of object instantiation, especially avoiding telescoping constructors. Factory patterns are for creating families of related objects, abstracting the instantiation process itself.

2.  **What are the main benefits of using the Builder pattern for object creation?**
    *   **Answer:** Key benefits include: separating construction logic from the representation, enabling step-by-step object building, supporting the creation of immutable objects, improving code readability by making the creation process explicit, and handling numerous optional parameters gracefully.

3.  **Can you explain the concept of a "fluent interface" in the context of the Builder pattern, and why it's beneficial?**
    *   **Answer:** A fluent interface allows method chaining, where each method returns `this` (the builder instance). This leads to a more readable and concise syntax for setting builder properties, as seen in `builder.setSize("large").addCheese().build()`. It significantly improves the developer experience for object construction.

4.  **How does the Builder pattern help prevent the "telescoping constructor" anti-pattern?**
    *   **Answer:** The telescoping constructor pattern occurs when you have multiple constructors with increasing numbers of parameters to handle different combinations of optional settings. This is hard to maintain. The Builder pattern consolidates all these configuration options into methods of a single builder object, allowing the client to specify only the parameters they need in a clear, readable manner, and then calling a single `build()` method.