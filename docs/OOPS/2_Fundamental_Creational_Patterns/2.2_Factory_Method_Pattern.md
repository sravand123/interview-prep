---
topic: OOPS
section: Fundamental Creational Patterns
subtopic: Factory Method Pattern
level: Intermediate
---

## Factory Method Pattern
### Core Concepts

*   **Purpose:** Defines an interface for creating an object, but lets subclasses decide which class to instantiate.
*   **Delegation:** Defers instantiation to subclasses.
*   **Decoupling:** Separates the client code (which uses the created object) from the concrete product classes.

### Key Details & Nuances

*   **Creator:** An abstract class or interface that declares the factory method. It may also define a default implementation of the factory method that returns a default `ConcreteProduct` object.
*   **Factory Method:** An abstract method in the `Creator` that the subclasses implement to return an instance of a `ConcreteProduct`.
*   **Product:** An interface or abstract class for the objects the factory method creates.
*   **ConcreteProduct:** Implements the `Product` interface. These are the actual objects that will be instantiated and returned by the factory method.
*   **Client:** Uses the `Creator`'s interface but doesn't know about the `ConcreteProduct` classes. It interacts with the `Product` interface.
*   **Relationship:** A `Creator` *has a* `Product` (through composition or dependency), but it doesn't know *which* `ConcreteProduct` it will be.

### Practical Examples

**Scenario:** A document processing application that can create different types of documents (e.g., PDF, Word).

```typescript
// Product Interface
interface Document {
  open(): void;
  save(): void;
}

// Concrete Products
class PdfDocument implements Document {
  open(): void {
    console.log("Opening PDF document...");
  }
  save(): void {
    console.log("Saving PDF document...");
  }
}

class WordDocument implements Document {
  open(): void {
    console.log("Opening Word document...");
  }
  save(): void {
    console.log("Saving Word document...");
  }
}

// Creator Abstract Class
abstract class DocumentCreator {
  // The Factory Method
  abstract createDocument(): Document;

  // Client Code that uses the factory method
  processDocument(): void {
    const doc = this.createDocument(); // The factory method is called here
    doc.open();
    doc.save();
  }
}

// Concrete Creators
class PdfDocumentCreator extends DocumentCreator {
  createDocument(): Document {
    return new PdfDocument();
  }
}

class WordDocumentCreator extends DocumentCreator {
  createDocument(): Document {
    return new WordDocument();
  }
}

// Client Usage
const pdfCreator = new PdfDocumentCreator();
pdfCreator.processDocument(); // Outputs: Opening PDF document..., Saving PDF document...

const wordCreator = new WordDocumentCreator();
wordCreator.processDocument(); // Outputs: Opening Word document..., Saving Word document...
```

### Common Pitfalls & Trade-offs

*   **Increased Class Count:** Can lead to a proliferation of creator classes if there are many product variations.
*   **Complexity:** For simple object creation, the pattern might introduce unnecessary complexity. Consider a simple factory (a single class with a `create` method) or direct instantiation if the product is fixed.
*   **Subclass Responsibility:** Pushes the responsibility of concrete class instantiation down to subclasses, which might not always be desired.

### Interview Questions

1.  **When would you choose the Factory Method pattern over a Simple Factory?**
    *   **Answer:** Factory Method is preferred when the specific product to be created is not known until runtime, or when subclasses of the Creator need to specify the product to be created. It provides a more extensible and flexible way to manage object creation, allowing new product types to be added without modifying the creator's core logic. Simple Factory is suitable for simpler scenarios where the creation logic is stable and can be encapsulated within a single factory class.

2.  **Explain the relationship between the Creator and its Product in the Factory Method pattern.**
    *   **Answer:** The Creator class declares the factory method but does not know the concrete product it will create. It relies on subclasses (Concrete Creators) to implement this method and return an instance of a Concrete Product. The Client code interacts with the Creator's abstract interface and uses the product through its abstract Product interface, achieving decoupling.

3.  **What is the main benefit of the Factory Method pattern regarding extensibility?**
    *   **Answer:** The primary benefit is extensibility. New Concrete Products can be introduced by simply creating new Concrete Product classes and corresponding Concrete Creator classes that implement the factory method to instantiate the new product. The existing Creator and Client code remains unchanged, adhering to the Open/Closed Principle.