---
topic: OOPS
section: System Design & Anti-Patterns
subtopic: GRASP Principles
level: Advanced
---

## GRASP Principles
### Core Concepts

*   **Object-Oriented Programming (OOP):** A programming paradigm based on the concept of "objects," which can contain data (attributes or properties) and code (methods or functions). Key pillars:
    *   **Encapsulation:** Bundling data and methods that operate on the data within a single unit (class). Hides internal state and requires interaction through public interfaces.
    *   **Abstraction:** Hiding complex implementation details and exposing only essential features. Focuses on *what* an object does, not *how*.
    *   **Inheritance:** Mechanism where a new class (subclass/derived class) inherits properties and behaviors from an existing class (superclass/base class). Promotes code reuse.
    *   **Polymorphism:** The ability of an object to take on many forms. Allows methods to behave differently based on the object type they are operating on.

*   **System Design:** The process of designing the architecture, modules, interfaces, and other characteristics of a system to satisfy specified requirements. Involves trade-offs between performance, scalability, maintainability, cost, etc. OOP principles heavily influence system design.

*   **GRASP (General Responsibility Assignment Software Patterns):** A set of principles that guide developers in assigning responsibilities to classes and objects. Aims to create well-structured, maintainable, and understandable object-oriented designs.

### Key Details & Nuances

*   **GRASP Principles:**
    *   **Information Expert:** Assign responsibilities to the class that has the information needed to fulfill the responsibility. (e.g., `Order` class should calculate its total price if it has all `OrderItem`s).
    *   **Creator:** Assign responsibility for creating objects to a class that needs to create them or aggregates them. (e.g., `Order` creates `OrderItem`s, `OrderService` creates `Order`s).
    *   **High Cohesion:** Group closely related responsibilities within a single class. Low cohesion means a class has too many unrelated responsibilities, making it hard to understand and maintain.
    *   **Low Coupling:** Minimize dependencies between classes. High coupling makes changes in one class ripple through many others.
    *   **Controller:** Assign UI controller responsibilities to a class that handles input from the user interface and delegates to other objects. Often a fa√ßade for the system's domain logic.
    *   **Indicate (or Controller/Mediator):** Centralize the control of a system or subsystem in a single object or a very limited number of objects.
    *   **Pure Fabrication:** Create classes that are not direct abstractions of the problem domain but are created to support low coupling and high cohesion. Often used for utility classes or to orchestrate complex workflows.

*   **OOP & System Design Connection:**
    *   **Encapsulation:** Crucial for modularity in system design. Objects are like self-contained services.
    *   **Abstraction:** Enables defining clear APIs for system components, allowing independent development and evolution.
    *   **Inheritance/Composition:** Used for code reuse and creating flexible hierarchies. Composition is often favored over inheritance (favor composition over inheritance) for greater flexibility.
    *   **Polymorphism:** Enables loose coupling by allowing systems to work with different implementations of an interface without knowing the concrete types.

*   **Anti-Patterns in System Design (often violate GRASP):**
    *   **God Object/God Class:** A single class that knows or does too much, violating High Cohesion and Low Coupling.
    *   **Blob/Vampire:** Similar to God Object, often arises from misapplication of inheritance or poorly distributed responsibilities.
    *   **Spaghetti Code:** Code with a complex and tangled control structure, often lacking clear organization and violating principles of cohesion and coupling.
    *   **Shotgun Surgery:** A change requires making many small changes in many different classes. Indicates low cohesion or high coupling.
    *   **Feature Envy:** A method seems more interested in the data of another class than its own. Violates Information Expert.
    *   **Parallel Inheritance Hierarchies:** Whenever you subclass one class, you must also subclass another. Violates Liskov Substitution Principle and indicates poor design.

### Practical Examples

*   **GRASP - Information Expert Example:**
    Consider an e-commerce system.

    ```typescript
    class Product {
        name: string;
        price: number;

        constructor(name: string, price: number) {
            this.name = name;
            this.price = price;
        }

        getPrice(): number {
            return this.price;
        }
    }

    class OrderItem {
        product: Product;
        quantity: number;

        constructor(product: Product, quantity: number) {
            this.product = product;
            this.quantity = quantity;
        }

        // Information Expert: OrderItem has both Product and quantity,
        // so it's best placed to calculate its subtotal.
        getSubtotal(): number {
            return this.product.getPrice() * this.quantity;
        }
    }

    class Order {
        items: OrderItem[];

        constructor() {
            this.items = [];
        }

        addItem(item: OrderItem): void {
            this.items.push(item);
        }

        // Information Expert: Order has all OrderItems, so it's best
        // placed to calculate the total.
        getTotal(): number {
            let total = 0;
            for (const item of this.items) {
                total += item.getSubtotal();
            }
            return total;
        }
    }
    ```

*   **System Design - Anti-Pattern (God Object):**
    A single `UserService` class handling authentication, profile management, email notifications, and database operations directly.

    ```typescript
    class GodUserService {
        // ... authentication logic ...
        authenticateUser(email, password) { /* ... */ }

        // ... profile management logic ...
        updateUserProfile(userId, profileData) { /* ... */ }
        getUserProfile(userId) { /* ... */ }

        // ... email notification logic ...
        sendWelcomeEmail(userEmail) { /* ... */ }
        sendPasswordResetEmail(userEmail) { /* ... */ }

        // ... direct database access ...
        saveUserToDB(userData) { /* ... */ }
        getUserFromDB(userId) { /* ... */ }
    }
    ```
    **Problem:** High coupling, low cohesion, difficult to test, prone to bugs, hard to maintain.

### Interview Questions

1.  **Question:** How do GRASP principles help in designing scalable systems, and can you give an example where violating one principle leads to scalability issues?
    **Answer:** GRASP principles like **Low Coupling** and **High Cohesion** are foundational for scalability. Low coupling ensures that changes in one component have minimal impact on others, allowing for independent scaling of services. High cohesion means a component focuses on a single responsibility, making it easier to optimize or replace.
    Violating **Information Expert** can lead to scalability issues. If a class that shouldn't have certain data is responsible for calculations involving that data (e.g., a `ReportGenerator` class calculating order totals instead of `Order`), it might need to fetch data from multiple sources or rely on other services. This increased inter-dependency and data shuffling can become a bottleneck under heavy load, hindering horizontal scaling.

2.  **Question:** Explain the difference between composition and inheritance in OOP, and when would you favor one over the other in system design? Provide an example of a system design choice influenced by this.
    **Answer:** **Inheritance** creates an "is-a" relationship (e.g., `Car` *is a* `Vehicle`). It promotes code reuse but can lead to rigid class hierarchies and tight coupling. **Composition** creates a "has-a" relationship (e.g., `Car` *has an* `Engine`). It promotes flexibility and loose coupling by allowing objects to delegate behavior to other objects they contain.
    In system design, **favor composition over inheritance** for greater flexibility and maintainability. For example, designing a system for different types of media players:
    *   **Inheritance:** A `MP3Player` and `VideoPlayer` might inherit from a `BasePlayer`. This works but can become problematic if players share some but not all features (e.g., one needs subtitles, the other doesn't).
    *   **Composition:** Create core components like `AudioPlaybackEngine`, `VideoDecodingEngine`, `SubtitleRenderer`. A `MediaPlayer` class can then be configured with a combination of these components using composition. A `MP3Player` might *have an* `AudioPlaybackEngine`, while a `VideoPlayer` *has* `AudioPlaybackEngine` and `VideoDecodingEngine`. This is more flexible, allowing new player types to be created by composing existing engines without deep inheritance chains.

3.  **Question:** Describe the "God Object" anti-pattern and how it relates to GRASP principles. How would you refactor a system suffering from this issue?
    **Answer:** A "God Object" (or God Class, Blob) is an anti-pattern where a single class has excessive responsibilities, knowledge, and control over many other parts of the system. It violates **High Cohesion** by grouping unrelated functionalities and **Low Coupling** by creating strong dependencies on itself from numerous other classes. It often breaks the **Information Expert** principle by hoarding data and logic.
    To refactor, identify the distinct responsibilities within the God Object and extract them into separate, smaller classes.
    *   **Example:** If a `UserManager` handles user creation, authentication, profile updates, sending emails, and logging, you would:
        *   Extract authentication logic into an `AuthenticationService`.
        *   Extract profile management into a `UserProfileService`.
        *   Extract email sending into an `EmailNotificationService`.
        *   Extract logging into a `LoggingService`.
    The original `UserManager` would then delegate these tasks to the new services, becoming a more focused coordinator or controller.

4.  **Question:** How does the "Controller" GRASP principle interact with the MVC (Model-View-Controller) architectural pattern in system design?
    **Answer:** The "Controller" GRASP principle aligns well with the Controller component in MVC. The GRASP Controller is responsible for receiving input and delegating to other objects. In MVC, the Controller acts as an intermediary between the Model (data and business logic) and the View (UI).
    The Controller receives user input (e.g., button clicks, form submissions), uses the GRASP "Controller" principle to handle that input, and then delegates tasks to the Model (e.g., fetching data, updating state) based on the input. Once the Model is updated, the Controller might then select a View to display the updated information. This principle helps keep the UI (View) and the core business logic (Model) separate, promoting modularity and maintainability, which are key for robust system design.