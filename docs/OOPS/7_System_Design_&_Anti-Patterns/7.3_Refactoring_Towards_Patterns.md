---
topic: OOPS
section: System Design & Anti-Patterns
subtopic: Refactoring Towards Patterns
level: Advanced
---

## Refactoring Towards Patterns
### Core Concepts

*   **Object-Oriented Programming (OOP) Principles:**
    *   **Encapsulation:** Bundling data (attributes) and methods (functions) that operate on the data into a single unit (class). Hides internal state and requires interaction through public interfaces.
    *   **Abstraction:** Simplifying complex reality by modeling classes based on relevant attributes and behaviors, hiding unnecessary implementation details.
    *   **Inheritance:** Mechanism where a new class (subclass/derived class) inherits properties and behaviors from an existing class (superclass/base class). Promotes code reuse.
    *   **Polymorphism:** Ability of an object to take on many forms. Allows objects of different classes to respond to the same method call in their own specific ways.

*   **System Design:** Focuses on structuring software systems to meet requirements, considering factors like scalability, reliability, maintainability, and performance. OOP principles are foundational for building modular and maintainable systems.

*   **Refactoring Towards Patterns:** The process of restructuring existing computer code without changing its external behavior. The goal is to improve non-functional attributes like readability, reduce complexity, and introduce design patterns to enhance maintainability and extensibility.

### Key Details & Nuances

*   **Encapsulation:**
    *   **Access Modifiers:** `public`, `private`, `protected` (language-specific). Crucial for defining the contract of a class.
    *   **Data Hiding:** Prevents direct manipulation of internal state, reducing side effects and making code easier to reason about.
    *   **Getters/Setters:** Provide controlled access to private data. Often used for validation or side effects.

*   **Abstraction:**
    *   **Abstract Classes:** Classes that cannot be instantiated. Can contain abstract methods (without implementation) that must be implemented by concrete subclasses.
    *   **Interfaces:** Contracts that define a set of methods a class must implement. Emphasize "what" a class can do, not "how." Useful for achieving polymorphism and loose coupling.

*   **Inheritance:**
    *   **"Is-A" Relationship:** Represents a generalization/specialization hierarchy.
    *   **Method Overriding:** Subclasses can provide a specific implementation for a method inherited from a superclass.
    *   **Composition over Inheritance:** Often preferred for flexibility. Objects "have-a" relationship instead of "is-a." Avoids deep, rigid hierarchies.

*   **Polymorphism:**
    *   **Compile-time (Static):** Method overloading (same method name, different parameters).
    *   **Runtime (Dynamic):** Method overriding through inheritance or interfaces. Enables treating objects of different classes uniformly if they share a common interface or base class.

*   **Design Patterns (as Refactoring Targets):**
    *   **Creational:** Factory Method, Abstract Factory, Builder, Singleton, Prototype. Solve object creation problems.
    *   **Structural:** Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy. Deal with class and object composition.
    *   **Behavioral:** Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor. Deal with algorithms and assignment of responsibilities.

*   **Anti-Patterns:**
    *   **God Object/Class:** A class that knows or does too much. Violates Single Responsibility Principle.
    *   **Spaghetti Code:** Code with a complex control flow structure, often due to excessive use of `goto` statements or deeply nested logic.
    *   **Boat Anchor:** Unused or obsolete code/modules that remain in the system.
    *   **Magic Numbers/Strings:** Using raw, unexplained numeric or string literals instead of named constants.
    *   **Shotgun Surgery:** Making a single logical change requires modifying many different classes. Indicates poor cohesion and high coupling.
    *   **Parallel Inheritance Hierarchies:** When creating a subclass in one hierarchy requires creating a corresponding subclass in another.

### Practical Examples

*   **Refactoring to Strategy Pattern:**

    Imagine a `ReportGenerator` class that handles different report formats (e.g., PDF, CSV). Initially, it might have conditional logic. Refactoring to the Strategy pattern decouples the algorithm from the client.

    **Before (Conditional Logic):**

    ```typescript
    class ReportGenerator {
        generateReport(data: any, format: 'pdf' | 'csv') {
            if (format === 'pdf') {
                console.log("Generating PDF report...");
                // PDF generation logic
            } else if (format === 'csv') {
                console.log("Generating CSV report...");
                // CSV generation logic
            }
        }
    }
    ```

    **After (Strategy Pattern):**

    ```typescript
    interface IReportStrategy {
        generate(data: any): void;
    }

    class PdfReportStrategy implements IReportStrategy {
        generate(data: any): void {
            console.log("Generating PDF report...");
            // PDF generation logic
        }
    }

    class CsvReportStrategy implements IReportStrategy {
        generate(data: any): void {
            console.log("Generating CSV report...");
            // CSV generation logic
        }
    }

    class ReportGenerator {
        private strategy: IReportStrategy;

        constructor(strategy: IReportStrategy) {
            this.strategy = strategy;
        }

        setStrategy(strategy: IReportStrategy): void {
            this.strategy = strategy;
        }

        generateReport(data: any): void {
            this.strategy.generate(data);
        }
    }

    // Usage
    const reportData = { /* ... */ };
    const pdfGenerator = new ReportGenerator(new PdfReportStrategy());
    pdfGenerator.generateReport(reportData);

    const csvGenerator = new ReportGenerator(new CsvReportStrategy());
    csvGenerator.generateReport(reportData);
    ```

*   **Mermaid Diagram: God Object Anti-Pattern**

    ```mermaid
    graph TD;
        A["UserManagement"] --> B["UserDataPersistence"];
        A --> C["AuthenticationService"];
        A --> D["EmailNotification"];
        A --> E["AuditLogging"];
        A --> F["UIHandler"];
    ```
    *Explanation:* `UserManagement` class is handling too many responsibilities, leading to tight coupling and making it difficult to modify or test individual parts.

### Common Pitfalls & Trade-offs

*   **Overuse of Inheritance:** Can lead to rigid class hierarchies, tight coupling, and the "diamond problem" (in multiple inheritance scenarios). Composition often offers more flexibility.
*   **Premature Abstraction:** Creating abstractions before the need is clear can lead to overly complex or incorrect designs that are hard to refactor later. "You ain't gonna need it" (YAGNI).
*   **Tight Coupling:** Classes are highly dependent on each other's internal details. Changes in one class ripple through others (Shotgun Surgery anti-pattern). Refactoring aims to reduce this using interfaces and dependency injection.
*   **Low Cohesion:** Elements within a class are not closely related or serve different purposes. Leads to classes that are hard to understand and maintain (God Object anti-pattern).
*   **Ignoring SOLID principles:**
    *   **S**ingle Responsibility Principle (SRP)
    *   **O**pen/Closed Principle (OCP)
    *   **L**iskov Substitution Principle (LSP)
    *   **I**nterface Segregation Principle (ISP)
    *   **D**ependency Inversion Principle (DIP)
    Violating these often leads to the anti-patterns mentioned. Refactoring towards patterns often means refactoring to adhere to SOLID.

### Interview Questions

1.  **Q: How would you refactor a large class with many methods and properties that handles multiple distinct concerns (e.g., data validation, database access, business logic) to improve maintainability?**
    *   **A:** I would identify the distinct concerns within the large class. For each concern, I'd extract its logic into separate, smaller classes, adhering to the Single Responsibility Principle. This might involve creating new interfaces for communication between these classes and potentially introducing design patterns like Strategy for interchangeable algorithms or Facade to provide a simplified interface to a subsystem. The goal is to reduce coupling and increase cohesion, making each class easier to test, understand, and modify independently.

2.  **Q: Explain the trade-offs between inheritance and composition in object-oriented design.**
    *   **A:** **Inheritance** promotes code reuse and establishes an "is-a" relationship. It's good for modeling strict generalization/specialization hierarchies. However, it leads to tight coupling between parent and child classes, making it less flexible. Changes in the base class can break subclasses. It can also lead to deep, brittle hierarchies.
    **Composition** promotes code reuse by assembling objects from smaller, independent objects, establishing a "has-a" or "uses-a" relationship. It offers greater flexibility because components can be swapped out at runtime. It leads to looser coupling and is generally favored over inheritance for building complex systems, aligning with the "favor composition over inheritance" principle. The trade-off is potentially more initial setup and managing multiple object relationships.

3.  **Q: Describe the "God Object" anti-pattern and how you would refactor it.**
    *   **A:** A "God Object" (or God Class) is a class that controls too many other classes or takes on too many responsibilities, violating the Single Responsibility Principle and often the Open/Closed Principle. It becomes a central point of failure and is difficult to test or modify due to its high coupling and low cohesion.
    To refactor it, I would:
    1.  **Analyze Responsibilities:** Identify the distinct functionalities currently handled by the God Object.
    2.  **Extract Classes:** Create new, focused classes for each identified responsibility (e.g., a `UserService`, a `UserAuthenticator`, a `NotificationService`).
    3.  **Define Interfaces:** Introduce interfaces for these new classes to define their contracts.
    4.  **Dependency Injection:** Inject instances of these new services into the original class (or a new orchestrator class) rather than having the God Object instantiate them directly.
    5.  **Delegate Calls:** Update the original class (or refactor its usage) to delegate calls to the appropriate extracted service.
    This breaks down the monolithic class into a more modular, maintainable, and testable system.

4.  **Q: When might you choose to use the Adapter pattern, and what are the benefits?**
    *   **A:** The Adapter pattern is used to make incompatible interfaces work together. You'd choose it when you need to integrate a new class with an existing system that expects a different interface, or when you want to reuse a class in a system that doesn't match its interface.
    **Benefits:**
    *   **Interoperability:** Allows classes with different interfaces to collaborate.
    *   **Reusability:** Enables using existing classes without modifying them to fit new requirements.
    *   **Decoupling:** Separates the client code from the specific implementation details of the adapted class, making the system more flexible.
    *   **Simplicity:** Avoids the need to change client code when the interface of a dependency changes, as the adapter handles the translation.