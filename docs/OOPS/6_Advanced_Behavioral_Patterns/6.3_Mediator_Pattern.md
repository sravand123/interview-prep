---
topic: OOPS
section: Advanced Behavioral Patterns
subtopic: Mediator Pattern
level: Advanced
---

## Mediator Pattern
### Core Concepts

*   **Intent:** Defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.
*   **Problem Solved:** Reduces direct dependencies between multiple collaborating objects. Instead of each object knowing about all others it interacts with, they only know about the Mediator.

### Key Details & Nuances

*   **Colleagues:** Objects that use the Mediator to communicate. They don't know about each other directly.
*   **Mediator Interface/Abstract Class:** Defines the communication interface for Colleagues.
*   **Concrete Mediator:** Implements the Mediator interface and coordinates the interaction between Colleagues. It knows about all Concrete Colleagues.
*   **Concrete Colleague:** Knows its Mediator and communicates with it when its state changes. It doesn't know about other Colleagues.
*   **Centralized Control:** The Mediator acts as a central hub for all communications, simplifying the interaction logic.
*   **Single Responsibility Principle:** The interaction logic is moved from the individual Colleagues into the Mediator.
*   **Open/Closed Principle:** New interaction behaviors can be added by creating new Mediators or modifying the existing one without changing the Colleagues.

### Practical Examples

*   **Chat Room Analogy:** A chat room where users (Colleagues) send messages to the room (Mediator), and the room distributes messages to other users. Users don't know each other, only the chat room.

```typescript
// Colleague Interface
interface ChatColleague {
    setMediator(mediator: ChatMediator): void;
    send(message: string): void;
    receive(message: string, sender: string): void;
}

// Mediator Interface
interface ChatMediator {
    sendMessage(message: string, sender: ChatColleague): void;
    addColleague(colleague: ChatColleague): void;
}

// Concrete Mediator
class ConcreteChatMediator implements ChatMediator {
    private colleagues: ChatColleague[] = [];

    addColleague(colleague: ChatColleague): void {
        this.colleagues.push(colleague);
        // Set the mediator for the colleague after adding
        colleague.setMediator(this);
    }

    sendMessage(message: string, sender: ChatColleague): void {
        for (const colleague of this.colleagues) {
            // Don't send message back to sender
            if (colleague !== sender) {
                colleague.receive(message, sender.constructor.name); // Pass sender's class name for identification
            }
        }
    }
}

// Concrete Colleague
class User implements ChatColleague {
    private mediator!: ChatMediator;
    private name: string;

    constructor(name: string) {
        this.name = name;
    }

    setMediator(mediator: ChatMediator): void {
        this.mediator = mediator;
    }

    send(message: string): void {
        console.log(`${this.name} sends: ${message}`);
        this.mediator.sendMessage(message, this);
    }

    receive(message: string, senderName: string): void {
        console.log(`${this.name} received from ${senderName}: ${message}`);
    }

    getName(): string {
        return this.name;
    }
}

// Usage
const mediator = new ConcreteChatMediator();
const user1 = new User("Alice");
const user2 = new User("Bob");
const user3 = new User("Charlie");

mediator.addColleague(user1);
mediator.addColleague(user2);
mediator.addColleague(user3);

user1.send("Hello everyone!");
user2.send("Hi Alice!");
```

### Common Pitfalls & Trade-offs

*   **Mediator Becomes God Object:** If not designed carefully, the Mediator can become overly complex and know too much, violating the Single Responsibility Principle.
*   **Increased Complexity:** While it decouples Colleagues, the Mediator itself can become complex to manage.
*   **Performance:** A single point of communication can be a bottleneck if not handled efficiently.
*   **When *Not* to Use:** If the interaction between objects is simple and direct dependencies are manageable, the Mediator pattern might add unnecessary overhead. Consider if the benefits of reduced coupling outweigh the complexity of the Mediator.

### Interview Questions

1.  **Q: Explain the Mediator pattern with a real-world example and its core benefit.**
    **A:** The Mediator pattern centralizes communication between multiple objects (Colleagues). A real-world example is a chat room application where users (Colleagues) don't talk directly to each other but send messages to the chat room (Mediator), which then distributes them. The core benefit is **loose coupling**, preventing Colleagues from needing explicit knowledge of each other, making the system more maintainable and extensible.

2.  **Q: When would you choose the Mediator pattern over direct communication or other patterns like Observer?**
    **A:** Choose Mediator when there's a complex many-to-many communication relationship between objects, and you want to avoid creating a tightly coupled "spaghetti" of direct connections. It's particularly useful when the interaction logic becomes difficult to manage within individual objects. Unlike Observer, where the subject doesn't know about the observers beyond a general notification, the Mediator has explicit knowledge of its Colleagues and orchestrates their interactions.

3.  **Q: What are the potential downsides or risks of using the Mediator pattern?**
    **A:** The main risk is the Mediator becoming a "God Object"â€”a single class that knows and controls too much, leading to high coupling within the Mediator itself and making it hard to maintain. The communication logic centralization can also introduce performance bottlenecks if not implemented efficiently.

4.  **Q: How does the Mediator pattern support the Open/Closed Principle?**
    **A:** The Mediator pattern supports the Open/Closed Principle because you can introduce new interaction behaviors or modify existing ones by changing or extending the Mediator component without altering the Colleague components. Colleagues only depend on the Mediator's interface, so changes within the Mediator that don't break the interface don't require changes in the Colleagues.