---
topic: OOPS
section: Advanced Behavioral Patterns
subtopic: State Pattern
level: Advanced
---

## State Pattern
### Core Concepts

*   **Intent:** Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
*   **Mechanism:** Encapsulates state-specific behavior in separate "state" objects. The context object delegates requests to its current state object.
*   **Purpose:** Avoids large conditional statements (if/else, switch) based on state within the context object. Improves maintainability and extensibility.

### Key Details & Nuances

*   **Context:** The class that maintains a reference to the current state object and delegates requests to it. It also provides the interface for clients to interact with the object.
*   **Concrete States:** Classes that implement the behavior associated with a particular state of the context. Each concrete state handles transitions to other states.
*   **State Interface/Abstract Class:** Defines the interface for all concrete states, typically including methods that represent the operations the context can perform.
*   **Transition Logic:** Handled within the concrete state objects. A state object can change the context's current state by setting the context's state reference to a different concrete state object.
*   **Single Responsibility Principle:** Each concrete state class handles only the behavior for one specific state.
*   **Open/Closed Principle:** New states can be added by creating new concrete state classes without modifying existing state classes or the context.

### Practical Examples

Consider a `VendingMachine` that can be in states like `Idle`, `Dispensing`, `SoldOut`.

```typescript
// State Interface
interface VendingMachineState {
    insertCoin(machine: VendingMachine): void;
    ejectCoin(machine: VendingMachine): void;
    selectItem(machine: VendingMachine): void;
    dispenseItem(machine: VendingMachine): void;
}

// Concrete State: Idle
class IdleState implements VendingMachineState {
    insertCoin(machine: VendingMachine): void {
        console.log("Coin inserted. Please select an item.");
        machine.setState(machine.getHasCoinState());
    }
    ejectCoin(machine: VendingMachine): void {
        console.log("No coin to eject.");
    }
    selectItem(machine: VendingMachine): void {
        console.log("Please insert a coin first.");
    }
    dispenseItem(machine: VendingMachine): void {
        console.log("Please insert a coin and select an item first.");
    }
}

// Concrete State: HasCoin
class HasCoinState implements VendingMachineState {
    insertCoin(machine: VendingMachine): void {
        console.log("Coin already inserted.");
    }
    ejectCoin(machine: VendingMachine): void {
        console.log("Coin returned.");
        machine.setState(machine.getIdleState());
    }
    selectItem(machine: VendingMachine): void {
        console.log("Item selected. Dispensing...");
        machine.setState(machine.getDispensingState());
        machine.dispenseItem();
    }
    dispenseItem(machine: VendingMachine): void {
        console.log("Dispensing item...");
        // Logic to dispense item
        machine.setState(machine.getSoldOutState()); // Example transition
    }
}

// Concrete State: Dispensing
class DispensingState implements VendingMachineState {
    insertCoin(machine: VendingMachine): void {
        console.log("Cannot insert coin, dispensing in progress.");
    }
    ejectCoin(machine: VendingMachine): void {
        console.log("Cannot eject coin during dispensing.");
    }
    selectItem(machine: VendingMachine): void {
        console.log("Cannot select item during dispensing.");
    }
    dispenseItem(machine: VendingMachine): void {
        console.log("Dispensing item...");
        // Actual dispensing logic
        // Transition to next state (e.g., back to Idle if more items, or SoldOut)
        machine.setState(machine.getSoldOutState()); // Example transition
    }
}

// Concrete State: SoldOut
class SoldOutState implements VendingMachineState {
    insertCoin(machine: VendingMachine): void {
        console.log("Machine is sold out. Returning coin.");
        // Return coin logic
    }
    ejectCoin(machine: VendingMachine): void {
        console.log("Machine is sold out. No coin to eject.");
    }
    selectItem(machine: VendingMachine): void {
        console.log("Machine is sold out.");
    }
    dispenseItem(machine: VendingMachine): void {
        console.log("Machine is sold out.");
    }
}

// Context
class VendingMachine {
    private currentState: VendingMachineState;
    private readonly idleState: VendingMachineState;
    private readonly hasCoinState: VendingMachineState;
    private readonly dispensingState: VendingMachineState;
    private readonly soldOutState: VendingMachineState;

    constructor() {
        this.idleState = new IdleState();
        this.hasCoinState = new HasCoinState();
        this.dispensingState = new DispensingState();
        this.soldOutState = new SoldOutState();

        this.currentState = this.idleState; // Initial state
    }

    setState(state: VendingMachineState): void {
        this.currentState = state;
    }

    getIdleState(): VendingMachineState { return this.idleState; }
    getHasCoinState(): VendingMachineState { return this.hasCoinState; }
    getDispensingState(): VendingMachineState { return this.dispensingState; }
    getSoldOutState(): VendingMachineState { return this.soldOutState; }

    insertCoin(): void {
        this.currentState.insertCoin(this);
    }
    ejectCoin(): void {
        this.currentState.ejectCoin(this);
    }
    selectItem(): void {
        this.currentState.selectItem(this);
    }
    dispenseItem(): void {
        this.currentState.dispenseItem(this);
    }
}
```

### Common Pitfalls & Trade-offs

*   **State Management Complexity:** While it removes conditionals from the context, it can lead to many small state classes.
*   **Transition Logic Coupling:** If state transitions are complex and involve many states, managing transitions can become intricate. Sometimes, the context might need to be aware of state changes or transitions.
*   **Overhead:** Creating many small state objects can introduce slight overhead compared to a simple conditional if the number of states and behaviors is very small.
*   **Not for all State Changes:** Best suited for state changes that significantly alter behavior. If states only differ by a few properties, a simpler approach might be better.

### Interview Questions

1.  **"When would you choose the State pattern over a simple switch statement or if/else chain?"**
    *   **Answer:** The State pattern is preferable when the object's behavior needs to change based on its internal state, and this behavior is encapsulated in multiple distinct states. It's particularly useful when the number of states is large or grows over time, as it keeps the context class clean, adheres to SRP and OCP, and prevents a proliferation of complex conditional logic that becomes hard to maintain. If the state changes are infrequent or only affect a few methods, simpler conditional logic might suffice.

2.  **"What are the key components of the State pattern, and how do they interact?"**
    *   **Answer:**
        *   **Context:** Holds a reference to the current state object and delegates client requests to it. It also provides the interface for state transitions.
        *   **State Interface/Abstract Class:** Declares the interface for objects representing states.
        *   **Concrete States:** Implement the State interface, encapsulating state-specific behavior. Each concrete state is responsible for handling requests and performing transitions to other states by changing the context's state.

3.  **"How does the State pattern support the Open/Closed Principle?"**
    *   **Answer:** The State pattern promotes the Open/Closed Principle because new states can be added by creating new concrete state classes without modifying the existing state classes or the context class. The context class only interacts with the State interface, making it open for extension (adding new states) but closed for modification.

4.  **"What are potential drawbacks or challenges when implementing the State pattern?"**
    *   **Answer:** A primary drawback can be the explosion of small state classes, potentially increasing the overall number of classes in the system. Managing the transitions between states can also become complex if states have intricate dependencies or transition logic. There's also a slight overhead in object creation for each state.