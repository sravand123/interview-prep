---
topic: AWS Essentials
section: Decoupling, Caching & Observability
subtopic: CloudFront: Content Delivery Network (CDN) and Caching
level: Advanced
---

## CloudFront: Content Delivery Network (CDN) and Caching
### Core Concepts
*   **Content Delivery Network (CDN):** CloudFront is AWS's CDN service that securely delivers content (web pages, videos, applications) with low latency and high transfer speeds.
*   **Edge Locations:** Content is cached at geographically distributed data centers (edge locations) closer to viewers. This reduces network latency and improves user experience.
*   **Caching:** CloudFront caches content at edge locations, reducing the number of requests to the origin server (e.g., S3, EC2, ELB, custom HTTP server).
*   **Primary Goals:**
    *   **Performance:** Faster content delivery due to proximity and optimized network paths.
    *   **Reduced Origin Load:** Offloads traffic from origin servers, saving bandwidth and compute resources.
    *   **Security:** Integrates with AWS WAF, SSL/TLS, signed URLs/cookies for secure content delivery.

### Key Details & Nuances
*   **Distribution:** The fundamental unit in CloudFront, specifying how content is delivered. Configured with:
    *   **Origins:** The source of your content (e.g., an S3 bucket, an EC2 instance, an Application Load Balancer, or any custom HTTP server).
    *   **Cache Behaviors:** Rules that define how CloudFront handles requests for different URL paths (e.g., `/images/*`, `/api/*`). Each behavior can specify:
        *   **Path Pattern:** Which requests apply to this behavior.
        *   **Origin:** Which origin to forward requests to.
        *   **Viewer Protocol Policy:** `HTTP and HTTPS`, `Redirect HTTP to HTTPS`, `HTTPS Only`.
        *   **Allowed HTTP Methods:** `GET, HEAD, OPTIONS`, `GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE`.
        *   **Cache Policy:** Defines how content is cached (TTL settings, headers/cookies/query strings to forward/cache on).
        *   **Origin Request Policy:** Defines headers/cookies/query strings to forward to the origin, regardless of caching.
        *   **WAF Integration:** Associate a Web Application Firewall (WAF) ACL.
*   **Cache Invalidation:** Forcefully removes content from CloudFront's edge caches. Useful for immediate content updates or corrections. Can be costly and should be used judiciously.
*   **Cache Expiration (TTL - Time To Live):** Content is automatically removed from the cache after a defined period. Controlled via:
    *   **Origin Headers:** `Cache-Control` (e.g., `max-age=3600`), `Expires`.
    *   **CloudFront Minimum/Default/Maximum TTL:** Overrides origin headers or sets defaults.
*   **Origin Access Control (OAC) / Origin Access Identity (OAI):**
    *   **OAC (Recommended, newer):** Securely restricts access to S3 buckets or other origins, ensuring content is only served via CloudFront. More flexible and secure than OAI.
    *   **OAI (Legacy for S3):** A virtual user that CloudFront uses to access private S3 content. S3 bucket policies must grant permissions to this OAI.
*   **Signed URLs/Cookies:** For serving private content to specific users for a limited time, CloudFront can generate pre-signed URLs or set signed cookies. This requires a trusted key group.
*   **Lambda@Edge / CloudFront Functions:**
    *   **CloudFront Functions (Newer, lighter, cheaper):** Run JavaScript code at CloudFront edge locations for lightweight, high-performance customizations (e.g., URL rewrites, header manipulation, A/B testing).
    *   **Lambda@Edge (More powerful, higher latency/cost):** Run Node.js or Python code at AWS regional edge caches for more complex logic (e.g., image resizing, authentication, integration with other AWS services). Triggered at four points: viewer request, origin request, origin response, viewer response.

### Practical Examples

**CloudFront Request Flow with Caching**

This diagram illustrates how CloudFront processes a request, including cache hits and misses.

```mermaid
graph TD;
    A["Client requests content (e.g., image.jpg)"];
    B["CloudFront Edge Location"];
    C["Origin Server (e.g., S3 Bucket)"];

    A --> B;
    B -- "1. Check Cache" --> |Cache Hit| B;
    B -- "2. Serve from Cache" --> A;

    B -- "1. Check Cache" --> |Cache Miss| C;
    C -- "3. Retrieve Content" --> B;
    B -- "4. Cache Content" --> B;
    B -- "5. Serve from Cache" --> A;
```

**Conceptual CloudFront Distribution Configuration (Simplified)**

```typescript
// Example of a CloudFront Distribution configuration concept
// (Not direct AWS SDK syntax, but illustrates key properties)

const cloudFrontDistribution = {
    Aliases: ["www.example.com", "example.com"], // CNAMEs for the distribution
    Origins: [
        {
            Id: "S3BucketOrigin",
            DomainName: "my-static-website-bucket.s3.us-east-1.amazonaws.com",
            S3OriginConfig: {
                OriginAccessControlId: "E123ABCDEF1234", // Recommended: OAC for secure S3 access
            },
        },
        {
            Id: "APIServerOrigin",
            DomainName: "api.example.com", // Or an ALB DNS name
            CustomOriginConfig: {
                HTTPPort: 80,
                HTTPSPort: 443,
                OriginProtocolPolicy: "https-only",
                OriginKeepaliveTimeout: 5,
            },
        },
    ],
    DefaultCacheBehavior: {
        TargetOriginId: "S3BucketOrigin",
        ViewerProtocolPolicy: "redirect-to-https",
        AllowedMethods: ["GET", "HEAD"],
        // Cache Policy defines TTLs and forwarded parameters
        CachePolicyId: "658327ea-f89d-4c65-8b06-cd3b0c8636b5", // Managed policy: CachingOptimized
    },
    CacheBehaviors: [
        {
            PathPattern: "/api/*",
            TargetOriginId: "APIServerOrigin",
            ViewerProtocolPolicy: "https-only",
            AllowedMethods: ["GET", "HEAD", "OPTIONS", "PUT", "POST", "PATCH", "DELETE"],
            // Custom cache policy for APIs (e.g., minimal/no caching, forward all headers)
            CachePolicyId: "4135ea2d-6df8-44a3-9df3-4b5a206216b8", // Managed policy: Managed-AllViewerExceptHostHeader
            OriginRequestPolicyId: "b62502e6-af9a-431a-85d7-31362095f68b", // Managed policy: AllViewerExceptHostHeader
        },
    ],
    Enabled: true,
    ViewerCertificate: {
        ACMCertificateArn: "arn:aws:acm:us-east-1:123456789012:certificate/uuid",
        SSLSupportMethod: "sni-only",
        MinimumProtocolVersion: "TLSv1.2_2021",
    },
};
```

### Common Pitfalls & Trade-offs
*   **Stale Content:** Incorrect TTLs or forgotten invalidations can lead to users seeing outdated content. Invalidation costs money and can take time (minutes).
*   **Cache Key Optimization:** By default, CloudFront might not cache based on query strings or specific headers. This can lead to low cache hit ratios if content varies by these parameters but isn't configured to forward them in the cache key.
    *   **Trade-off:** Including more parameters in the cache key increases cache fragmentation (more distinct objects to cache), potentially lowering cache hit ratio for individual items but ensuring content correctness.
*   **Over-Invalidation:** Frequent or wildcard invalidations (`/*`) are expensive and can negate the benefits of caching by forcing CloudFront to fetch everything from the origin again.
*   **Origin Overload on Cold Cache:** If an edge location's cache expires or is invalidated for a popular item, the first few requests will hit the origin, potentially causing a thundering herd problem.
*   **Security Misconfigurations:** Failing to restrict direct access to S3 buckets (not using OAC/OAI) means users can bypass CloudFront's security and caching.
*   **Cost Management:** While beneficial, CloudFront adds cost, primarily for data transfer out and requests. Misconfigurations (e.g., very short TTLs, high invalidation rates) can significantly increase bills.

### Interview Questions
1.  **How does CloudFront improve website performance and reduce the load on your origin server?**
    *   **Answer:** CloudFront improves performance by caching content at geographically distributed edge locations closer to users, reducing network latency. For origin servers, it significantly reduces load by serving cached content directly from edge locations, meaning fewer requests hit the origin, thus saving compute resources and bandwidth.
2.  **Explain the difference between cache invalidation and cache expiration in CloudFront. When would you use each?**
    *   **Answer:** **Cache Expiration** is the natural process where cached content is removed after its TTL (Time To Live) defined by `Cache-Control` headers or CloudFront settings. It's automatic and cost-free. Use it for content that can tolerate a delay in updates (e.g., static assets like images, CSS, JS). **Cache Invalidation** is a manual or programmatic process to immediately remove content from CloudFront's cache before its TTL expires. It incurs a cost. Use it for urgent content updates, bug fixes, or when content must be immediately fresh across all edge locations.
3.  **You have private user-specific content stored in an S3 bucket that you want to serve via CloudFront, ensuring only authorized users can access it. How would you secure this setup?**
    *   **Answer:** First, I'd use an **Origin Access Control (OAC)** or **Origin Access Identity (OAI)** (OAC is preferred) for the S3 bucket to ensure CloudFront is the only entity that can access the content from S3 directly, preventing public access to the bucket. Then, for user authorization, I'd implement **Signed URLs** or **Signed Cookies**. Signed URLs are suitable for granting temporary access to individual files, while Signed Cookies are better for granting access to multiple private files within a directory for a session. This typically involves backend authentication logic that generates and signs these URLs/cookies.
4.  **Describe a scenario where CloudFront's default caching behavior might not be optimal, and what steps you would take to optimize it.**
    *   **Answer:** A common scenario is dynamic API endpoints where content varies based on query parameters or specific request headers (e.g., `Authorization` header, `Accept-Language`). CloudFront's default caching often ignores query parameters or forwards only a minimal set of headers, leading to a low cache hit ratio or incorrect cached responses. To optimize, I would create a **specific cache behavior** for the API path (`/api/*`). In this behavior, I would configure a **custom Cache Policy** to:
        *   **Forward all necessary query parameters:** If the API response changes based on them.
        *   **Forward specific headers:** Such as `Authorization` (though often APIs are not cached if authorization is dynamic per request) or `Accept-Language` if content localization is involved, but usually for caching, `Accept` or `Content-Type` related headers are considered.
        *   **Set a very short or zero TTL (no caching):** For highly dynamic or sensitive API responses.
        *   **Allow appropriate HTTP methods:** (e.g., `GET`, `POST`).
        *   Alternatively, for APIs that should never be cached, I'd use a managed `Managed-CachingDisabled` Cache Policy.
5.  **When would you consider using Lambda@Edge or CloudFront Functions with CloudFront? Provide an example.**
    *   **Answer:** I'd use Lambda@Edge or CloudFront Functions when I need to execute custom code at the edge to modify requests/responses or perform authentication/authorization before content is served or requested from the origin.
    *   **CloudFront Functions (lighter, high-performance):** For simple URL rewrites (e.g., redirecting `/old-path` to `/new-path`), header manipulation (e.g., adding a `X-Request-ID` header), or basic A/B testing routing.
    *   **Lambda@Edge (more powerful, higher latency/cost):** For more complex logic like:
        *   **Dynamic Image Resizing:** On-the-fly resizing based on query parameters before hitting an S3 origin.
        *   **Custom Authentication/Authorization:** Integrating with an identity provider to validate tokens before allowing access to private content.
        *   **Server-Side Rendering (SSR) or SEO optimization:** Serving different content based on the user agent (e.g., rendering a simpler HTML for web crawlers).