---
topic: Git
section: Branching, Merging & History Manipulation
subtopic: git merge and Resolving Merge Conflicts
level: Intermediate
---

## git merge and Resolving Merge Conflicts
### Core Concepts

*   **`git merge`**: Integrates changes from one branch into another. It takes the contents of a source branch and integrates them with a target branch.
*   **Merge Commit**: When `git merge` is successful without conflicts, it creates a new commit that has two parent commits â€“ one from the target branch and one from the source branch.
*   **Fast-Forward Merge**: Occurs when the target branch hasn't diverged since the source branch was created. Git simply moves the target branch pointer forward to the latest commit of the source branch. No new merge commit is created.
*   **Three-Way Merge**: When both branches have diverged, Git uses a common ancestor and the tips of both branches to create a new merge commit.
*   **Merge Conflicts**: Happen when Git cannot automatically determine how to combine changes from two branches. This typically occurs when the same part of a file has been modified differently in both branches.

### Key Details & Nuances

*   **`--no-ff` Option**: Forces Git to create a merge commit even when a fast-forward merge is possible. This preserves the history of feature branches and makes it clear when a feature was merged.
    *   **Benefit**: Clearer branch history, easy to identify feature branches.
    *   **Drawback**: Can create more commits in the main branch history.
*   **`--squash` Option**: Integrates changes from the source branch into the target branch but does *not* create a merge commit. Instead, it stages all the changes from the source branch as a single set of modifications in the target branch. The history of individual commits from the source branch is lost in the target branch.
    *   **Benefit**: Keeps main branch history clean by consolidating feature branches into single commits.
    *   **Drawback**: Loses granular history of the feature branch.
*   **Resolving Conflicts**:
    *   Git marks conflicting files with special markers (`<<<<<<<`, `=======`, `>>>>>>>`).
    *   `<<<<<<< HEAD`: The start of your changes in the current branch.
    *   `=======`: Separator between the two conflicting versions.
    *   `>>>>>>> [branch_name]`: The end of the incoming changes from the merged branch.
    *   **Resolution process**: Manually edit the conflicting files to keep the desired changes, then `git add` the resolved files and `git commit` to finalize the merge.

### Practical Examples

**Merging Branches:**

```bash
# Assume you are on the 'main' branch
git checkout main

# Merge the 'feature' branch into 'main'
git merge feature
```

**Forcing a Merge Commit (`--no-ff`):**

```bash
git checkout main
git merge --no-ff feature
```

**Squashing a Merge (`--squash`):**

```bash
git checkout main
git merge --squash feature
# Now stage and commit the squashed changes
git commit -m "Add feature X from feature branch"
```

**Resolving a Merge Conflict:**

1.  **Trigger a conflict:**
    ```bash
    # Branch 'main' has file A modified
    # Branch 'feature' has file A modified differently
    git checkout main
    git merge feature
    ```
2.  **Identify conflicting files:** Git will output messages indicating conflicts.
    ```
    Auto-merging conflicting_file.txt
    CONFLICT (content): Merge conflict in conflicting_file.txt
    ```
3.  **Edit the conflicting file:**
    Open `conflicting_file.txt` in your editor. You'll see markers:

    ```
    This is the original line.
    <<<<<<< HEAD
    This is the change made on the main branch.
    =======
    This is the change made on the feature branch.
    >>>>>>> feature
    This is another original line.
    ```

    Manually edit to the desired state:
    ```
    This is the original line.
    This is the combined or preferred change.
    This is another original line.
    ```
4.  **Stage and commit the resolved file:**
    ```bash
    git add conflicting_file.txt
    git commit
    ```
    Git will often pre-populate the commit message with "Merge branch 'feature' into main", you can add details if needed.

### Interview Questions

*   **Q: What is the difference between a fast-forward merge and a three-way merge? When would you prefer one over the other?**
    *   **A:** A fast-forward merge happens when the target branch hasn't moved forward since the source branch was created; Git simply moves the target branch pointer. A three-way merge occurs when both branches have diverged, and Git creates a new merge commit with two parents. Prefer fast-forward for simplicity when a branch hasn't diverged. Prefer three-way (or `--no-ff`) when you want to preserve the explicit history of a feature branch being integrated.

*   **Q: Explain the purpose of `git merge --no-ff` and `git merge --squash`. What are the pros and cons of each?**
    *   **A:** `--no-ff` forces Git to create a merge commit even if a fast-forward is possible. **Pros**: Preserves feature branch history clearly in the main branch. **Cons**: Can lead to a "messier" or more verbose history with many small merge commits. `--squash` integrates changes as a single commit on the target branch, discarding the source branch's commit history. **Pros**: Keeps the main branch history clean and linear. **Cons**: Loses granular history of the feature development.

*   **Q: How do you resolve a Git merge conflict? Walk me through the steps.**
    *   **A:** When a conflict occurs, Git stops the merge. You identify the conflicting files (e.g., `git status`). Open each file; Git inserts markers (`<<<<<<< HEAD`, `=======`, `>>>>>>> [branch_name]`) showing the conflicting sections. You manually edit the file to resolve the differences, removing the markers. After editing, you `git add` the resolved file(s) and then `git commit` to complete the merge.

*   **Q: Imagine you're on branch `main` and accidentally merged `feature-A` which introduced a bug. How would you undo this merge?**
    *   **A:** If the merge hasn't been pushed, you can use `git reset --hard HEAD~1` (assuming the merge was the last commit on `main`). This moves `main` back to the commit before the merge. If the merge has been pushed, `git revert -m 1 <merge-commit-hash>` is safer. This creates a new commit that undoes the changes introduced by the merge commit. The `-m 1` specifies that you are reverting based on the first parent (the `main` branch).