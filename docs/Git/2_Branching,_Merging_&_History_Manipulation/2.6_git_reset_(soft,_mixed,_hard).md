---
topic: Git
section: Branching, Merging & History Manipulation
subtopic: git reset (soft, mixed, hard)
level: Intermediate
---

## git reset (soft, mixed, hard)
### Core Concepts

*   **`git reset`**: A powerful command to un-stage changes and/or move the current branch HEAD to a specified commit. It can alter your working directory, staging area, and commit history.
*   **Three states:** Git manages three main areas:
    *   **Working Directory:** The files you are currently editing.
    *   **Staging Area (Index):** Where you prepare changes before committing.
    *   **Commit History:** The record of your project's past states.

### Key Details & Nuances

*   **`git reset <commit>`**: Moves the current branch HEAD to `<commit>`. The effect on the working directory and staging area depends on the mode (`--soft`, `--mixed`, `--hard`).
*   **`git reset --soft <commit>`**:
    *   Moves HEAD to `<commit>`.
    *   **Does not** change the staging area.
    *   **Does not** change the working directory.
    *   Effectively "re-does" commits, keeping all changes staged. Useful for combining multiple commits or amending the last commit's message without touching files.
*   **`git reset --mixed <commit>` (Default)**:
    *   Moves HEAD to `<commit>`.
    *   Resets the staging area to match `<commit>`.
    *   **Does not** change the working directory.
    *   Effectively "un-stages" changes from the commits that were reset. Changes are still present in the working directory, available to be staged and committed again.
*   **`git reset --hard <commit>`**:
    *   Moves HEAD to `<commit>`.
    *   Resets the staging area to match `<commit>`.
    *   **Discards all changes** in the working directory since `<commit>`. This is a destructive operation and should be used with caution.
*   **Resetting to the same commit**: `git reset HEAD` is equivalent to `git reset --mixed HEAD`, which unstages all currently staged changes.
*   **Relative references**: You can use relative references like `HEAD~1` (the commit before HEAD), `HEAD~2`, etc.
*   **Caution with shared history**: Avoid using `git reset --hard` or any reset that rewrites history that has already been pushed to a shared remote repository, as it can cause significant problems for collaborators. Use `git revert` for shared history.

### Practical Examples

*   **Scenario:** You've made several commits but want to combine the last three into one, with a cleaner message, and keep the changes staged.
    ```sh
    # Assume current branch HEAD points to commit C
    # History: A -- B -- C (HEAD)

    git log --oneline
    # Output might show:
    # abcdef1 (HEAD -> main) Latest commit
    # 1234567 Second to last commit
    # fedcba9 Third to last commit
    # ...

    # Move HEAD to the commit before the last three (commit A)
    # and keep all changes from B, C staged.
    git reset --soft HEAD~3

    git status
    # Output:
    # On branch main
    # Changes to be committed:
    #   (use "git restore --staged <file>..." to unstage)
    #       modified: file1.txt
    #       new file: file2.txt
    # ...

    # Now you can make a single commit with all those changes
    git commit -m "Combined commits B and C into a single feature commit"
    # History: A --NewCommit (HEAD -> main)
    ```

*   **Scenario:** You committed a change locally but realized it's wrong and want to discard it entirely (working directory and staging area).
    ```sh
    # Assume you have uncommitted changes or staged changes
    git reset --hard HEAD

    # This will discard all uncommitted changes and staged changes,
    # reverting the working directory to the state of the last commit.
    ```

*   **Scenario:** You staged some changes but then decided you don't want to commit them yet and want them back in your working directory as unstaged modifications.
    ```sh
    # Stage some changes
    git add file1.txt

    # Decide not to commit them yet, unstaging them
    git reset HEAD file1.txt
    # or simply:
    git reset HEAD
    ```

### Interview Questions

1.  **Question:** What is the difference between `git reset` and `git revert`?
    *   **Answer:** `git reset` rewrites history by moving the branch pointer and optionally discarding changes. It's a destructive operation if used on pushed commits. `git revert` creates a *new* commit that undoes the changes introduced by a previous commit. It's non-destructive and safe for shared history.

2.  **Question:** Describe the three modes of `git reset` (`soft`, `mixed`, `hard`) and when you might use each.
    *   **Answer:**
        *   `--soft`: Moves HEAD. Staging area and working directory are unchanged. Use to re-package commits (e.g., squashing multiple commits into one).
        *   `--mixed` (default): Moves HEAD and resets the staging area. Working directory is unchanged. Use to unstage changes or break down a commit's changes into multiple smaller commits.
        *   `--hard`: Moves HEAD, resets staging area, and discards working directory changes. Use to completely discard unwanted changes or revert to a specific past state, but be very careful not to lose work.

3.  **Question:** You accidentally committed a large sensitive file and pushed it. What's the safest way to remove it from history?
    *   **Answer:** The safest way is to use `git revert`. First, you would likely add a new file that effectively overrides or denies access to the sensitive data, or use `git rm --cached <sensitive_file>` to remove it from the *next* commit's staging area without deleting it from your working directory. Then, commit this change. If the file *must* be entirely removed from history, a more drastic measure like `git filter-repo` (preferred over `BFG` or older `git filter-branch`) would be necessary, but this requires rewriting history and coordinating with all collaborators, which is complex and error-prone. For immediate removal after an accidental push, `git revert` followed by fixing the next commit is often a more practical first step.

4.  **Question:** What happens if you run `git reset --hard origin/main`?
    *   **Answer:** This command attempts to reset your current local branch (`main`, assuming that's where you are) to match the state of the `origin/main` branch on your remote. It will discard *all* local commits that are not on `origin/main` and also discard *all* uncommitted local changes in your working directory and staging area, bringing your local repository and working files exactly in sync with `origin/main`. This is a potentially destructive operation.