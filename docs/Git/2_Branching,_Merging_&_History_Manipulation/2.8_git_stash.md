---
topic: Git
section: Branching, Merging & History Manipulation
subtopic: git stash
level: Intermediate
---

## git stash
### Core Concepts

*   `git stash`: Temporarily shelves (or hides) uncommitted local changes (both staged and unstaged) so you can work on something else, and then reapply them later.
*   **Purpose:** To allow switching branches or pulling changes without committing incomplete work.

### Key Details & Nuances

*   **What it saves:**
    *   Modified tracked files.
    *   Staged changes.
    *   By default, it does **not** save untracked files.
*   **Stash entries:** Stored in a stack. Each `stash` command adds a new entry.
*   **Applying stashes:**
    *   `git stash apply`: Reapplies the most recent stash but keeps it in the stash list.
    *   `git stash pop`: Reapplies the most recent stash and removes it from the stash list.
*   **Viewing stashes:**
    *   `git stash list`: Shows all stashes, prefixed with `stash@{<number>}` (e.g., `stash@{0}`).
*   **Reapplying specific stashes:**
    *   `git stash apply stash@{<number>}`
*   **Dropping stashes:**
    *   `git stash drop stash@{<number>}`: Deletes a specific stash.
    *   `git stash clear`: Deletes all stashes.
*   **Stashing untracked files:**
    *   `git stash -u` or `git stash --include-untracked`: Stashes untracked files as well.
*   **Stashing ignored files:**
    *   `git stash -a` or `git stash --all`: Stashes untracked and ignored files.
*   **Creating a branch from a stash:**
    *   `git stash branch <branch-name> stash@{<number>}`: Creates a new branch from the commit the stash was originally created from, reapplies the stash to this new branch, and then drops the stash.

### Practical Examples

**Stashing changes and switching branches:**

```sh
# Make some changes to file1.txt and file2.txt
echo "modified content 1" > file1.txt
echo "modified content 2" > file2.txt

# Stage file1.txt
git add file1.txt

# Git stash the changes
git stash
# Output might look like: Saved working directory and index state WIP on <current-branch>: <commit-hash> <commit-message>

# Now, the working directory is clean, and you can switch branches
git checkout main

# ... do work on main branch ...

# Come back to the original branch
git checkout <original-branch>

# Reapply the stashed changes
git stash pop
# Output might look like: On <original-branch>: <commit-hash> <commit-message>
# Changes not staged for commit:
#   modified:   file1.txt
#   modified:   file2.txt
```

**Viewing and applying a specific stash:**

```sh
# Assuming multiple stashes exist
git stash list
# Output:
# stash@{0}: WIP on feature/new-feature: a3b4c5d Initial commit
# stash@{1}: WIP on main: f1e2d3c Refactor login logic

# Apply stash@{1}
git stash apply stash@{1}
```

**Stashing untracked files:**

```sh
# Create a new untracked file
echo "new untracked content" > new_file.txt

# Stash only tracked changes
git stash

# Stash tracked and untracked files
git stash -u
```

### Common Pitfalls & Trade-offs

*   **Forgetting stashes:** If you perform many stashes (`git stash push -m "message"`) without popping/applying, the stash list can become unmanageable. Use messages for clarity.
*   **Conflicts during apply/pop:** If the current branch has diverged significantly from the branch where the stash was created, `git stash apply` or `git stash pop` can result in merge conflicts. These need to be resolved manually.
*   **Stashing vs. Committing:** `git stash` is for *temporary* work that isn't ready for a commit. If the work represents a logical unit, committing to a feature branch is often cleaner. Stashing can sometimes obscure the development history if overused.
*   **Untracked files:** By default, untracked files are **not** stashed. This can be a surprise if you expect `git stash` to save everything. Use `-u` or `-a` explicitly when needed.
*   **Overwriting `stash@{0}`:** If you `git stash` again without popping/applying the previous one, the new stash becomes `stash@{0}`, and the old one is now `stash@{1}`. This can lead to confusion if not managed.

### Interview Questions

1.  **When would you use `git stash` versus creating a new commit on a feature branch?**
    *   **Answer:** `git stash` is ideal for **temporary, incomplete work** that you need to put aside *immediately* to switch context (e.g., fix an urgent bug on `main`, pull latest changes). It keeps your working directory clean without cluttering the commit history with half-done features. Creating a new commit is for **completed, logical units of work** that represent a state you might want to revisit or revert to, and it's the standard way to progress on a feature branch. Overusing stash for feature development can make history harder to follow.

2.  **What happens if you have merge conflicts when applying a stash? How do you resolve them?**
    *   **Answer:** If the changes in the stash conflict with the current state of your working directory (e.g., files have been modified differently since the stash was created), `git stash apply` or `git stash pop` will report merge conflicts. Git will mark these conflicts in the affected files with standard conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`). You need to manually edit the files to resolve these conflicts, choosing which version of the code to keep. After resolving, you stage the files (`git add <file>`) and then continue the stash operation. If using `pop`, you'd typically commit the resolved changes. If using `apply`, Git may notify you to run `git stash drop` if successful, or you might need to resolve and then continue.

3.  **How do you stash untracked files? What is the command?**
    *   **Answer:** You use the `-u` or `--include-untracked` flag with the `git stash` command. The command is `git stash -u`. This will also stash any modified tracked files. If you need to stash ignored files as well, use `git stash -a` or `git stash --all`.

4.  **Explain the difference between `git stash apply` and `git stash pop`.**
    *   **Answer:** Both commands reapply the most recently stashed changes to your working directory. The key difference is what happens to the stash entry itself:
        *   `git stash apply`: Reapplies the changes but **keeps** the stash entry in the stash list. This is useful if you want to apply the same set of changes to multiple branches or want to keep the stash as a backup.
        *   `git stash pop`: Reapplies the changes and then **removes** the stash entry from the stash list. This is the more common usage when you're done with the stashed work and want to clean up the stash.