---
topic: Git
section: Advanced Techniques & Internals
subtopic: git blame
level: Advanced
---

## git blame
### Core Concepts

*   `git blame`: A Git command that displays the revision and author who last modified each line of a file. It's a crucial tool for understanding the history and attribution of code changes.
*   **Purpose:** Identifies who introduced specific lines of code and when, aiding in debugging, understanding context, and accountability.

### Key Details & Nuances

*   **Line-by-Line Attribution:** Shows commit hash, author, date, and line number for each line.
*   **Default Behavior:** Operates on the current working copy of the file.
*   **Targeting Specific Commits:** Can be used with `-c <commit>` or `-r <commit>` to blame a file as it existed at a specific past commit.
*   **Ignoring Whitespace Changes:** The `-w` flag ignores whitespace when determining blame, useful for code refactors that only altered formatting.
*   **Detecting Moved/Copied Lines:**
    *   `-M`: Detects lines moved or copied within the file.
    *   `-C`: Detects lines moved or copied from other files (more computationally expensive).
    *   `-C -C` (or `-C3`): Detects lines moved or copied from other files in *any* commit.
*   **Email Address Matching:** By default, `git blame` uses the author's email address for matching. The `mailmap` feature can be used to normalize author identities if emails change over time.
*   **Output Formatting:** Options like `--line-porcelain` provide machine-readable output for scripting.
*   **Integration with GUIs:** Most Git GUIs (e.g., VS Code, GitHub Desktop, GitKraken) offer integrated blame views.

### Practical Examples

*   **Basic Blame:**
    ```sh
    git blame README.md
    ```

*   **Blaming at a Specific Commit:**
    ```sh
    git blame -c abc1234 README.md
    ```

*   **Ignoring Whitespace:**
    ```sh
    git blame -w src/index.js
    ```

*   **Detecting Moved/Copied Lines (intra-file):**
    ```sh
    git blame -M src/utils.ts
    ```

*   **Detecting Moved/Copied Lines (inter-file):**
    ```sh
    git blame -C src/main.ts
    ```

### Common Pitfalls & Trade-offs

*   **Misinterpreting "Last Change":** `git blame` shows the *last commit that touched a line*. This might not be the commit that introduced the *logic*, but rather a reformatting or whitespace change. Use `-w` to mitigate this.
*   **Cost of `-C`:** Detecting lines moved/copied between files (`-C`) can be significantly slower, especially with many files and a long history.
*   **Refactoring Impact:** Large refactors or code rewrites can "reset" blame information for many lines, making it harder to trace original authorship.
*   **False Positives/Negatives:** With complex history or automated code generation, blame information might not always perfectly reflect human intent or original authorship.

### Interview Questions

1.  **Question:** What is `git blame` used for, and what information does it provide?
    **Answer:** `git blame` attributes each line in a file to the commit and author that last modified it. It helps identify who wrote specific code sections, understand the history of changes, and debug by pinpointing when a line was last altered.

2.  **Question:** How would you use `git blame` to find out who last modified a line of code, ignoring any whitespace-only changes?
    **Answer:** I would use the `-w` flag: `git blame -w <file_path>`. This flag tells Git to ignore whitespace differences when tracking line history, ensuring the blame points to the last change that actually altered the code's logic or content.

3.  **Question:** What are the differences between `git blame -M` and `git blame -C`? When would you choose one over the other?
    **Answer:** `git blame -M` detects lines moved or copied *within the same file*. `git blame -C` goes further and detects lines moved or copied *from other files* (or even other commits, with `-C -C`). I'd use `-M` for tracking code reshuffles during refactors within a file. I'd use `-C` when I suspect code was copied from another module or project, or if I need a more comprehensive history trace, understanding it might be slower.

4.  **Question:** Can `git blame` be misleading? Explain a scenario.
    **Answer:** Yes, `git blame` can be misleading. For instance, if a line of code was introduced in commit A, and then only whitespace was changed in commit B, `git blame` will attribute that line to commit B. Without flags like `-w`, it shows the *last change*, not necessarily the commit that introduced the logic. Similarly, large refactors can make blame information appear to "reset."