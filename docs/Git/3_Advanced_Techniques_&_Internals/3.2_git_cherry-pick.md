---
topic: Git
section: Advanced Techniques & Internals
subtopic: git cherry-pick
level: Advanced
---

## git cherry-pick
### Core Concepts

*   **`git cherry-pick`**: Applies the changes introduced by specific existing commits onto your current branch. It's like "picking" a commit from one branch and applying its patch to another.
*   **Purpose**: To selectively bring commits from one branch to another without merging the entire branch. Useful for applying bug fixes, small features, or reverting specific commits.

### Key Details & Nuances

*   **Patch Creation**: `cherry-pick` creates a *new* commit on the target branch with the same changes as the original commit, but with a different commit hash, parent, and author/committer timestamps.
*   **Order Matters**: Commits are applied in the order specified. If you cherry-pick multiple commits, they are applied sequentially.
*   **Conflict Resolution**: If the changes in the cherry-picked commit conflict with the current state of the target branch, Git will pause and require manual conflict resolution.
*   **Reference Specification**: Can take commit hashes, tags, or branch names.
*   **Options**:
    *   `--edit`: Allows you to edit the commit message before committing.
    *   `--no-commit`: Applies the changes to the working directory and staging area but does not create a new commit. Useful for combining multiple cherry-picks into a single commit.
    *   `--signoff`: Adds a `Signed-off-by` trailer to the commit.
    *   `--mainline <parent-number>`: When picking a merge commit, this specifies which parent's changes to apply.
    *   `--strategy <strategy>`: Allows specifying a merge strategy (e.g., `recursive`, `resolve`).

### Practical Examples

*   **Cherry-picking a single commit:**
    ```sh
    # On your target branch (e.g., main)
    git checkout main

    # Cherry-pick a commit from another branch (e.g., feature-branch)
    git cherry-pick <commit-hash-from-feature-branch>
    ```

*   **Cherry-picking a range of commits:**
    ```sh
    # Cherry-pick commits from A (exclusive) to B (inclusive) from feature-branch
    git cherry-pick <commit-hash-A>^..<commit-hash-B>
    ```

*   **Cherry-picking without committing:**
    ```sh
    git cherry-pick --no-commit <commit-hash>
    # Make further changes or cherry-pick more commits
    git commit -m "Applied specific changes"
    ```

*   **Visualizing cherry-pick:**
    ```mermaid
    graph TD;
        A["Branch A: Commit 1"] --> B["Branch A: Commit 2 (Target)"];
        C["Branch B: Commit X"] --> D["Branch B: Commit Y"];
        B --> E["New Branch: Commit 2' (Cherry-picked)"];
        D --> F["New Branch: Commit Y' (Cherry-picked)"];
    ```

### Common Pitfalls & Trade-offs

*   **Duplicate Commits**: Cherry-picking creates *new* commits with identical changes. This can lead to confusion if both the original and cherry-picked commits exist on different branches that are later merged.
*   **Loss of History Context**: The cherry-picked commit loses its original commit history and its place within a sequence of related commits on its source branch.
*   **Merge Conflicts**: Frequent cherry-picking, especially across divergent branches, significantly increases the likelihood of merge conflicts.
*   **Alternative to Merge**: `cherry-pick` is often a temporary solution. For integrating significant features or bug fixes that should be part of a branch's ongoing development, a regular `git merge` or `git rebase` is usually more appropriate.

### Interview Questions

1.  **What is `git cherry-pick` and when would you use it?**
    *   **Answer**: `git cherry-pick` applies the changes from an existing commit onto your current branch, creating a new commit. It's useful for selectively moving a small fix, a specific feature, or a revert from one branch to another without merging the entire source branch. For instance, applying a critical bug fix from a `develop` branch to a stable `release` branch.

2.  **What happens if a cherry-pick operation results in a conflict? How do you resolve it?**
    *   **Answer**: If conflicts occur, `git cherry-pick` stops, marking the conflicting files. You must manually resolve the `<<<<<<<`, `=======`, `>>>>>>>` markers in the affected files. After resolving, stage the files (`git add <file>`) and continue the cherry-pick process with `git cherry-pick --continue`. Alternatively, you can abort the operation with `git cherry-pick --abort`.

3.  **How does `git cherry-pick` differ from `git merge`?**
    *   **Answer**: `git merge` combines the histories of two branches, creating a new merge commit that points to the tip of both branches. It preserves the original commit history. `git cherry-pick`, on the other hand, takes the patch from a specific commit and reapplies it as a *new* commit on the current branch. This means the cherry-picked commit has a new commit hash and is not directly linked in history to its original commit, which can be a trade-off.

4.  **Can you cherry-pick a merge commit? What are the considerations?**
    *   **Answer**: Yes, you can cherry-pick a merge commit, but it requires specifying which parent's changes you want to apply using the `--mainline <parent-number>` option. For example, `--mainline 1` would pick the changes introduced by the first parent of the merge commit. This is crucial because a merge commit itself doesn't introduce changes; it combines changes from its parents. You need to decide which parent's line of development you want to graft onto your current branch.