---
topic: Git
section: Advanced Techniques & Internals
subtopic: Interactive Rebase (squash, fixup, reword)
level: Advanced
---

## Interactive Rebase (squash, fixup, reword)
### Core Concepts

*   **Interactive Rebase (`git rebase -i`):** A powerful Git command that allows you to rewrite commit history. It lets you pick, reorder, squash, fixup, edit, and split commits that are not yet pushed to a remote repository.
*   **Purpose:** Primarily used to clean up local commit history before merging or sharing it, making it more readable and logical.

### Key Details & Nuances

*   **Commit History Manipulation:**
    *   **`pick`**: Use the commit as is.
    *   **`reword`**: Use the commit, but edit the commit message.
    *   **`edit`**: Use the commit, but stop for amending. Allows modification of the commit's content and message.
    *   **`squash`**: Use the commit, but meld it into the previous commit. The commit message will be combined.
    *   **`fixup`**: Like `squash`, but discard this commit's commit message. Useful for small, trivial changes.
    *   **`drop`**: Remove the commit entirely.
*   **Workflow:**
    1.  Start an interactive rebase with `git rebase -i <commit-hash-or-ref>`. This opens an editor with a list of commits.
    2.  Modify the "action" (e.g., `pick`, `squash`, `fixup`) for each commit.
    3.  Save and close the editor. Git then applies the changes in sequence.
    4.  If `edit` is used, Git pauses, allowing you to make changes (`git add`, `git commit --amend`), and then continue (`git rebase --continue`).
    5.  If multiple commits are squashed or fixup-ed, Git may pause to combine commit messages.
*   **Targeting Commits:** Rebase against a specific commit hash, a branch name (e.g., `main`), or relative references (e.g., `HEAD~3` for the last 3 commits).
*   **"Safety Zone":** Never rebase commits that have already been pushed to a shared remote. Rewriting history that others have based their work on can cause significant problems for collaborators.

### Practical Examples

*   **Squashing last 3 commits into one:**
    ```sh
    # Assume your current commit is C3, with previous commits C2, C1, C0
    # You want to combine C3, C2, C1 into a single commit based on C0
    git rebase -i HEAD~3
    ```
    This opens an editor with content like:
    ```
    pick <hash_C1> Commit message for C1
    pick <hash_C2> Commit message for C2
    pick <hash_C3> Commit message for C3

    # Rebase <commit_before_C1>..<commit_before_C3> onto <commit_before_C1> (3 commands)
    #
    # Commands:
    # p, pick <commit> = use commit
    # r, reword <commit> = use commit, but edit the commit message
    # e, edit <commit> = use commit, but stop for amending
    # s, squash <commit> = use commit, but meld into previous commit
    # f, fixup <commit> = like "squash", but discard this commit's log message
    # x, exec <command> = run command (the rest of the line) using shell
    # b, break = stop here (continue rebase later with 'git rebase --continue')
    # ...
    ```
    Change to:
    ```
    pick <hash_C1> Commit message for C1
    squash <hash_C2> Commit message for C2
    squash <hash_C3> Commit message for C3
    ```
    Save and close. Git will then present a combined commit message editor for the squashed commits.

*   **Fixup last commit:**
    ```sh
    # You made a small typo in the last commit's message or added a forgotten file
    git commit --fixup HEAD
    git rebase -i HEAD~2 # Rebase on HEAD~2 to include the fixup commit
    ```
    In the editor, change the action for the fixup commit to `f` (or `fixup`):
    ```
    pick <hash_C2> Commit message for C2
    fixup <hash_C3> Commit message for C3 (fixup!)
    ```
    Save and close. Git will automatically apply the changes from `C3` to `C2` and discard `C3`'s message.

### Interview Questions

1.  **When would you use `git rebase -i` versus `git commit --amend`?**
    *   `git commit --amend` is for modifying the *very last* commit (its message or content). It's a simpler operation for minor fixes to the most recent commit.
    *   `git rebase -i` is for rewriting a *sequence* of commits. It's used for more complex history cleanup, like reordering, squashing multiple commits, fixing messages of older commits, or dropping commits that are no longer needed. It's a more powerful but also potentially more dangerous tool.

2.  **You've accidentally committed sensitive information to a branch that has already been pushed. How would you remove it and clean up the history?**
    *   This is a dangerous scenario because it involves rewriting shared history.
    *   **Step 1 (Remove sensitive data):** Use `git filter-branch` (or BFG Repo-Cleaner for better performance and safety) to rewrite history and remove the sensitive file/data.
    *   **Step 2 (Rewrite history):** After cleaning, you'll need to force-push (`git push --force` or `git push --force-with-lease`) to update the remote branch.
    *   **Crucially:** You *must* communicate this action to all collaborators immediately. They will need to re-clone or perform complex operations to align their local branches with the new history. Interactive rebase is generally not used for this specific, high-stakes cleanup; specialized tools are preferred.

3.  **Explain the difference between `squash` and `fixup` in `git rebase -i`.**
    *   **`squash`**: Melds a commit into the preceding one. It prompts you to edit the combined commit message, allowing you to integrate messages from both commits.
    *   **`fixup`**: Also melds a commit into the preceding one, but it discards the commit message of the commit being "fixup-ed." This is ideal for small, atomic changes or corrections where the commit message is redundant or adds noise.

4.  **What are the risks associated with using `git rebase -i` on public/shared branches?**
    *   **History Rewriting:** `git rebase -i` rewrites commit SHAs. If others have based their work on the original commits, their local history will diverge from the new rewritten history.
    *   **Collaboration Issues:** Pushing rewritten history onto a shared branch (e.g., `main` or a feature branch others are using) forces collaborators to perform complex Git operations (like `git rebase` or resetting their branch) to realign their local state, which can be error-prone and confusing.
    *   **Data Loss Potential:** Incorrectly using `drop` or `edit` followed by `--abort` can lead to lost work if not handled carefully.
    *   **Rule of Thumb:** Only rebase commits that are local to your repository and have not been shared with others.