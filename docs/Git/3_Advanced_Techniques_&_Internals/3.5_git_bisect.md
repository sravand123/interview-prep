---
topic: Git
section: Advanced Techniques & Internals
subtopic: git bisect
level: Advanced
---

## git bisect
### Core Concepts

*   **What it is:** `git bisect` is a Git command used to find the specific commit that introduced a bug or regression.
*   **How it works:** It automates a binary search through your commit history. You mark a "bad" commit (where the bug exists) and a "good" commit (where the bug doesn't exist). Git then checks out a commit roughly halfway between them and asks you to test. Based on whether that commit is "good" or "bad," Git halves the search space until the offending commit is pinpointed.

### Key Details & Nuances

*   **Binary Search:** Exploits the linear nature of commit history to efficiently narrow down the search space.
*   **`git bisect start`:** Initiates the bisecting process.
*   **`git bisect bad [commit-ish]`:** Marks a commit as containing the bug. Defaults to `HEAD` if not specified.
*   **`git bisect good [commit-ish]`:** Marks a commit as not containing the bug.
*   **`git bisect skip [commit-ish]`:** Used when a commit cannot be tested (e.g., it doesn't build or is unrelated to the bug). `git bisect` will pick another nearby commit.
*   **`git bisect reset`:** Exits the bisecting process and returns to the original `HEAD`. Crucial to run after finding the bug.
*   **Automation (`git bisect run`):** Allows scripting the test process. A script should exit with code 0 if the commit is "good" and a non-zero code (typically 1) if the commit is "bad."
*   **Path Filtering:** Can narrow the search to commits affecting specific files/directories using `git bisect start -- path/to/file`.
*   **Visualizing the Process:** `git log --graph --oneline` can help visualize the bisect range.

### Practical Examples

**Manual Bisect:**

```sh
# 1. Start the bisect session
git bisect start

# 2. Mark the current commit as bad (assuming the bug is present)
git bisect bad

# 3. Mark a known good commit (e.g., a previous release tag)
git bisect good v1.0.0

# Git checks out a commit. Test your code.

# 4. If the bug is present, mark this commit as bad
git bisect bad

# 5. If the bug is NOT present, mark this commit as good
git bisect good

# Repeat steps 4/5 until Git identifies the first bad commit.

# 6. Reset to the original HEAD after finding the commit
git bisect reset
```

**Automated Bisect:**

*   **`test.sh` (script to test for the bug):**

    ```sh
    #!/bin/sh
    make clean && make # Build the project
    if ./your_test_command; then
      exit 0 # Good commit
    else
      exit 1 # Bad commit
    fi
    ```

*   **Running the automated bisect:**

    ```sh
    # 1. Start and mark boundaries
    git bisect start
    git bisect bad
    git bisect good v1.0.0

    # 2. Run the script to automate testing
    git bisect run ./test.sh

    # 3. Reset after completion
    git bisect reset
    ```

### Interview Questions

1.  **Q: When would you use `git bisect` and what are its core advantages?**
    *   **A:** You use `git bisect` when you know a bug exists in your current codebase but don't know which commit introduced it. Its core advantage is efficiency; it automates a binary search, significantly reducing the number of commits you need to manually check compared to a linear scan. This is invaluable for large or long-lived projects.

2.  **Q: How does `git bisect run` differ from manual `git bisect`? What are the requirements for the script?**
    *   **A:** `git bisect run` automates the testing and marking process. Instead of you manually testing and typing `git bisect good` or `git bisect bad`, you provide a script. The script must exit with a status code of `0` if the current commit is good and a non-zero status code (conventionally `1`) if the current commit is bad. If a commit cannot be tested, the script should exit with code `125`.

3.  **Q: What is `git bisect skip` used for, and how does it affect the bisect process?**
    *   **A:** `git bisect skip` is used when a commit within the bisect range cannot be tested, perhaps because it doesn't compile or the bug you're looking for isn't testable on that specific commit. When `git bisect skip` is executed, Git will ignore that commit and choose another commit that is still within the remaining search range, attempting to maintain the binary search efficiency.

4.  **Q: Can `git bisect` be combined with specific file paths? How and why?**
    *   **A:** Yes, `git bisect start -- <path>` can be used to narrow the bisecting process to only commits that have modified specific files or directories. This is highly beneficial if you suspect the bug is localized to a particular part of the codebase, as it drastically reduces the number of commits Git needs to consider, making the search much faster.