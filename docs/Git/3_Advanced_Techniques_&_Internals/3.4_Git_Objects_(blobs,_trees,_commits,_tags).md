---
topic: Git
section: Advanced Techniques & Internals
subtopic: Git Objects (blobs, trees, commits, tags)
level: Advanced
---

## Git Objects (blobs, trees, commits, tags)
### Core Concepts

*   **Git Objects:** Git stores all data (files, commits, etc.) as objects, identified by SHA-1 hashes. This content-addressable system ensures integrity and efficient storage.
    *   **Blob (Binary Large Object):** Represents file content. A blob's SHA-1 hash is derived from the file's content itself.
    *   **Tree:** Represents a directory. It contains pointers (SHA-1 hashes) to blobs (files) and other trees (subdirectories). It also stores file modes and names.
    *   **Commit:** Represents a snapshot of the project at a specific point in time. It points to a tree object (representing the project's root directory) and contains metadata like author, committer, date, and a commit message. It also has pointers to parent commits.
    *   **Tag:** A reference to a specific commit. Can be lightweight (just a pointer) or annotated (an object itself with metadata like tagger, date, and message).

### Key Details & Nuances

*   **Immutability:** Once created, Git objects are immutable. Changing an object's content results in a new object with a new SHA-1 hash.
*   **Content-Addressable Storage:** The SHA-1 hash uniquely identifies the object based on its content. This means identical files will have the same blob object, saving space.
*   **Tree Structure:** A tree object is like a snapshot of a directory.
    *   `git ls-tree <tree-ish>`: Inspects the contents of a tree.
    *   `git cat-file -p <object-hash>`: Displays the content of any Git object.
*   **Commit History:** Each commit is linked to its parent(s), forming a directed acyclic graph (DAG) of the project's history.
*   **Tagging:**
    *   **Lightweight Tag:** Simply a pointer to a commit (e.g., `git tag v1.0`).
    *   **Annotated Tag:** A full object with metadata, recommended for releases (e.g., `git tag -a v1.0 -m "Version 1.0"`). Annotated tags can be signed.
*   **Object Internals:**
    *   **Blob:** `blob <size>\0<file content>`
    *   **Tree:** `tree <mode> <filename>\0<sha1>` (repeated for each entry)
    *   **Commit:** `tree <sha1>\nparent <sha1>\nauthor <name> <email> <timestamp>\ncommitter <name> <email> <timestamp>\n\n<commit message>`
    *   **Tag:** `object <sha1>\ntype <commit|tree|blob|tag>\ntag <tag name>\ntagger <name> <email> <timestamp>\n\n<tag message>`

### Practical Examples

*   **Creating and Inspecting Objects:**

    ```sh
    # Create a file
    echo "Hello Git Objects" > readme.md

    # Hash the file content to get the blob SHA
    git hash-object -w readme.md
    # Output: <blob_sha>

    # Inspect the blob object
    git cat-file -p <blob_sha>
    # Output: Hello Git Objects

    # Create a tree with the blob
    git mktree readme.md:<blob_sha>
    # Output: <tree_sha>

    # Inspect the tree object
    git cat-file -p <tree_sha>
    # Output: <blob_mode> blob <blob_sha>  readme.md

    # Create a commit with the tree
    git commit-tree <tree_sha> -m "Initial commit"
    # Output: <commit_sha>

    # Inspect the commit object
    git cat-file -p <commit_sha>
    # Output: tree <tree_sha>
    #         author <...>
    #         committer <...>
    #
    #         Initial commit

    # Create an annotated tag
    git tag -a v1.0 <commit_sha> -m "Release v1.0"

    # Inspect the tag object
    git cat-file -p v1.0
    # Output: object <commit_sha>
    #         type commit
    #         tag v1.0
    #         tagger <...>
    #
    #         Release v1.0

    # Get the tag's commit SHA
    git rev-parse v1.0
    # Output: <commit_sha>
    ```

*   **Visualizing Commit History (Conceptual):**

    ```mermaid
    graph TD;
        A["Commit A"] --> B["Commit B"];
        A --> C["Commit C"];
        B --> D["Commit D"];
        C --> D;
    ```

### Common Pitfalls & Trade-offs

*   **Misunderstanding SHA-1:** It's derived from content, not just metadata. Identical files (even in different branches) share the same blob.
*   **Over-reliance on `git cat-file`:** While powerful for understanding, in day-to-day use, commands like `git log`, `git show`, `git ls-tree` are more practical.
*   **Lightweight vs. Annotated Tags:** For release management, annotated tags are preferred due to their richer metadata and verifiability. Lightweight tags are often for internal, temporary pointers.
*   **Internal Object Representation:** While understanding the structure (`blob <size>\0<content>`) is good, Git abstracts this. Direct manipulation of objects is rarely needed for typical SDE workflows.

### Interview Questions

1.  **How does Git store file content and directory structure? Explain the role of blobs and trees.**
    *   **Answer:** Git stores file content as **blobs**, where the SHA-1 hash is directly derived from the file's content. Directory structures are represented by **trees**, which are essentially lists of blobs and other trees, along with their names and permissions. This hierarchical structure, anchored by commits, allows Git to efficiently track changes and reconstruct project states.

2.  **What is the difference between a lightweight tag and an annotated tag in Git? When would you use each?**
    *   **Answer:** A **lightweight tag** is just a pointer to a specific commit. It's simple and quick but contains no extra information. An **annotated tag** is a full Git object with its own SHA-1 hash. It stores metadata like the tagger's name, email, date, and a message, and can be cryptographically signed. Use **annotated tags** for significant milestones like releases, as they provide more context and traceability. Use **lightweight tags** for temporary, private references.

3.  **If you have two identical files (same content, same name) in different directories within your project, how does Git handle them internally?**
    *   **Answer:** Git will create only *one* **blob** object for the content because the SHA-1 hash is content-based. The **tree** objects representing the directories will simply contain separate entries pointing to this same blob object, each associated with its respective directory path and filename. This deduplication saves storage space.

4.  **Explain the immutability of Git objects and its implications.**
    *   **Answer:** Once a Git object (blob, tree, commit, tag) is created, its content cannot be changed. If you modify an object's content (e.g., change a file's content, which affects its blob), Git generates a *new* object with a new SHA-1 hash. This immutability guarantees the integrity and history of the repository; past states cannot be altered without leaving a clear trace (by creating new objects and new commit references).

5.  **Describe the components of a Git commit object.**
    *   **Answer:** A Git commit object primarily contains:
        *   A pointer to the **tree object** representing the project's root directory state for that commit.
        *   Pointers to its **parent commit(s)** (forming the history chain).
        *   Metadata: author name/email, committer name/email, timestamp, timezone.
        *   A commit message describing the changes.