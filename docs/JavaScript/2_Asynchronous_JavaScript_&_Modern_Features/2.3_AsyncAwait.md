---
topic: JavaScript
section: Asynchronous JavaScript & Modern Features
subtopic: Async/Await
level: Intermediate
---

## Async/Await

### Core Concepts

- **Syntactic Sugar for Promises:** `async/await` provides a cleaner, more readable way to work with asynchronous operations, making asynchronous code look and behave more like synchronous code. It's built on top of JavaScript Promises.
- **Sequential Execution:** The `await` keyword pauses the execution of an `async` function until the awaited Promise settles (resolves or rejects). This allows for sequential reasoning about asynchronous steps.
- **Non-blocking:** While `await` pauses the _current `async` function_, it does not block the main thread of execution. Other code outside the `async` function continues to run.

### Key Details & Nuances

- **`async` Function Always Returns a Promise:**
  - If an `async` function returns a non-Promise value, it's implicitly wrapped in a resolved Promise.
  - If an `async` function throws an error, it implicitly returns a rejected Promise.
  - This allows chaining `.then()` and `.catch()` after calling an `async` function.
- **`await` Can Only Be Used Inside `async` Functions:**
  - Using `await` outside an `async` function (e.g., in the global scope in older environments, or inside a regular function) will result in a `SyntaxError`.
  - Top-level `await` is supported in JavaScript modules (`type: "module"` in `package.json` or `<script type="module">`) and certain environments (e.g., Node.js REPL, modern browser developer consoles).
- **Error Handling:** Use standard `try...catch` blocks to handle rejected Promises (errors) within `async` functions. This replaces `.catch()` chains.
- **Microtask Queue:** When an `async` function is called, it starts executing synchronously until it hits the first `await`. At that point, the remainder of the `async` function (after the `await`) is scheduled as a microtask to be executed once the awaited Promise resolves. This ensures that microtasks (like `.then()` callbacks) are prioritized over macrotasks (like `setTimeout`).

### Practical Examples

```typescript
// Example 1: Basic async/await with error handling
async function fetchData(url: string): Promise<any> {
  try {
    console.log('Fetching data...');
    const response = await fetch(url); // Pauses here until fetch promise resolves
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json(); // Pauses here until json parsing promise resolves
    console.log('Data fetched successfully!');
    return data;
  } catch (error) {
    console.error('Failed to fetch data:', error);
    // Re-throw or return a default value based on application needs
    throw error;
  }
}

// Example usage:
(async () => {
  const correctUrl = 'https://jsonplaceholder.typicode.com/todos/1';
  const wrongUrl = 'https://invalid.url/data';

  try {
    const todo = await fetchData(correctUrl);
    console.log('Todo:', todo.title);
  } catch (err) {
    console.error('Caught error during correct URL fetch:', err.message);
  }

  console.log('--- Attempting wrong URL ---');

  try {
    await fetchData(wrongUrl);
  } catch (err) {
    console.error('Caught error during wrong URL fetch:', err.message);
  }
})();

// Example 2: Sequential vs. Parallel execution with Promise.all
async function processSequential() {
  console.log('Sequential processing started');
  await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 sec
  console.log('First step done');
  await new Promise((resolve) => setTimeout(resolve, 500)); // Wait 0.5 sec
  console.log('Second step done');
  console.log('Sequential processing finished');
}

async function processParallel() {
  console.log('Parallel processing started');
  // Both promises run concurrently
  await Promise.all([
    new Promise((resolve) => setTimeout(resolve, 1000)),
    new Promise((resolve) => setTimeout(resolve, 500)),
  ]);
  console.log('All parallel steps done (after 1 second, max of 1s and 0.5s)');
  console.log('Parallel processing finished');
}

(async () => {
  await processSequential(); // Takes ~1.5 seconds
  console.log('\n---');
  await processParallel(); // Takes ~1 second
})();
```

### Common Pitfalls & Trade-offs

- **Over-sequentialization:** Excessively using `await` for independent asynchronous operations can lead to slower execution times. If tasks don't depend on each other, run them in parallel using `Promise.all` or `Promise.allSettled`.

  ```typescript
  // Pitfall: Sequential, when it could be parallel
  async function getUserAndPostsSequential(userId: number) {
    const user = await fetch(`/api/users/${userId}`).then((res) => res.json());
    const posts = await fetch(`/api/users/${userId}/posts`).then((res) =>
      res.json()
    );
    return { user, posts }; // Takes longer because calls are serialized
  }

  // Better: Parallel execution
  async function getUserAndPostsParallel(userId: number) {
    const [user, posts] = await Promise.all([
      fetch(`/api/users/${userId}`).then((res) => res.json()),
      fetch(`/api/users/${userId}/posts`).then((res) => res.json()),
    ]);
    return { user, posts }; // Faster, calls run concurrently
  }
  ```

- **Forgetting `await`:** Calling an `async` function without `await` (or `.then()`) will return a pending Promise, not its resolved value. This can lead to unexpected behavior or difficult-to-debug race conditions.

  ```typescript
  async function sayHello() {
    await new Promise((resolve) => setTimeout(resolve, 100));
    return 'Hello';
  }

  async function processGreeting() {
    const greetingPromise = sayHello(); // Missing await here! greetingPromise is a Promise<string>
    console.log(greetingPromise); // Logs: Promise { <pending> }

    const greeting = await sayHello(); // Correct usage
    console.log(greeting); // Logs: "Hello"
  }
  processGreeting();
  ```

- **`await` in `forEach`:** `forEach` is not `async`-aware. Using `await` directly inside `forEach` will not pause the outer `async` function; the `forEach` loop will complete synchronously, and the awaited operations will run concurrently _after_ the loop has finished, potentially leading to race conditions or incorrect order of operations. Use `for...of` or `Promise.all` for asynchronous iteration.

  ```typescript
  async function processItems(items: string[]) {
    // Pitfall: `await` inside `forEach` doesn't work as expected for sequential processing
    items.forEach(async (item) => {
      await new Promise((resolve) => setTimeout(resolve, 100));
      console.log(`Processed (forEach): ${item}`); // Logs might be out of order or all at once
    });
    console.log('forEach loop finished (outer context)'); // This logs *before* items are processed
  }

  async function processItemsCorrectly(items: string[]) {
    // Correct: Use for...of for sequential processing
    for (const item of items) {
      await new Promise((resolve) => setTimeout(resolve, 100));
      console.log(`Processed (for-of): ${item}`); // Logs in order
    }
    console.log('for-of loop finished');
  }

  // To process concurrently with Promise.all:
  async function processItemsConcurrently(items: string[]) {
    await Promise.all(
      items.map(async (item) => {
        await new Promise((resolve) => setTimeout(resolve, 100));
        console.log(`Processed (concurrently): ${item}`);
      })
    );
    console.log('Concurrent processing finished');
  }

  (async () => {
    console.log('--- Pitfall example ---');
    await processItems(['a', 'b', 'c']); // await here is for the *outer* promise if processItems returned one.
    // The async operations inside forEach are detached.
    await new Promise((resolve) => setTimeout(resolve, 500)); // Give time for forEach's async ops to finish

    console.log('\n--- Correct for...of example ---');
    await processItemsCorrectly(['d', 'e', 'f']);

    console.log('\n--- Correct concurrent example ---');
    await processItemsConcurrently(['g', 'h', 'i']);
  })();
  ```

### Interview Questions

1.  **What problem does `async/await` solve, and how does it relate to Promises?**

    - **Answer:** `async/await` provides a more readable and synchronous-looking syntax for writing asynchronous code, addressing callback hell and chained `.then()` readability issues. It's syntactic sugar built on top of Promises; an `async` function always returns a Promise, and `await` pauses execution until a Promise settles, allowing its resolved value (or rejected error) to be handled directly.

2.  **Explain the difference in error handling between traditional Promise chains (`.then().catch()`) and `async/await`.**

    - **Answer:** With traditional Promises, errors are caught using a `.catch()` method at the end of a chain. With `async/await`, error handling is done using standard `try...catch` blocks, similar to synchronous code. If an `await`ed Promise rejects, the error is thrown and can be caught by the surrounding `try...catch` block.

3.  **When should you use `Promise.all` instead of multiple `await` calls for independent asynchronous operations? Provide an example.**

    - **Answer:** Use `Promise.all` when you have multiple independent asynchronous operations that do not depend on each other's results, and you want them to execute concurrently to improve performance. Using multiple `await` calls sequentially would force each operation to wait for the previous one to complete, leading to longer total execution time.
      - **Example (Conceptual):** Fetching user data and product data from two different API endpoints concurrently using `Promise.all` is faster than awaiting each `fetch` call sequentially.

4.  **Can you use `await` outside an `async` function? Explain the context.**

    - **Answer:** Traditionally, no. `await` can only be used directly inside an `async` function. Using it elsewhere would result in a `SyntaxError`. However, with the introduction of **top-level `await`**, it is now possible to use `await` outside an `async` function within JavaScript modules (`<script type="module">` or Node.js ES Modules) and some specific environments (like browser developer consoles or Node.js REPL), allowing for asynchronous operations directly at the module's root without an enclosing `async` IIFE.

5.  **Describe the execution flow when an `async` function encounters an `await` keyword. What happens to the rest of the `async` function and the main thread?**
    - **Answer:** When an `async` function hits an `await` keyword, it first executes the expression after `await`. If that expression returns a Promise, the `async` function pauses its execution and yields control back to the event loop. The main thread is _not_ blocked and continues to execute other tasks. Once the awaited Promise settles (resolves or rejects), the remainder of the `async` function (from immediately after the `await`) is placed onto the **microtask queue** to be executed as soon as the call stack is clear. If the awaited expression is not a Promise, the value is returned immediately, and the `async` function continues synchronously.
