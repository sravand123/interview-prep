---
topic: JavaScript
section: Asynchronous JavaScript & Modern Features
subtopic: ES6+ Data Structures (Map, Set, WeakMap)
level: Intermediate
---

## ES6+ Data Structures (Map, Set, WeakMap)

### Core Concepts

- **Map:** An ordered collection of key-value pairs.
  - **Keys:** Can be _any_ data type (primitives, objects, functions), unlike plain objects where keys are implicitly strings or Symbols.
  - **Order:** Maintains insertion order, allowing for ordered iteration.
- **Set:** An ordered collection of _unique_ values.
  - **Values:** Can be any data type.
  - **Uniqueness:** Ensures each value appears only once, based on the Same-value-zero algorithm (similar to strict equality `===`, but `NaN` is considered equal to `NaN`, and `+0` is equal to `-0`).
  - **Order:** Maintains insertion order, allowing for ordered iteration.
- **WeakMap:** A collection of key-value pairs where keys _must_ be objects and are _weakly referenced_.
  - **Weak Reference:** If the only reference to a key object exists within a `WeakMap`, that object (and its corresponding value in the `WeakMap`) can be garbage collected. This prevents memory leaks.
  - **Keys:** Only non-null objects can be keys. Primitives are not allowed.
- **WeakSet:** A collection of _unique objects_ where the values are _weakly referenced_.
  - **Weak Reference:** Similar to `WeakMap`, if the only reference to an object exists within a `WeakSet`, it can be garbage collected.
  - **Values:** Only non-null objects can be values. Primitives are not allowed.

### Key Details & Nuances

- **Map Details:**
  - **API:** `new Map()`, `map.set(key, value)`, `map.get(key)`, `map.has(key)`, `map.delete(key)`, `map.clear()`, `map.size`.
  - **Iteration:** Iterable using `for...of` (returns `[key, value]` pairs), `map.keys()`, `map.values()`, `map.entries()`. Order is guaranteed insertion order.
- **Set Details:**
  - **API:** `new Set()`, `set.add(value)`, `set.has(value)`, `set.delete(value)`, `set.clear()`, `set.size`.
  - **Iteration:** Iterable using `for...of` (returns values), `set.values()` (same as `set.keys()`), `set.entries()` (returns `[value, value]` pairs). Order is guaranteed insertion order.
- **WeakMap Details:**
  - **Memory Management:** Crucial for preventing memory leaks, especially when associating data with objects that might be removed (e.g., DOM elements).
  - **Non-Enumerable/Non-Iterable:** `WeakMap`s are not iterable (cannot use `for...of`, `keys()`, `values()`, `entries()`) and do not have a `size` property. This is because their contents are subject to garbage collection at any time, making a stable iteration impossible.
  - **Limited API:** `new WeakMap()`, `weakMap.set(key, value)`, `weakMap.get(key)`, `weakMap.has(key)`, `weakMap.delete(key)`. No `clear()` or `size`.
- **WeakSet Details:**
  - **Memory Management:** Similar benefits to `WeakMap` for unique object collections.
  - **Non-Enumerable/Non-Iterable:** Similar to `WeakMap`, not iterable and has no `size`.
  - **Limited API:** `new WeakSet()`, `weakSet.add(value)`, `weakSet.has(value)`, `weakSet.delete(value)`. No `clear()` or `size`.

### Practical Examples

```typescript
// Map Example
console.log('--- Map Example ---');
const user1 = { id: 1, name: 'Alice' };
const user2 = { id: 2, name: 'Bob' };
const user3 = { id: 3, name: 'Charlie' };

const userRoles = new Map<object, string>();
userRoles.set(user1, 'Admin');
userRoles.set(user2, 'Editor');
userRoles.set(user3, 'Viewer');

// Using an object as a key
const config = {};
userRoles.set(config, 'Configuration Object');

console.log(`Role for user1: ${userRoles.get(user1)}`); // Output: Role for user1: Admin
console.log(`Map size: ${userRoles.size}`); // Output: Map size: 4

// Iteration order is preserved
for (const [user, role] of userRoles) {
  console.log(`${user === config ? 'Config' : user.name}: ${role}`);
}
/* Output:
Alice: Admin
Bob: Editor
Charlie: Viewer
Config: Configuration Object
*/

// Set Example
console.log('\n--- Set Example ---');
const tags = new Set<string>();
tags.add('JavaScript');
tags.add('TypeScript');
tags.add('React');
tags.add('JavaScript'); // Adding duplicate has no effect

console.log(`Set size: ${tags.size}`); // Output: Set size: 3
console.log(`Has 'React'? ${tags.has('React')}`); // Output: Has 'React'? true

for (const tag of tags) {
  console.log(tag);
}
/* Output:
JavaScript
TypeScript
React
*/

// WeakMap Example (conceptual, as GC is non-deterministic)
console.log('\n--- WeakMap Example ---');
let element = document.createElement('div');
const privateData = new WeakMap<HTMLElement, { secret: string }>();

privateData.set(element, { secret: 'Confidential Info' });
console.log(`Private data for element: ${privateData.get(element)?.secret}`); // Output: Private data for element: Confidential Info

// If 'element' loses all other references, it will be garbage collected,
// and its entry in 'privateData' will also be automatically removed.
// We can't directly observe this removal or iterate the WeakMap.
element = null as any; // Dereference the element
// At some point, GC *might* collect the div and its WeakMap entry.
// privateData.get(element) would return undefined after GC.
// There is no privateData.size or privateData.keys() to check this.
```

### Common Pitfalls & Trade-offs

- **Map vs. Plain Object (`{}`):**
  - **`Map` Advantages:** Keys can be any data type (objects, functions, primitives), preserves insertion order, has a reliable `size` property, better performance for frequent additions/deletions.
  - **`Object` Advantages:** Simpler literal syntax (`{}`), often used for fixed, known string keys. However, object keys are coerced to strings, and iteration order is not guaranteed for older JS versions or numeric keys. Can have prototype chain issues if not careful (`hasOwnProperty`, `Object.create(null)`).
  - **Choose `Map`** when you need non-string keys, guaranteed iteration order, or a reliable `size`. Choose `Object` for simple collections with string/symbol keys or when working with JSON-like data.
- **Set vs. Array for Uniqueness:**
  - **`Set` Advantages:** Provides efficient O(1) average time complexity for adding, deleting, and checking existence (`has()`). Automatically handles uniqueness.
  - **`Array` Disadvantages:** Checking for existence (`includes()`) is O(N). Removing duplicates requires manual iteration or filtering.
  - **Choose `Set`** when managing unique items or quickly filtering unique values from an existing array.
- **WeakMap/WeakSet Misconceptions:**
  - **GC Guarantee:** Garbage collection is non-deterministic. An object might remain in memory for an arbitrary time even if it's only weakly referenced. `WeakMap`s and `WeakSet`s only allow for _potential_ collection, not immediate or guaranteed collection.
  - **Iterability:** A common mistake is trying to iterate or get the size of a `WeakMap`/`WeakSet`. This is explicitly not supported because their contents are unstable due to GC. This limitation is a deliberate design choice to enable weak references.
  - **Key/Value Types:** Remember `WeakMap` keys and `WeakSet` values _must_ be objects. Using primitives will result in an error. This is because primitives are inherently not garbage-collectible in the same way objects are.

### Interview Questions

1.  **When would you choose a `Map` over a plain JavaScript `Object` for storing key-value pairs?**

    - **Answer:** You'd choose `Map` when you need keys to be non-string types (e.g., objects, functions), when you require guaranteed insertion order for iteration, or when you need an accurate `size` property. `Map` also avoids potential prototype chain issues that can affect plain objects.

2.  **Explain the primary use cases and benefits of `WeakMap` compared to `Map`.**

    - **Answer:** `WeakMap`'s primary benefit is its weak referencing of keys, which allows for automatic garbage collection of key-value pairs when the key object is no longer referenced elsewhere. This prevents memory leaks, especially when associating metadata with objects (like DOM elements) that might be removed from the application. `Map` holds strong references, meaning its keys will prevent objects from being garbage collected. `WeakMap` is suitable for private data, caching where keys are objects, or associating data with objects managed by external code.

3.  **How does `Set` ensure uniqueness, and what are its performance characteristics compared to an array for checking item existence?**

    - **Answer:** `Set` ensures uniqueness using the Same-value-zero algorithm, which treats `NaN` as equal to `NaN` and `+0` as equal to `-0`. For checking item existence (`set.has(value)`), `Set` provides near O(1) (constant time on average) performance. In contrast, checking item existence in an array (`array.includes(value)`) has O(N) (linear time) performance, as it may need to iterate through the entire array.

4.  **Can you use a primitive value (like a string, number, or boolean) as a key in a `WeakMap`? Why or why not?**

    - **Answer:** No, you cannot use primitive values as keys in a `WeakMap`. `WeakMap` keys _must_ be objects. This is because primitives are not subject to garbage collection in the same way objects are; they don't have references in the same sense. The core purpose of `WeakMap` is to allow its entries to be garbage-collected along with their keys, which only makes sense for objects that can be collected.

5.  **Describe a scenario where using a `WeakMap` would explicitly help prevent a memory leak.**
    - **Answer:** A common scenario is associating private data or event listeners with DOM elements. If you use a regular `Map` to store data keyed by DOM elements, and those elements are later removed from the DOM and no longer referenced by the application, the `Map` would still hold a strong reference to them, preventing their garbage collection and leading to a memory leak. By using a `WeakMap` instead, once the DOM element is removed and no other references exist, it (and its corresponding entry in the `WeakMap`) can be garbage collected, preventing the leak.
