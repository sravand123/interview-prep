---
topic: JavaScript
section: Core Concepts & Interview Fundamentals
subtopic: Closures & Scope
level: Beginner
---

## Closures & Scope

### Core Concepts

- **Scope:** Determines the accessibility of variables, functions, and objects in some part of your code.
  - **Global Scope:** Variables declared outside any function or block are accessible anywhere.
  - **Function (Local) Scope:** Variables declared within a function are only accessible inside that function. Each function call creates a new scope.
  - **Block Scope (`let`, `const`):** Variables declared within a block (`{...}`) are only accessible within that block. This includes `if` statements, `for` loops, etc. Introduced with ES6.
  - **Lexical (Static) Scoping:** Functions are executed using the scope chain that was in effect when they were _defined_ (lexical environment), not when they were _called_. This is fundamental to closures.
- **Closures:** A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (its lexical environment).
  - They give you access to an outer function's scope from an inner function.
  - They "remember" the environment in which they were created, even after the outer function has finished executing.

### Key Details & Nuances

- **Variable Capture by Reference:** When a closure captures a variable from its outer scope, it captures a _reference_ to that variable, not a copy of its value at the time of creation. If the outer variable changes before the closure is invoked, the closure will see the updated value.
- **Persistent State:** Closures allow functions to maintain private variables, enabling patterns like private methods in object-oriented programming (before class syntax was widespread or for functional patterns).
- **New Closure Per Call:** Each time an outer function is called, a _new_ lexical environment is created for that call. If the outer function returns an inner function (a closure), that closure will be bound to that _specific_ lexical environment, even if the outer function is called multiple times.
- **ES6 `let` and `const` vs. `var`:**
  - `var` is function-scoped (or globally scoped). This often leads to the "loop trap" where inner functions capture the final value of a loop variable.
  - `let` and `const` are block-scoped. In a loop, `let` declares a _new_ variable for each iteration, correctly capturing the per-iteration value for any inner closures.

### Practical Examples

**Common Loop Trap (and its fix) demonstrating Scope & Closures:**

```typescript
function createIncrementersVar(): Function[] {
  const incrementers: Function[] = [];
  for (var i = 0; i < 3; i++) {
    // 'var' is function-scoped
    incrementers.push(function () {
      console.log(`Incrementer var: ${i}`); // 'i' is captured by reference
    });
  }
  return incrementers;
}

function createIncrementersLet(): Function[] {
  const incrementers: Function[] = [];
  for (let i = 0; i < 3; i++) {
    // 'let' is block-scoped, new 'i' per iteration
    incrementers.push(function () {
      console.log(`Incrementer let: ${i}`); // 'i' correctly captured for each iteration
    });
  }
  return incrementers;
}

const varInc = createIncrementersVar();
varInc[0](); // Output: Incrementer var: 3
varInc[1](); // Output: Incrementer var: 3
varInc[2](); // Output: Incrementer var: 3

const letInc = createIncrementersLet();
letInc[0](); // Output: Incrementer let: 0
letInc[1](); // Output: Incrementer let: 1
letInc[2](); // Output: Incrementer let: 2
```

### Common Pitfalls & Trade-offs

- **Memory Leaks:** If a closure retains a reference to a large outer scope (e.g., a DOM element that is later removed from the page), it can prevent garbage collection of that scope, leading to memory leaks.
- **Unexpected Variable Values in Loops:** As shown in the example, using `var` inside a loop when defining functions within it often leads to all functions referencing the final value of the loop counter.
- **Performance Overhead:** While generally negligible, creating many closures can incur a slight performance cost due to the need to manage their lexical environments.
- **Complexity:** Overuse or poorly designed closures can make code harder to read, debug, and reason about, especially for developers unfamiliar with the pattern.

### Interview Questions

1.  **What is a closure in JavaScript, and why are they useful?**

    - **Answer:** A closure is a function bundled with its lexical environment. It gives access to an outer function's scope from an inner function, even after the outer function has finished executing. They are useful for maintaining private state (e.g., in module patterns), creating factory functions for specific configurations, implementing memoization, and ensuring data privacy.

2.  **Explain the difference between `var`, `let`, and `const` with respect to scope. How do they impact closures?**

    - **Answer:** `var` is function-scoped or globally-scoped. `let` and `const` are block-scoped. This distinction significantly impacts closures in loops: `var` creates a single variable shared across loop iterations, causing all inner closures to reference its final value. `let` (and `const`) creates a new variable for each loop iteration, allowing each inner closure to correctly capture its specific iteration value.

3.  **How do closures relate to the module pattern in JavaScript?**

    - **Answer:** The module pattern (often an Immediately Invoked Function Expression - IIFE - that returns an object) heavily relies on closures. Variables and functions declared inside the IIFE are kept private, while the returned object's methods are closures that can access these private members, effectively creating public APIs with private state, mimicking encapsulation.

4.  **Describe a scenario where a closure might inadvertently lead to a memory leak.**

    - **Answer:** A common scenario is when a closure captures a reference to a large DOM element or an object from its outer scope. If that DOM element is later removed from the page, but the closure (e.g., an event listener) is still alive and referencing it, the element cannot be garbage collected, leading to a memory leak. This happens because the closure's lexical environment prevents the original object from being freed.

5.  **You have a `for` loop that creates five functions, each intended to `console.log` its iteration number. If you use `var` for the loop variable, what will happen when you call these functions, and how can you fix it using `let` or another method?**
    - **Answer:** If `var` is used, all five functions will log `5` (or the loop's final condition value) because `var` is function-scoped, and all closures capture a reference to the _same_ `i` variable, which has its final value of `5` when the loop finishes. To fix this with `let`, change `var i` to `let i`. `let` is block-scoped, so a new `i` is created for each iteration, and each closure correctly captures its specific `i` value (0, 1, 2, 3, 4). Alternatively, an IIFE could be used inside the `var` loop to create a new scope for each iteration.
