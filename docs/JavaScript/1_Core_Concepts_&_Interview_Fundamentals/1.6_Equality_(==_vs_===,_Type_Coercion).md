---
topic: JavaScript
section: Core Concepts & Interview Fundamentals
subtopic: Equality (== vs ===, Type Coercion)
level: Beginner
---

## Equality (== vs ===, Type Coercion)

### Core Concepts

- **Loose Equality (`==`)**: Compares two values for equality after converting both values to a common type (type coercion). It prioritizes value comparison over type strictness.
- **Strict Equality (`===`)**: Compares two values for equality _without_ type coercion. Both the value and the type must be identical for the comparison to return `true`. It prioritizes type strictness and predictability.

### Key Details & Nuances

- **`===` (Strict Equality)**:
  - **No Coercion**: Does not perform any implicit type conversion. If types differ, the result is always `false`.
  - **Predictable**: Generally preferred in modern JavaScript development due to its consistent and predictable behavior.
  - **Reference vs. Value**: For objects (including arrays, functions), `===` compares by reference. Two distinct objects with identical properties will be `false` because they point to different memory locations. Primitives (numbers, strings, booleans, `null`, `undefined`, `symbol`, `bigint`) are compared by value.
  - **Edge Cases**:
    - `NaN === NaN` is `false`. (`NaN` is the only value in JavaScript not equal to itself.)
    - `+0 === -0` is `true`.
- **`==` (Loose Equality)**:
  - **Type Coercion Rules**: Follows a complex set of rules to convert operands to a common type before comparison. Common rules include:
    - If one operand is a string and the other is a number, the string is converted to a number.
    - If one operand is boolean, it's converted to a number (`true` becomes `1`, `false` becomes `0`).
    - `null == undefined` is `true`. (`null` is only loosely equal to `undefined` and itself).
    - If an object is compared with a primitive, the object is converted to a primitive value (via `valueOf()` or `toString()`).
  - **Unpredictable**: Can lead to unexpected results and subtle bugs, making code harder to debug and reason about.
  - **Avoidance**: Rarely recommended in production code unless specific coercion behavior is _explicitly_ desired and understood, which is rare.

### Practical Examples

```typescript
// Strict Equality (===) - Recommended
console.log(1 === 1); // true (Same type, same value)
console.log(1 === '1'); // false (Different types: number vs string)
console.log(true === 1); // false (Different types: boolean vs number)
console.log(null === undefined); // false (Different types)
console.log(NaN === NaN); // false (NaN is never equal to itself)
console.log(0 === -0); // true (Same type, same value)

const obj1 = { a: 1 };
const obj2 = { a: 1 };
console.log(obj1 === obj2); // false (Different references)
console.log(obj1 === obj1); // true (Same reference)

// Loose Equality (==) - Avoid where possible
console.log(1 == '1'); // true (String '1' coerced to number 1)
console.log(true == 1); // true (Boolean true coerced to number 1)
console.log(false == 0); // true (Boolean false coerced to number 0)
console.log(null == undefined); // true (Special rule: null and undefined are loosely equal)
console.log('' == 0); // true (Empty string coerced to 0)
console.log([] == 0); // true (Empty array coerced to '') then to 0
console.log([1] == '1'); // true (Array [1] coerced to '1')
console.log([1, 2] == '1,2'); // true (Array [1,2] coerced to '1,2')

// Object coercion example for ==
const customObj = {
  valueOf: () => 1,
  toString: () => '2',
};
console.log(customObj == 1); // true (customObj.valueOf() is used: 1 == 1)
console.log(customObj == '2'); // true (customObj.toString() is used: '2' == '2')
```

### Common Pitfalls & Trade-offs

- **Unintended Coercion**: The biggest pitfall of `==` is its unpredictable type coercion, leading to hard-to-find bugs (e.g., `"" == false` is `true`, `[1] == true` is `true`).
- **`NaN` Behavior**: Forgetting that `NaN === NaN` is `false` can lead to incorrect logic. Use `Number.isNaN()` to reliably check for `NaN`.
- **Object Comparison**: Misunderstanding that `==` and `===` compare objects by reference, not by value. To compare object content, you must iterate through properties or use a deep equality function.
- **Readability & Maintainability**: Code using `==` can be less readable and harder to maintain due to the implicit type conversions. `===` is clearer about developer intent.
- **Performance**: While `===` is theoretically marginally faster as it skips coercion, the performance difference is negligible in most real-world applications. The primary trade-off is predictability and correctness over micro-optimization.

### Interview Questions

1.  **Explain the fundamental difference between `==` and `===`. When would you use one over the other in practice?**
    - **Answer**: `===` compares values without type coercion, requiring both type and value to be identical. `==` performs type coercion before comparison. In practice, `===` is almost always preferred for its predictability and to prevent unexpected bugs from implicit type conversions. `==` is rarely used except in very specific, well-understood scenarios, or often as a sign of less robust code.
2.  **Can you provide a few examples where `==` yields surprising results due to type coercion? How would you typically handle such comparisons in robust JavaScript code?**
    - **Answer**: Examples include `false == []` (true), `null == false` (false), `0 == ' '` (true), `'1' == true` (true). To handle such comparisons robustly, always use `===` unless you have an extremely specific reason not to. For checking "falsiness" of a value, explicitly convert to boolean (`!!value`) or use `Boolean(value)` before comparison if that's the desired semantic.
3.  **What's the output of `NaN === NaN` and why? How would you reliably check if a variable holds a `NaN` value?**
    - **Answer**: `NaN === NaN` outputs `false`. This is a unique property of `NaN` â€“ it's the only value in JavaScript that is not equal to itself, even strictly. To reliably check for `NaN`, use the `Number.isNaN()` function, which correctly identifies `NaN` values without coercion issues.
4.  **How do `==` and `===` behave when comparing objects (including arrays and functions) versus primitive values?**
    - **Answer**: For primitive values (numbers, strings, booleans, `null`, `undefined`, `symbol`, `bigint`), both `==` and `===` compare by value, though `==` will perform type coercion if types differ. For objects (including arrays and functions), both `==` and `===` compare by reference. They only return `true` if both operands refer to the _exact same object_ in memory, not if they merely have identical content.
5.  **Discuss the concept of "falsy" values in JavaScript and how they interact with `==` and `===` comparisons, particularly in conditional statements.**
    - **Answer**: Falsy values are values that evaluate to `false` when explicitly converted to a boolean (e.g., `false`, `0`, `""`, `null`, `undefined`, `NaN`). In conditional statements (e.g., `if (value)`), JavaScript implicitly converts the value to a boolean, so falsy values act as `false`. When using `==`, falsy values often exhibit unexpected equality (e.g., `0 == false` is `true`, `"" == 0` is `true`). With `===`, however, types must match, so `0 === false` is `false`, and `"" === 0` is `false`. This reinforces why `===` is safer, as it doesn't rely on implicit falsy/truthy conversions for equality checks.
