---
topic: JavaScript
section: Core Concepts & Interview Fundamentals
subtopic: Value vs. Reference Types
level: Beginner
---

## Value vs. Reference Types

### Core Concepts

- **Value Types (Primitives):**
  - Data types whose values are stored directly in the memory location associated with the variable.
  - When assigned or passed, a new, independent copy of the value is created.
  - **Immutable:** Their value cannot be changed after creation. Any operation that _seems_ to modify a primitive (e.g., string concatenation) actually returns a _new_ primitive.
  - **Examples:** `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
- **Reference Types (Objects):**
  - Data types whose values are stored in the heap, and the variable holds a _reference_ (memory address) to that location.
  - When assigned or passed, the _reference_ (not the actual object) is copied. Both variables then point to the _same_ object in memory.
  - **Mutable:** Properties of the object can be changed after creation, affecting all variables that hold a reference to it.
  - **Examples:** `Object` (plain objects `{}`), `Array` (`[]`), `Function`, `Date`, `RegExp`, `Map`, `Set`, `Class` instances.

### Key Details & Nuances

- **Memory Allocation:**
  - **Stack:** Primitives are typically stored on the call stack, enabling fast access and direct value comparisons.
  - **Heap:** Objects are stored on the heap, allowing for dynamic memory allocation and variable sizing. Variables hold pointers to these heap locations.
- **Assignment & Comparison (`==`, `===`):**

  - **Value Types:**
    ```typescript
    let a = 10;
    let b = a; // b gets a *copy* of 10
    a = 20; // Changes a, b remains 10
    console.log(a === b); // false
    ```
    Comparison checks the actual values.
  - **Reference Types:**

    ```typescript
    let obj1 = { value: 10 };
    let obj2 = obj1; // obj2 gets a *copy of the reference* to obj1
    obj1.value = 20; // Modifies the object obj1 *points to*
    console.log(obj2.value); // 20 (obj2 points to the same modified object)
    console.log(obj1 === obj2); // true (they point to the same memory location)

    let obj3 = { value: 20 }; // Different object, even if content is same
    console.log(obj1 === obj3); // false (different memory locations)
    ```

    Comparison checks if the references point to the _exact same object_ in memory.

- **Function Arguments (Pass by Value vs. Pass by Sharing):**
  - JavaScript is always "pass by value".
  - For primitives, a copy of the value is passed.
  - For objects, a copy of the _reference_ (the memory address) is passed. This is often termed "pass by sharing" or "pass by value of the reference."
    - Modifying a property of the object _inside_ the function affects the original object (because both the original variable and the function parameter hold references to the same object).
    - _Reassigning_ the object parameter _inside_ the function to a new object does _not_ affect the original variable outside the function (because the parameter's reference is merely updated to point to a new object, not the original variable's reference).

### Practical Examples

- **Reference Type Assignment & Function Argument Behavior**

  ```typescript
  function modifyAndReassign(objParam: { data: number }) {
    console.log('Inside function - Before modification:', objParam); // { data: 10 }
    objParam.data = 20; // Modifies the original object
    console.log('Inside function - After modification:', objParam); // { data: 20 }

    // Reassigning the parameter to a NEW object
    objParam = { data: 30 }; // objParam now points to a new object
    console.log('Inside function - After reassigning parameter:', objParam); // { data: 30 }
  }

  let myObject = { data: 10 };
  console.log('Outside function - Before call:', myObject); // { data: 10 }

  modifyAndReassign(myObject);

  // myObject's 'data' property was changed, but myObject itself was not reassigned
  console.log('Outside function - After call:', myObject); // { data: 20 }
  ```

- **Visualizing Reference Copy on Assignment**

  ```mermaid
  graph TD;
      V1["myObject (Variable)"] --> M1["Object Data (Heap)"];
      M1 --> P1["data: 10"];

      V2["objParam (Variable)"] --> M1;

      subgraph Function Call
          M1 --> P2["data: 20"];
      end

      V3["objParam (Reassigned)"] --> M2["New Object (Heap)"];
      M2 --> P3["data: 30"];
  ```

### Common Pitfalls & Trade-offs

- **Unintended Side Effects:** Modifying an object that was passed by reference can lead to unexpected behavior in other parts of the codebase that hold a reference to the same object. This is a common source of bugs in JavaScript.
- **Shallow vs. Deep Copy:**
  - **Shallow Copy:** Creates a new object, but copies only the _references_ to nested objects. Changes to nested objects in the copy will still affect the original. Achieved by `Object.assign()`, spread syntax (`...`), `Array.prototype.slice()`, `Array.from()`.
  - **Deep Copy:** Creates a completely independent copy of an object, including all nested objects and arrays. Changes to the copied object or its nested structures will not affect the original.
    - **Methods:** `JSON.parse(JSON.stringify(obj))` (simple, but limited: loses functions, `undefined`, `Map`, `Set`, `Date` objects become strings, etc.). For complex cases, `structuredClone()` (ES2021+) or utility libraries like Lodash's `_.cloneDeep()` are required.
- **Performance:** While passing references is efficient, performing deep copies of large, complex objects can be computationally expensive due to recursive traversal and new memory allocation.

### Interview Questions

1.  **Explain the core difference between value types and reference types in JavaScript, providing an example for each.**
    - **Answer:** Value types (primitives like `number`, `string`, `boolean`, etc.) store their actual value directly. When assigned, a new, independent copy of the value is made. Reference types (objects like `{}` or `[]`) store a reference (memory address) to their data on the heap. When assigned, only the reference is copied, meaning multiple variables can point to the _same_ underlying object.
2.  **How does JavaScript handle function arguments with respect to value and reference types? Is JavaScript "pass by reference" for objects?**
    - **Answer:** JavaScript is always "pass by value." For primitives, a copy of the primitive's value is passed. For objects, a copy of the _reference_ (the memory address) to the object is passed. This is often called "pass by sharing." It means that while you can modify properties of the original object inside the function (because you have a reference to it), _reassigning_ the parameter variable itself inside the function will _not_ affect the original variable's reference outside the function.
3.  **Consider `let obj1 = { a: 1 }; let obj2 = obj1; obj2.a = 2;`. What will be the value of `obj1.a` after these operations? Explain why.**
    - **Answer:** `obj1.a` will be `2`. When `obj2 = obj1` is executed, `obj2` receives a copy of the _reference_ that `obj1` holds. Both `obj1` and `obj2` then point to the _same_ object in memory. Therefore, when `obj2.a = 2` modifies the `a` property, it's modifying the `a` property of the _shared object_ that both variables reference.
4.  **When is a "deep copy" necessary, and what are some common ways to achieve it in JavaScript?**
    - **Answer:** A deep copy is necessary when you need a completely independent duplicate of an object, including all nested objects and arrays, such that changes to the copy do not affect the original. Common ways include:
      1.  `JSON.parse(JSON.stringify(obj))`: Simple, but has limitations (loses functions, `undefined`, `Date` objects become strings, circular references fail).
      2.  `structuredClone(obj)`: A newer, built-in method (ES2021+) that handles more types and circular references.
      3.  Writing a custom recursive cloning function.
      4.  Using utility libraries like Lodash's `_.cloneDeep()`.
