---
topic: JavaScript
section: Performance, Architecture, and the Browser
subtopic: Generators and Iterators
level: Advanced
---

## Generators and Iterators
### Core Concepts

*   **Iterables:** An object that can be iterated over (e.g., with `for...of`). It must implement the `[Symbol.iterator]` method, which returns an `Iterator`.
    *   Examples: `Array`, `String`, `Map`, `Set`, `NodeList`.
*   **Iterators:** An object that conforms to the Iterator Protocol, providing a `next()` method.
    *   The `next()` method returns an object with two properties:
        *   `value`: The next item in the sequence.
        *   `done`: A boolean indicating if the iteration is complete (`true`) or not (`false`).
*   **Generators:** Special functions defined with `function*` that return an `Iterator` object. They allow functions to be paused and resumed, producing a sequence of values on demand using the `yield` keyword.
    *   Generators are a powerful way to implement custom iterators.

### Key Details & Nuances

*   **Lazy Evaluation / On-demand Generation:** Generators produce values one at a time, only when requested (via `next()`). This is crucial for:
    *   **Memory Efficiency:** Generating large or infinite sequences without needing to compute and store all values upfront.
    *   **Performance:** Delaying computation until necessary.
*   **State Management:** Generators maintain their own internal state (e.g., variable values, current execution point) between `yield` pauses, simplifying stateful iteration logic.
*   **`yield` vs. `return`:**
    *   `yield expression`: Pauses the generator, emits `expression` as the `value` in the `next()` result, and waits for the next `next()` call to resume. The `done` property will be `false`.
    *   `return expression`: Terminates the generator. `expression` becomes the `value` in the final `next()` result, and `done` becomes `true`. Subsequent `next()` calls will always return `{ value: undefined, done: true }`.
*   **`yield*` (Yield Delegation):** Allows a generator to delegate to another iterable or generator. It iterates over the delegated iterable/generator and `yield`s each of its values.
*   **Controlling Generators Externally:**
    *   `generator.next(value)`: The optional `value` passed to `next()` becomes the result of the `yield` expression that paused the generator.
    *   `generator.throw(error)`: Injects an error into the generator, which can be caught inside the generator with `try...catch`.
    *   `generator.return(value)`: Forces the generator to complete immediately, returning `value` as the final result.
*   **Asynchronous Generators (`async function*`):** Used with `await yield` and consumed with `for await...of`, enabling lazy iteration over asynchronous data streams.

### Practical Examples

**1. Basic Generator and Iterator Protocol**

```typescript
// Generator function definition
function* idGenerator(): Generator<number, string, number> {
    let id = 1;
    while (true) {
        const resetId = yield id++; // 'resetId' receives value from next() call
        if (resetId) {
            id = resetId;
        }
    }
}

// Get the iterator object from the generator function
const generator = idGenerator();

console.log(generator.next());      // { value: 1, done: false }
console.log(generator.next());      // { value: 2, done: false }
console.log(generator.next(100));   // { value: 100, done: false } (resets id to 100)
console.log(generator.next());      // { value: 101, done: false }

// Generators are also Iterables, so they can be used with for...of
// Note: This specific generator runs indefinitely, so 'for...of' needs a break condition
function* limitGenerator(limit: number): Generator<number> {
    for (let i = 0; i < limit; i++) {
        yield i;
    }
}

for (const num of limitGenerator(3)) {
    console.log(num); // 0, 1, 2
}
```

**2. Generator Execution Flow**

```mermaid
graph TD;
    A["Generator Function Called (e.g., idGenerator())"] --> B["Returns Iterator Object"];
    B --> C["Iterator.next() Called"];
    C --> D{"yield' Encountered?"};
    D -- Yes --> E["Emit Value, Pause Execution"];
    E --> F["Wait for Next Iterator.next() Call"];
    F --> C; // Loop back to next call
    D -- No --> G["Function Completes / 'return' Statement"];
    G --> H["Emit Final Value (if any), Mark as Done"];
    H --> I["Subsequent Iterator.next() Calls"];
    I --> J["Return { value: undefined, done: true }"];
```

### Common Pitfalls & Trade-offs

*   **Statefulness & Reusability:** Once a generator's iterator is `done` (i.e., it has completed its execution or encountered a `return` statement), it cannot be reset or reused. A new iterator must be created by calling the generator function again. This can be a gotcha if you expect to iterate multiple times over the same generator instance.
*   **Debugging Complexity:** The non-linear execution flow (pausing and resuming) can make debugging generators more challenging than traditional functions, especially with complex `yield` logic or external control (`next(value)`, `throw()`).
*   **Readability for Simple Cases:** For very simple iteration needs, a traditional loop or array method (`map`, `filter`, `forEach`) might be more straightforward and readable than a generator, potentially leading to over-engineering.
*   **Performance Trade-offs:** While excellent for memory efficiency with large datasets, the overhead of context switching between `yield` calls can sometimes be marginally slower for very small, frequently iterated sequences compared to highly optimized built-in array methods or simple loops. The benefit usually outweighs this for complex or large-scale data processing.

### Interview Questions

1.  **Explain the core difference between an `Iterable` and an `Iterator` in JavaScript. How do generators relate to these concepts?**
    *   **Answer:** An `Iterable` is any object that defines a `[Symbol.iterator]` method, which returns an `Iterator`. An `Iterator` is an object that provides a `next()` method, returning `{ value, done }}` pairs for sequential access. Generators are special functions (`function*`) that *return* an `Iterator` object, making them a convenient way to create custom iterators and thus make objects `Iterable`.

2.  **When would you choose to use a generator function over a traditional function returning an array? Provide a concrete use case.**
    *   **Answer:** You'd choose a generator when dealing with large or potentially infinite sequences, or when you need lazy evaluation. A concrete use case is **processing large log files line by line without loading the entire file into memory**. A generator could `yield` each line as it's read, preventing memory overflow for multi-gigabyte files. Another is **generating an infinite sequence**, like Fibonacci numbers, where computing all values upfront is impossible.

3.  **How does `yield` differ from `return` inside a generator function? What is the purpose of `yield*`?**
    *   **Answer:** `yield` pauses the generator's execution and emits a value, keeping the generator's state active so it can be resumed later. The generator is not finished (`done: false`). `return` terminates the generator's execution, optionally emits a final value, and marks the generator as finished (`done: true`). Subsequent `next()` calls will yield `{ value: undefined, done: true }`. `yield*` is a delegation syntax used to iterate over another iterable (or generator) from within the current generator, effectively "flattening" nested iterations.

4.  **Describe how generators can be used for infinite sequences or asynchronous operations. Can you briefly explain `async function*`?**
    *   **Answer:** For **infinite sequences**, generators use `yield` within an indefinite loop (e.g., `while(true)`). Since values are produced only on demand, the infinite sequence doesn't exhaust memory. For **asynchronous operations**, `async function*` (asynchronous generators) combine `async/await` with generators. They `await` promises before `yield`ing results, making them ideal for lazy iteration over asynchronous data streams (e.g., fetching paginated API results one page at a time) and consumed using `for await...of`.