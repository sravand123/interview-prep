---
topic: System Design
section: Performance Antipatterns
subtopic: Improper Instantiation
level: Advanced
---

## Improper Instantiation
### Core Concepts

*   **Improper Instantiation:** Creating objects or instances of classes/services too frequently, inefficiently, or at the wrong scope, leading to performance degradation, increased resource consumption (CPU, memory), and potential latency.
*   **Impact:** Can manifest as slow response times, high server load, increased garbage collection overhead, and general system unresponsiveness.

### Key Details & Nuances

*   **Lifecycle Management:** Understanding the intended lifecycle of an object is critical.
    *   **Short-lived vs. Long-lived:** Some objects are designed for single use, while others are meant to be reused throughout an application's lifetime or a specific request's lifetime.
    *   **Singleton Pattern:** Suitable for resources that should have a single global instance (e.g., a configuration manager, a connection pool manager). Instantiating multiple singletons is an anti-pattern.
    *   **Factory Patterns:** Used to abstract object creation, allowing for flexibility and deferred instantiation. Improper use can still lead to over-instantiation.
*   **Scope of Instantiation:**
    *   **Global Scope:** Creating objects that are accessible everywhere can lead to unintended dependencies and difficulty in managing their lifecycle.
    *   **Request Scope:** Objects tightly coupled to a single request should be instantiated within that request's context and discarded afterward.
    *   **Thread Scope:** In multi-threaded environments, objects tied to a specific thread's execution can prevent resource contention if managed correctly.
*   **Resource-Intensive Objects:** Objects that require significant initialization time, memory allocation, or network connections are prime candidates for improper instantiation issues. Examples include database connections, large data structures, or complex service clients.
*   **Dependency Injection (DI):** A powerful pattern to manage object dependencies and lifecycles. DI containers can often handle instantiation and scope management, but misconfiguration can still lead to improper instantiation.

### Practical Examples

Consider a hypothetical web service that needs to fetch data from a remote API.

**Anti-pattern: Instantiating client on every request**

```typescript
class DataFetcherService {
    async fetchData(resourceId: string): Promise<any> {
        // Inefficient: Creates a new HTTP client for every single request
        const httpClient = new HttpClient("https://api.example.com");
        const response = await httpClient.get(`/data/${resourceId}`);
        return response.data;
    }
}
```

**Improved: Reusing a shared client instance**

```typescript
// Shared instance, ideally managed by a DI container or initialized once
const sharedHttpClient = new HttpClient("https://api.example.com");

class DataFetcherService {
    async fetchData(resourceId: string): Promise<any> {
        // Efficient: Reuses the already initialized client
        const response = await sharedHttpClient.get(`/data/${resourceId}`);
        return response.data;
    }
}
```

### Common Pitfalls & Trade-offs

*   **Premature Optimization:** While instantiating objects is an overhead, over-optimizing by making everything a singleton can lead to tightly coupled, hard-to-test code and state management issues.
*   **Garbage Collection (GC) Pressure:** Frequent creation and destruction of many small objects can increase GC overhead, causing pauses and impacting performance. Conversely, keeping long-lived objects unnecessarily can lead to memory leaks.
*   **Connection Pooling:** For resources like database connections or network sockets, creating a new connection for each request is extremely inefficient. Connection pooling manages a set of pre-established connections that can be reused. Improper instantiation would mean bypassing or mismanaging a connection pool.
*   **Thread Safety:** When sharing instances (e.g., singletons or pooled resources) across threads, ensure they are thread-safe to avoid race conditions and data corruption.

### Interview Questions

1.  **Question:** How would you identify and address improper instantiation of objects in a high-traffic web application?
    **Answer:** I'd start by profiling the application using performance monitoring tools to identify hotspots related to object creation and garbage collection. I'd look for frequently instantiated classes, especially those that are resource-intensive or have long initialization times. Then, I'd analyze the lifecycle and scope of these objects. Solutions would involve implementing patterns like Singleton for truly global resources, reusing instances within request scopes, or utilizing dependency injection frameworks to manage object lifecycles and scopes effectively. For resources like database connections, I'd ensure connection pooling is in place and correctly configured.

2.  **Question:** When is using a Singleton pattern appropriate, and what are its potential downsides regarding instantiation?
    **Answer:** Singletons are appropriate for managing global state or providing a single point of access to a resource that must be unique, such as a configuration manager, logger, or a cache. Their downside is that they introduce global state, making code harder to test and increasing coupling. Overuse can lead to a "god object" antipattern. If not carefully managed, multiple instances could theoretically be created in complex or distributed systems, or if the singleton's initialization is not properly synchronized, leading to unexpected behavior.

3.  **Question:** Explain the performance implications of creating many short-lived objects versus fewer long-lived objects.
    **Answer:** Creating many short-lived objects can increase garbage collection overhead, leading to CPU spikes and potential application pauses. The system spends more time allocating memory and then deallocating it. Conversely, having fewer long-lived objects can lead to higher memory consumption and potential memory leaks if references are not cleared properly. It can also increase the complexity of managing state if these objects are shared across different parts of the application. The optimal approach often involves a balance, carefully managing object lifecycles and reusing them where appropriate without holding onto them longer than necessary.