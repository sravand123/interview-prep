---
topic: System Design
section: High Availability & Deployment
subtopic: Health Endpoint Monitoring
level: Expert
---

## Health Endpoint Monitoring
### Core Concepts

*   **Health Endpoint Monitoring (HEM):** A mechanism to expose the operational status of a service or application.
*   **Purpose:**
    *   Allow load balancers, orchestrators (e.g., Kubernetes), and monitoring systems to determine if an instance is healthy and should receive traffic.
    *   Facilitate automated restarts or replacements of unhealthy instances.
    *   Provide insights into the internal state of the application.

### Key Details & Nuances

*   **Endpoint:** Typically an HTTP GET request to a specific path (e.g., `/health`, `/status`, `/ping`).
*   **Response Codes:**
    *   `2xx` (e.g., `200 OK`): Service is healthy.
    *   `5xx` (e.g., `503 Service Unavailable`): Service is unhealthy or degraded.
*   **Response Body:**
    *   Can be plain text, JSON, or XML.
    *   **Essential Data:**
        *   **Status:** `"UP"`, `"DOWN"`, `"DEGRADED"`, `"OUT_OF_SERVICE"`.
        *   **Details:** Specific internal component statuses (e.g., database connection, cache status, external API health).
        *   **Timestamp:** When the check was performed.
        *   **Uptime:** How long the service has been running.
*   **Granularity of Checks:**
    *   **Liveness Probe:** Basic check (e.g., is the process running?). If fails, the container/instance is restarted.
    *   **Readiness Probe:** Checks if the service is ready to serve traffic (e.g., all dependencies are available, initialization complete). If fails, the instance is removed from the load balancer.
    *   **Deep Health Check:** Comprehensive check of all critical dependencies and functionalities.
*   **Execution Frequency:** Configurable by the orchestrator or monitoring system. Frequent checks are good but can add load.
*   **External vs. Internal Health:**
    *   **External:** Does the service respond to basic requests? (e.g., HTTP 200 OK).
    *   **Internal:** Are all dependencies (DB, cache, external services) reachable and functioning correctly?
*   **Idempotency:** Health check requests should be idempotent.

### Practical Examples

*   **Simple Health Check (Node.js):**

    ```typescript
    import express from 'express';

    const app = express();
    const port = 3000;

    // Simulate database connection status
    let dbConnected = true;

    app.get('/health', (req, res) => {
        if (dbConnected) {
            res.status(200).json({
                status: 'UP',
                timestamp: new Date().toISOString(),
                dependencies: {
                    database: 'CONNECTED'
                }
            });
        } else {
            res.status(503).json({
                status: 'DOWN',
                timestamp: new Date().toISOString(),
                dependencies: {
                    database: 'DISCONNECTED'
                }
            });
        }
    });

    app.listen(port, () => {
        console.log(`Service listening on port ${port}`);
    });

    // Simulate DB connection failure
    setTimeout(() => {
        dbConnected = false;
        console.log('Simulating database disconnection...');
    }, 30000);
    ```

*   **Kubernetes Readiness/Liveness Probes (Conceptual):**

    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: my-app
    spec:
      containers:
      - name: my-app-container
        image: my-app-image
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /health # Basic check to restart if process hangs
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 20
        readinessProbe:
          httpGet:
            path: /health # Deeper check to see if ready to serve traffic
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
    ```

### Common Pitfalls & Trade-offs

*   **Overly Complex Health Checks:**
    *   **Pitfall:** Health checks that are too slow or too complex can become a bottleneck themselves or cause false negatives.
    *   **Trade-off:** Simple checks are fast but might miss critical internal failures. Deep checks are comprehensive but slower.
*   **Ignoring Dependencies:**
    *   **Pitfall:** A health check only verifying the process is running, not its critical dependencies (DB, cache, message queue).
    *   **Trade-off:** False positives of "UP" when the service is functionally broken.
*   **Not Differentiating Liveness/Readiness:**
    *   **Pitfall:** Using the same health check for both liveness and readiness.
    *   **Trade-off:** An instance might be restarted unnecessarily (liveness) or traffic might be sent to an instance that isn't fully initialized or is experiencing temporary issues (readiness).
*   **Lack of Specificity in Response:**
    *   **Pitfall:** Returning a generic "healthy" or "unhealthy" without context.
    *   **Trade-off:** Difficult for operators or automated systems to diagnose the root cause.
*   **Security:**
    *   **Pitfall:** Exposing sensitive internal state through health endpoints without proper authorization or network segmentation.
    *   **Trade-off:** Information leakage. Health endpoints should ideally be accessible only by trusted infrastructure.

### Interview Questions

1.  **"Describe the difference between liveness and readiness probes in a containerized environment."**
    *   **Answer:** Liveness probes determine if a container is running and should be restarted if it fails (e.g., application crash, deadlocks). Readiness probes determine if a container is ready to serve traffic; if it fails, the container is removed from service endpoints until it becomes ready again (e.g., initial data loading, dependency availability).
2.  **"What information should be included in a comprehensive health check response, and why?"**
    *   **Answer:** A comprehensive response should include a clear status (`UP`, `DOWN`, `DEGRADED`), a timestamp, and detailed status of critical dependencies (database, cache, external APIs). This provides actionable diagnostics for operators and automated systems to quickly identify the source of a problem.
3.  **"What are the trade-offs involved in making your health check very lightweight versus very comprehensive?"**
    *   **Answer:** A lightweight check is fast and has minimal impact but might miss subtle internal failures. A comprehensive check provides better diagnostic detail but can be slower, potentially impacting performance or leading to false positives if dependencies are temporarily unavailable. The goal is to strike a balance that reflects the application's critical paths.
4.  **"How would you design a health endpoint for a distributed system with multiple microservices?"**
    *   **Answer:** Each microservice should have its own health endpoint. A central system or API gateway can aggregate these. For critical user-facing health, an aggregate endpoint might check the health of all essential downstream services, potentially reporting a `DEGRADED` status if some non-critical dependencies are down but the core functionality is still available.