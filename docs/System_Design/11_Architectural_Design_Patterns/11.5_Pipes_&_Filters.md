---
topic: System Design
section: Architectural Design Patterns
subtopic: Pipes & Filters
level: Advanced
---

## Pipes & Filters
### Core Concepts

*   **Definition:** A software design pattern that structures a system as a sequence of processing steps (filters) connected by pipes. Each filter performs a specific, atomic task, and the output of one filter becomes the input of the next.
*   **Pipeline:** The chain of filters connected by pipes. Data flows sequentially through the pipeline.
*   **Separation of Concerns:** Each filter is responsible for a single task, promoting modularity and reusability.

### Key Details & Nuances

*   **Filter:**
    *   Receives data from an input pipe.
    *   Processes the data.
    *   Sends processed data to an output pipe.
    *   Can transform, validate, enrich, or filter data.
    *   Should be stateless if possible to simplify concurrency and testing.
*   **Pipe:**
    *   Connects the output of one filter to the input of another.
    *   Handles data transfer between filters.
    *   Can buffer data, manage flow control, and handle different data formats.
*   **Orchestration:** The overall management of the pipeline, including filter instantiation, connection, execution, and error handling.
*   **Composability:** Filters can be easily combined in different sequences to create new pipelines.
*   **Extensibility:** New filters can be added to existing pipelines or used to build entirely new ones without modifying existing filters.
*   **Concurrency:** Can be achieved by running filters in separate threads or processes, especially for long-running or I/O-bound operations.

### Practical Examples

A common use case is data processing pipelines, such as text processing or ETL (Extract, Transform, Load).

```typescript
// --- Define a Filter ---
interface Filter<I, O> {
  process(input: I): O;
}

// --- Example Filters ---
class UppercaseFilter implements Filter<string, string> {
  process(input: string): string {
    return input.toUpperCase();
  }
}

class AddExclamationFilter implements Filter<string, string> {
  process(input: string): string {
    return `${input}!`;
  }
}

class TrimFilter implements Filter<string, string> {
  process(input: string): string {
    return input.trim();
  }
}

// --- The Pipeline ---
class Pipeline<I, O> {
  private filters: Filter<any, any>[] = [];

  addFilter<NextI, NextO>(filter: Filter<NextI, NextO>): Pipeline<NextI, NextO> {
    this.filters.push(filter as Filter<any, any>);
    return this as any; // Type assertion for chaining
  }

  execute(initialInput: I): O {
    let currentOutput: any = initialInput;
    for (const filter of this.filters) {
      currentOutput = filter.process(currentOutput);
    }
    return currentOutput as O;
  }
}

// --- Usage ---
const pipeline = new Pipeline<string, string>()
  .addFilter(new TrimFilter())
  .addFilter(new UppercaseFilter())
  .addFilter(new AddExclamationFilter());

const result = pipeline.execute("  hello world  ");
console.log(result); // Output: HELLO WORLD!
```

### Common Pitfalls & Trade-offs

*   **Performance Bottlenecks:** A slow filter in the middle of the pipeline can impact the entire system's throughput.
*   **Complexity:** Very long or complex pipelines can become difficult to understand, debug, and maintain.
*   **Error Handling:** Propagating errors and handling them gracefully across multiple filters requires careful design. Consider a separate error handling filter or a mechanism for filters to signal errors.
*   **State Management:** While stateless filters are ideal, stateful filters introduce complexity, especially in concurrent or distributed systems.
*   **Data Serialization/Deserialization:** If filters operate across process boundaries, inefficient serialization/deserialization can be a performance hit.

### Interview Questions

1.  **How would you design a system to process user uploads, including validation, resizing, and storage, using a pipes and filters approach?**
    *   **Answer:** Each step would be a filter: `FileValidatorFilter` (checks format/size), `ImageResizerFilter` (resizes if it's an image), `StorageFilter` (uploads to S3/GCS), `NotificationFilter` (sends user confirmation). Pipes would pass the file data or its reference between these. This modularity allows adding/replacing steps easily (e.g., add watermarking or thumbnail generation).

2.  **What are the challenges of implementing error handling in a complex pipes and filters system?**
    *   **Answer:** Errors can occur in any filter. The system needs a strategy:
        *   **Fail-fast:** Terminate the pipeline on the first error.
        *   **Partial success:** Log errors and continue processing subsequent items if the pipeline handles batches.
        *   **Error filter:** A dedicated filter to catch and report errors, potentially rerouting problematic data.
        *   **Retry mechanisms:** Some filters might benefit from retries (e.g., network requests for storage).

3.  **When would you *not* use the pipes and filters pattern for a system design?**
    *   **Answer:** For systems requiring highly interactive, non-sequential processing, or complex state management where data doesn't flow linearly. Examples include real-time collaborative editing (like Google Docs) or systems with many interdependent, non-linear operations. Also, for very simple, single-step operations, the overhead of the pattern might be unnecessary.