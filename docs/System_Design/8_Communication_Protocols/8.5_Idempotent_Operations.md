---
topic: System Design
section: Communication Protocols
subtopic: Idempotent Operations
level: Intermediate
---

## Idempotent Operations
### Core Concepts

*   **Idempotence:** An operation is idempotent if applying it multiple times has the same effect as applying it once. The state of the system remains unchanged after the first successful execution.
*   **Why it matters:** Crucial for building reliable distributed systems, especially in the face of network failures and retries. It ensures that clients can safely re-send requests without causing unintended side effects.

### Key Details & Nuances

*   **HTTP Methods and Idempotence:**
    *   **Idempotent:** `GET`, `PUT`, `DELETE`, `OPTIONS`, `HEAD`, `TRACE`.
        *   `GET`: Retrieving data. Multiple requests yield the same data.
        *   `PUT`: Updating a resource to a specific state. Multiple `PUT`s to the same URL with the same body result in the same final state.
        *   `DELETE`: Deleting a resource. Multiple `DELETE`s result in the resource being deleted once; subsequent requests might return a 404 but don't change the state further.
    *   **Non-idempotent:** `POST`, `PATCH` (can be made idempotent with careful implementation).
        *   `POST`: Typically used for creating new resources or performing actions that change state in a non-deterministic way (e.g., submitting an order, triggering an event). Multiple `POST`s usually create multiple resources or trigger the action multiple times.
        *   `PATCH`: Applies a partial modification to a resource. If the modification is additive (e.g., "increment count by 1"), `PATCH` is not idempotent. If it's a conditional update or replaces a specific field, it *can* be idempotent.
*   **Achieving Idempotence with `POST`:**
    *   **Unique Request Identifiers:** Clients can generate a unique ID for each request.
    *   **Server-Side Tracking:** The server stores these IDs and checks if a request with that ID has already been processed.
    *   **Conditional Execution:** If the ID is recognized, the server returns the previous result instead of re-executing.

### Practical Examples

*   **Idempotent `PUT` Request:**
    *   **Scenario:** Updating a user's email address.
    *   **Request:** `PUT /users/123` with body `{"email": "new.email@example.com"}`.
    *   **Effect:** If the user `123` exists, their email is set to `new.email@example.com`. If the request is sent again with the same payload, the email remains `new.email@example.com`. The final state is the same.

*   **Non-Idempotent `POST` Request:**
    *   **Scenario:** Creating a new order.
    *   **Request:** `POST /orders` with body `{"userId": "456", "items": ["item1"]}`.
    *   **Effect:** Creates a new order. If sent again, another new order is created.

*   **Idempotent `POST` with Request ID:**
    *   **Scenario:** Triggering a payment processing job that should only run once per unique payment attempt.
    *   **Request:** `POST /payments` with body `{"userId": "789", "amount": 100, "attemptId": "uuid-for-this-attempt"}`.
    *   **Server Logic:**
        1.  Extract `attemptId`.
        2.  Check if `attemptId` exists in a cache/database of processed attempts.
        3.  If it exists, return the status of the previous attempt.
        4.  If it doesn't exist, mark `attemptId` as processed, execute the payment logic, and return the new status.

```typescript
// Server-side pseudo-code for idempotent POST
async function processPayment(requestBody: { userId: string; amount: number; attemptId: string }) {
    const { userId, amount, attemptId } = requestBody;

    const processedAttempt = await getProcessedAttempt(attemptId);

    if (processedAttempt) {
        return { status: processedAttempt.status, message: "Already processed." };
    }

    // Mark as processed *before* execution to handle failures mid-process
    await markAttemptAsProcessed(attemptId, "processing");

    try {
        // Actual payment processing logic
        const result = await executePayment(userId, amount);
        await updateAttemptStatus(attemptId, result.status);
        return { status: result.status };
    } catch (error) {
        await updateAttemptStatus(attemptId, "failed");
        throw error; // Re-throw for client handling
    }
}
```

### Common Pitfalls & Trade-offs

*   **Overhead of Idempotent `POST`:** Storing and checking request IDs adds latency and storage requirements.
*   **Race Conditions:** Ensuring the "check and set" for request IDs is atomic is crucial. If two requests with the same ID arrive nearly simultaneously, both might proceed if not handled carefully (e.g., using database transactions or atomic operations).
*   **State Management:** Idempotence is about the *effect* of the operation. If an operation has side effects beyond the target resource (e.g., sending emails), making it idempotent usually means those side effects are also only triggered once.
*   **Client Responsibility:** Clients need a reliable way to generate unique request IDs and manage them across retries.

### Interview Questions

1.  **What is idempotence and why is it important in distributed systems?**
    *   **Answer:** Idempotence means an operation can be applied multiple times without changing the result beyond the initial application. It's vital for reliability, allowing clients to safely retry requests that might have failed due to network issues or server errors, preventing duplicate operations or inconsistent states.

2.  **Which HTTP methods are inherently idempotent, and which are not? Explain why for each.**
    *   **Answer:** `GET`, `PUT`, `DELETE`, `OPTIONS`, `HEAD`, `TRACE` are idempotent. `GET` retrieves data, `PUT` sets a resource to a specific state, and `DELETE` removes it â€“ repeating these actions doesn't change the outcome. `POST` is generally not idempotent as it typically creates new resources or triggers actions that can occur multiple times (e.g., submitting an order). `PATCH`'s idempotence depends on the nature of the partial update.

3.  **How would you make a `POST` request idempotent?**
    *   **Answer:** Implement a mechanism on the server to track unique request identifiers (e.g., UUIDs) sent by the client. Before processing a `POST` request, the server checks if it has already processed a request with that identifier. If it has, it returns the previous result; otherwise, it processes the request and records the identifier. This check-and-execute sequence must be atomic.

4.  **Consider a scenario where a client sends a `PUT` request to update a user's profile, but the server returns a network error before sending a response. What should the client do, and why?**
    *   **Answer:** The client should safely retry the `PUT` request. Since `PUT` is idempotent, sending the same request multiple times will not have unintended side effects on the server's state. The server will either process it for the first time or, if it was already processed, return the same result as the initial attempt. This ensures the user's profile is updated correctly despite the transient network failure.