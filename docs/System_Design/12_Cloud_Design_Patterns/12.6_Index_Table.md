---
topic: System Design
section: Cloud Design Patterns
subtopic: Index Table
level: Advanced
---

## Index Table
### Core Concepts

*   **Index Table:** A data structure that stores a subset of a larger dataset, typically used to speed up data retrieval operations. It maps specific query keys to the location(s) of the corresponding records in the primary data store.
*   **Purpose:** To reduce the need to scan entire datasets, significantly improving query performance.
*   **Analogy:** Similar to an index in a book, allowing quick lookups of specific topics without reading the entire book.

### Key Details & Nuances

*   **Content:** Contains a subset of columns from the primary table, usually including columns used for filtering, sorting, or joining.
*   **Key:** The column(s) used for lookup (e.g., `user_id`, `product_name`).
*   **Pointer/Reference:** Stores a reference (e.g., row ID, primary key, or physical location) to the actual data in the main table.
*   **Data Locality:** Index tables can be co-located with data for faster access, or stored separately.
*   **Read vs. Write Trade-off:**
    *   **Reads:** Significantly faster for queries that can leverage the index.
    *   **Writes:** Slower because the index table must also be updated alongside the primary data, incurring additional overhead.
*   **Storage Overhead:** Index tables consume additional storage space.
*   **Maintenance:** Indexes require maintenance, such as rebuilding or rebalancing, especially in distributed systems.
*   **Types of Indexes:**
    *   **B-Trees (most common):** Balanced tree structures providing efficient range queries and equality lookups.
    *   **Hash Indexes:** Excellent for equality lookups but poor for range queries.
    *   **Full-Text Indexes:** For searching within text documents.
    *   **Bitmap Indexes:** Efficient for columns with low cardinality (few distinct values).

### Practical Examples

A common use case is in databases for speeding up `SELECT` queries.

Consider a `Users` table:

`Users` Table:
| user_id (PK) | username | email | registration_date |
|--------------|----------|-------|-------------------|
| 1            | alice    | a@e.com | 2023-01-15        |
| 2            | bob      | b@e.com | 2023-02-20        |
| 3            | charlie  | c@e.com | 2023-01-15        |

To speed up queries filtering by `registration_date`, we create an index on that column:

`registration_date` Index Table (conceptual):
*   Key: `registration_date`
*   Value: List of `user_id`s with that date

| registration_date | user_ids                      |
|-------------------|-------------------------------|
| 2023-01-15        | [1, 3]                        |
| 2023-02-20        | [2]                           |

Query: `SELECT * FROM Users WHERE registration_date = '2023-01-15';`

1.  Database looks up `'2023-01-15'` in the `registration_date` index.
2.  Finds the associated `user_ids`: `[1, 3]`.
3.  Retrieves rows with `user_id` 1 and 3 from the `Users` table directly, avoiding a full table scan.

### Common Pitfalls & Trade-offs

*   **Over-Indexing:** Creating too many indexes can drastically slow down write operations (inserts, updates, deletes) and consume excessive storage. It can also confuse the query optimizer.
*   **Index Selectivity:** Indexes are most effective on columns with high selectivity (many distinct values). They are less effective on columns with low selectivity (e.g., boolean flags, gender).
*   **Stale Indexes:** In highly dynamic datasets or systems with frequent data churn, indexes might become less efficient if not maintained.
*   **Composite Indexes:** The order of columns in a composite index matters significantly for query performance. The query's `WHERE` clause needs to align with the index definition.
*   **Index Saturation:** For very large datasets, an index might still require significant traversal. Distributed indexing strategies (like those in NoSQL or distributed SQL) are needed.

### Interview Questions

*   **Q: When would you *not* use an index table, even if a column is frequently queried?**
    *   **A:** If the table is very small and scanned quickly anyway. If the column has very low cardinality (e.g., gender: M/F). If write performance is paramount and reads are infrequent. If the overhead of index maintenance outweighs read benefits.
*   **Q: Explain the trade-off between indexing for read speed and its impact on write operations.**
    *   **A:** Indexes accelerate read operations by providing a shortcut to data. However, for every write operation (insert, update, delete), the database must not only modify the main data but also update all relevant indexes. This synchronization increases the latency and resource cost of writes.
*   **Q: How does the order of columns in a composite index affect query performance?**
    *   **A:** The order matters because indexes are typically traversed from left to right. An index on `(col_A, col_B)` is highly effective for queries filtering on `col_A` or `col_A AND col_B`. It is less effective, or entirely ineffective, for queries filtering only on `col_B`. A query planner can often use the index for `col_A` and then filter `col_B` in memory, but this is less efficient than a direct index lookup.
*   **Q: Describe a scenario where a hash index might be preferred over a B-tree index.**
    *   **A:** Hash indexes are highly efficient for exact equality lookups (e.g., `WHERE user_id = 123`). They offer O(1) average time complexity for these specific operations. However, they do not support range queries (e.g., `WHERE age BETWEEN 20 AND 30`) or sorting efficiently. A B-tree is generally preferred for its versatility, supporting both equality and range queries. A hash index would be chosen if the primary access pattern is solely point lookups on a specific key and range queries are not a concern.