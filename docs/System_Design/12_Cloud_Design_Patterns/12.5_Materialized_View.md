---
topic: System Design
section: Cloud Design Patterns
subtopic: Materialized View
level: Advanced
---

## Materialized View
### Core Concepts

*   **Definition:** A materialized view is a database object that stores the results of a query. Unlike a regular view (which is a stored query executed on demand), a materialized view stores the actual data, effectively acting as a pre-computed cache.
*   **Purpose:** To improve query performance by reducing the need to recompute complex or frequently accessed data from base tables.

### Key Details & Nuances

*   **Refresh Mechanisms:** Materialized views are not automatically updated when the underlying base tables change. They require explicit refresh mechanisms:
    *   **Complete Refresh:** Recomputes the entire view from scratch. Simple but can be slow for large datasets.
    *   **Incremental Refresh (Fast Refresh):** Updates the view based only on the changes in the base tables since the last refresh. Requires specific configurations (e.g., materialized view logs) and is more complex but much faster.
*   **When to Use:**
    *   **Complex Aggregations:** Queries involving `GROUP BY`, `SUM`, `COUNT`, `AVG` over large datasets.
    *   **Joins:** Queries joining multiple large tables.
    *   **Frequently Accessed Data:** When a subset of data is read very often, and freshness requirements are not real-time.
    *   **Data Warehousing & Reporting:** Common in OLAP scenarios.
*   **Storage:** Materialized views consume disk space, similar to a table, because they store the data.
*   **Database Support:** Availability and specific features (like incremental refresh) vary across different database systems (e.g., PostgreSQL, Oracle, SQL Server).

### Practical Examples

Consider a scenario where we have `orders` and `customers` tables, and we frequently need to get the total order amount per customer.

**1. Creating a Materialized View (PostgreSQL Syntax):**

```sql
-- Create a materialized view for total order amount per customer
CREATE MATERIALIZED VIEW customer_order_totals AS
SELECT
    c.customer_id,
    c.customer_name,
    SUM(o.order_amount) AS total_amount
FROM
    customers c
JOIN
    orders o ON c.customer_id = o.customer_id
GROUP BY
    c.customer_id, c.customer_name;

-- To query the materialized view
SELECT * FROM customer_order_totals WHERE customer_id = 123;
```

**2. Refreshing the Materialized View:**

```sql
-- Refreshing the materialized view (complete refresh)
REFRESH MATERIALIZED VIEW customer_order_totals;
```

**3. Incremental Refresh (Conceptual - requires setup):**

To enable incremental refresh, you'd typically create materialized view logs on the base tables. The refresh process then uses these logs to apply deltas. This is database-specific and often requires careful configuration.

```sql
-- Example: Creating a log for incremental refresh (PostgreSQL)
CREATE MATERIALIZED VIEW log ON orders WITH (ROWدیای);
CREATE MATERIALIZED VIEW log ON customers WITH (ROWدیای);

-- Refreshing incrementally (if supported and configured)
-- REFRESH MATERIALIZED VIEW CONCURRENTLY customer_order_totals; -- (Syntax varies)
```

### Common Pitfalls & Trade-offs

*   **Staleness:** The primary trade-off. Data in the materialized view can be out-of-date between refreshes.
    *   **Mitigation:** Tune refresh frequency based on business requirements. Consider event-driven refreshes or background jobs.
*   **Storage Costs:** Materialized views consume disk space.
*   **Refresh Overhead:** Refreshes, especially complete refreshes on large datasets, can be resource-intensive and time-consuming. Incremental refreshes reduce this but add complexity to setup and maintenance.
*   **Write Performance Impact:** If using incremental refresh, maintaining logs on base tables can add a small overhead to write operations on those tables.
*   **Complexity:** Implementing and managing incremental refresh can be complex.

### Interview Questions

1.  **When would you choose a materialized view over a regular view, and what are the primary trade-offs?**
    *   **Answer:** Use a materialized view when query performance is critical for complex or frequently run queries, and the data can tolerate some staleness. The main trade-off is data staleness and the overhead of maintaining the pre-computed data (storage, refresh process) versus the performance gain. Regular views offer real-time data but execute the underlying query every time, which can be slow.

2.  **Describe the different ways a materialized view can be refreshed. What are the pros and cons of each?**
    *   **Answer:**
        *   **Complete Refresh:** Recomputes the entire view. Pro: Simpler to implement. Con: Can be slow and resource-intensive for large datasets.
        *   **Incremental Refresh:** Updates based on changes in base tables. Pro: Much faster and more efficient. Con: More complex to set up (requires logs/triggers), can impact write performance on base tables.

3.  **Imagine you've designed a system that uses materialized views. What are the key metrics you'd monitor to ensure its health and performance?**
    *   **Answer:**
        *   **Refresh Latency:** How long does a refresh take? Is it meeting SLAs?
        *   **Data Staleness:** How old is the data in the materialized view?
        *   **Query Performance:** Is the materialized view actually improving query response times?
        *   **Storage Usage:** How much disk space are the materialized views consuming?
        *   **Refresh Failures:** Are refreshes failing, and if so, why?
        *   **Base Table Write Latency:** Has implementing materialized view logs impacted application write performance?