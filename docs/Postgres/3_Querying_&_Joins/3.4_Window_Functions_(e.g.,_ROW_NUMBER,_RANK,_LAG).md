---
topic: Postgres
section: Querying & Joins
subtopic: Window Functions (e.g., ROW_NUMBER, RANK, LAG)
level: Intermediate
---

## Window Functions (e.g., ROW_NUMBER, RANK, LAG)
### Core Concepts
*   **Definition:** Window functions perform calculations across a set of table rows that are related to the current row, known as a "window." Unlike aggregate functions (`SUM`, `COUNT`, `AVG`) which collapse rows into a single result per group, window functions return a result for *each* row.
*   **Key Components:**
    *   `OVER()`: Defines the window of rows.
    *   `PARTITION BY`: (Optional) Divides the dataset into partitions, and the window function operates independently within each partition. Similar to `GROUP BY` but preserves individual rows.
    *   `ORDER BY`: (Optional) Orders rows *within* each partition, which is crucial for ranking functions (e.g., `ROW_NUMBER`) and analytic functions (e.g., `LAG`, `LEAD`).
    *   `ROWS`/`RANGE` (Window Frame): (Optional) Further refines the set of rows within the partition on which the function operates (e.g., `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` for running totals).

### Key Details & Nuances
*   **Execution Order:** Window functions are executed *after* `FROM`, `WHERE`, `GROUP BY`, and `HAVING` clauses, but *before* `SELECT`, `DISTINCT`, `ORDER BY`, and `LIMIT`. This is critical: you cannot directly filter on the result of a window function in the `WHERE` clause; you need a subquery or Common Table Expression (CTE).
*   **Function Types:**
    *   **Ranking Functions:** Assign a rank to each row within its partition.
        *   `ROW_NUMBER()`: Assigns a unique sequential integer to each row within its partition, starting from 1. No ties.
        *   `RANK()`: Assigns a rank with gaps for ties. If two rows tie for 1st, the next rank is 3rd.
        *   `DENSE_RANK()`: Assigns a rank without gaps for ties. If two rows tie for 1st, the next rank is 2nd.
    *   **Analytic Functions:** Calculate a value based on other rows in the window.
        *   `LAG(expression, offset, default)`: Accesses data from a previous row in the ordered window. Useful for comparing current row to a prior one.
        *   `LEAD(expression, offset, default)`: Accesses data from a subsequent row in the ordered window. Useful for comparing current row to a future one.
    *   **Aggregate Functions (as Window Functions):** Standard aggregates (`SUM`, `AVG`, `COUNT`) can also be used as window functions, allowing calculations like running totals or moving averages without collapsing rows.
*   **Performance:** Can be resource-intensive on very large datasets, especially with complex `ORDER BY` clauses or many partitions. Proper indexing on `PARTITION BY` and `ORDER BY` columns can significantly help.

### Practical Examples

```sql
-- Example Table Setup (for demonstration)
CREATE TABLE sales (
    sale_id SERIAL PRIMARY KEY,
    sale_date DATE NOT NULL,
    product_id INT NOT NULL,
    region VARCHAR(50) NOT NULL,
    amount DECIMAL(10, 2) NOT NULL
);

INSERT INTO sales (sale_date, product_id, region, amount) VALUES
('2023-01-01', 101, 'East', 100.00),
('2023-01-01', 102, 'West', 150.00),
('2023-01-02', 101, 'East', 120.00),
('2023-01-02', 103, 'East', 110.00),
('2023-01-03', 102, 'West', 160.00),
('2023-01-03', 101, 'East', 90.00),
('2023-01-04', 101, 'West', 130.00),
('2023-01-04', 102, 'East', 140.00);

-- 1. Using ROW_NUMBER() to get the most recent sale per product per region
--    Useful for "top N per group" scenarios.
SELECT
    sale_id,
    sale_date,
    product_id,
    region,
    amount,
    ROW_NUMBER() OVER (PARTITION BY product_id, region ORDER BY sale_date DESC, sale_id DESC) AS rn
FROM
    sales;

-- To get only the most recent sale, use a CTE or subquery:
WITH RankedSales AS (
    SELECT
        sale_id,
        sale_date,
        product_id,
        region,
        amount,
        ROW_NUMBER() OVER (PARTITION BY product_id, region ORDER BY sale_date DESC, sale_id DESC) AS rn
    FROM
        sales
)
SELECT
    sale_id,
    sale_date,
    product_id,
    region,
    amount
FROM
    RankedSales
WHERE
    rn = 1;

-- 2. Using RANK() and DENSE_RANK() for ranking sales by amount within each region
SELECT
    sale_id,
    sale_date,
    region,
    amount,
    RANK() OVER (PARTITION BY region ORDER BY amount DESC) AS regional_rank,
    DENSE_RANK() OVER (PARTITION BY region ORDER BY amount DESC) AS regional_dense_rank
FROM
    sales;

-- 3. Using LAG() to compare current sale amount with the previous sale amount for the same product
--    Useful for calculating growth, differences, or identifying trends over time.
SELECT
    sale_id,
    sale_date,
    product_id,
    region,
    amount,
    LAG(amount, 1, 0) OVER (PARTITION BY product_id ORDER BY sale_date, sale_id) AS previous_sale_amount,
    amount - LAG(amount, 1, 0) OVER (PARTITION BY product_id ORDER BY sale_date, sale_id) AS amount_difference
FROM
    sales
ORDER BY
    product_id, sale_date, sale_id;

-- 4. Using SUM() as a window function for running totals
SELECT
    sale_date,
    region,
    amount,
    SUM(amount) OVER (PARTITION BY region ORDER BY sale_date) AS running_total_region,
    SUM(amount) OVER (ORDER BY sale_date) AS running_total_overall
FROM
    sales
ORDER BY
    sale_date, region;
```

### Common Pitfalls & Trade-offs
*   **Filtering Issues:** A common mistake is trying to filter the result of a window function directly in the `WHERE` clause (e.g., `WHERE ROW_NUMBER() > 1`). This won't work due to execution order. **Solution:** Use a CTE or subquery to define the window function, then filter the result of that CTE/subquery.
*   **Missing `ORDER BY`:** For ranking functions (`ROW_NUMBER`, `RANK`) and analytical functions (`LAG`, `LEAD`), `ORDER BY` within the `OVER()` clause is crucial. Without it, the order of rows in the window is non-deterministic, leading to unpredictable results.
*   **Performance on Large Datasets:** Window functions can be computationally expensive, especially when `PARTITION BY` columns lack indexes, or when the number of rows within a partition is very large, requiring significant memory and processing power to sort and process the window.
*   **Over-complication:** Sometimes a simple `GROUP BY` or a series of joins might achieve the desired result more efficiently for basic aggregations, especially if the "window" is simply the entire group. Always consider simpler alternatives first.

### Interview Questions
1.  **Explain the difference between `ROW_NUMBER()`, `RANK()`, and `DENSE_RANK()`. Provide a scenario for each.**
    *   **Expert Answer:** All assign ranks within a partition. `ROW_NUMBER()` assigns a unique, sequential integer to each row (1, 2, 3...), even for ties. Use it when you need a distinct identifier or to select the "top N" items per group. `RANK()` assigns ranks with gaps for ties (e.g., 1, 1, 3...). Use it when you want to see true positional rank, acknowledging ties. `DENSE_RANK()` assigns ranks without gaps for ties (e.g., 1, 1, 2...). Use it when you want a continuous ranking sequence, ignoring the number of tied rows.
2.  **When would you use a window function over a standard aggregate function with `GROUP BY`?**
    *   **Expert Answer:** Use window functions when you need to perform calculations *across related rows* but still want to **retain the individual rows** in the result set. Standard `GROUP BY` aggregates collapse rows into single summary rows, losing the detail of individual records. Window functions are ideal for per-row calculations like running totals, moving averages, comparing current row to previous/next, or ranking items within subgroups without sacrificing the original data granularity.
3.  **How do `LAG()` and `LEAD()` work, and provide a scenario where they are useful?**
    *   **Expert Answer:** `LAG(column, offset, default)` retrieves the value of `column` from a row that appears `offset` rows *before* the current row in the window defined by `OVER()`. `LEAD()` does the opposite, retrieving from a row `offset` rows *after*. Both require an `ORDER BY` clause in `OVER()`. A common scenario for `LAG()` is calculating the **difference or growth between consecutive periods** (e.g., month-over-month sales change, or the time elapsed since the previous event for a user). `LEAD()` could be used to predict the next event or calculate the duration until the next status change.
4.  **What are `PARTITION BY` and `ORDER BY` within the `OVER()` clause, and why are both often necessary?**
    *   **Expert Answer:** `PARTITION BY` divides the dataset into independent logical groups (partitions) before the window function is applied. The function then operates solely within each partition. `ORDER BY` specifies the order of rows *within* each of these partitions. Both are often necessary because `PARTITION BY` defines *what* set of rows the function should consider as a "window" (e.g., per product, per region), and `ORDER BY` defines the *sequence* within that window, which is crucial for functions that depend on row position (like `ROW_NUMBER`, `RANK`, `LAG`, `LEAD`) or for cumulative calculations. Without `ORDER BY`, the result for positional functions would be non-deterministic.
5.  **Can you filter rows based on the result of a window function in the `WHERE` clause? If not, how would you achieve this?**
    *   **Expert Answer:** No, you cannot directly filter on the result of a window function in the `WHERE` clause. This is due to the SQL query execution order: `WHERE` clauses are processed *before* window functions are evaluated. To achieve this, you must first calculate the window function result, and then filter based on that result. This is typically done using a **Common Table Expression (CTE)** or a **subquery**. You define the CTE/subquery to include the window function's output, and then your outer query can filter on that calculated column.