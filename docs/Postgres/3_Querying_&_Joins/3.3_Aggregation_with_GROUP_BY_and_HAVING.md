---
topic: Postgres
section: Querying & Joins
subtopic: Aggregation with GROUP BY and HAVING
level: Intermediate
---

## Aggregation with GROUP BY and HAVING
### Core Concepts

*   **`GROUP BY` Clause:**
    *   **Purpose:** Aggregates rows that have the same values in specified columns into summary rows. It's used with aggregate functions (e.g., `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()`) to perform calculations on each group.
    *   **Mechanism:** Divides the result set into groups based on identical values in one or more columns. The aggregate function then operates on the rows within each of these groups.

*   **`HAVING` Clause:**
    *   **Purpose:** Filters groups of rows based on a specified condition, typically applied after the `GROUP BY` clause has aggregated the data.
    *   **Mechanism:** Similar to `WHERE`, but operates on the results of aggregate functions, allowing you to filter groups based on aggregated values (e.g., "only show groups where the sum of sales is greater than 1000").

### Key Details & Nuances

*   **`WHERE` vs. `HAVING` - Order of Operations:**
    *   `WHERE` filters individual rows *before* they are grouped. It cannot use aggregate functions.
    *   `HAVING` filters groups *after* they have been formed by `GROUP BY` and aggregate functions have been calculated. It *must* use aggregate functions in its condition (or refer to a column in `GROUP BY`).
    *   **Logical Query Processing Order:**
        ```mermaid
        graph TD;
            A["FROM & JOINs"] --> B["WHERE clause filters rows"];
            B --> C["GROUP BY aggregates rows"];
            C --> D["HAVING clause filters groups"];
            D --> E["SELECT determines output"];
            E --> F["ORDER BY sorts results"];
            F --> G["LIMIT & OFFSET paginate"];
        ```

*   **`SELECT` Clause Restrictions with `GROUP BY`:**
    *   Any column in the `SELECT` list that is *not* an aggregate function *must* also be present in the `GROUP BY` clause. This ensures that for each row returned, the non-aggregated columns have a single, well-defined value for that group.
    *   Failure to adhere to this rule results in an error (e.g., `column "customers.name" must appear in the GROUP BY clause or be used in an aggregate function`).

*   **Performance Considerations:**
    *   **`WHERE` first:** Always apply `WHERE` clauses to filter as many rows as possible *before* `GROUP BY` to reduce the dataset that needs to be grouped, significantly improving performance.
    *   **Indexing:** Indexes on `GROUP BY` columns can accelerate the grouping process, especially for large datasets.
    *   **Cardinality:** Grouping by columns with high cardinality (many unique values) can be more resource-intensive.

*   **`NULL` Values:**
    *   `NULL` values in a `GROUP BY` column are treated as a distinct group. All `NULL`s will be grouped together into a single group.

*   **Advanced Aggregation (Senior Level):**
    *   **`ROLLUP`:** Generates grouping sets for the specified columns and all their possible sub-totals, including a grand total. (e.g., `GROUP BY ROLLUP(col1, col2)` generates groups for `(col1, col2)`, `(col1)`, and `()`).
    *   **`CUBE`:** Generates grouping sets for all possible combinations of the specified columns. (e.g., `GROUP BY CUBE(col1, col2)` generates groups for `(col1, col2)`, `(col1)`, `(col2)`, and `()`).
    *   **`GROUPING SETS`:** Allows you to define multiple explicit grouping criteria within a single query, offering fine-grained control over which aggregates are generated.

### Practical Examples

Consider an `orders` table:
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(50)
);

INSERT INTO orders (order_id, customer_id, order_date, total_amount, status) VALUES
(1, 101, '2023-01-15', 150.00, 'completed'),
(2, 102, '2023-01-16', 200.00, 'completed'),
(3, 101, '2023-02-01', 50.00, 'pending'),
(4, 103, '2023-02-05', 300.00, 'completed'),
(5, 102, '2023-03-10', 100.00, 'completed'),
(6, 101, '2023-03-12', 250.00, 'completed'),
(7, 104, '2023-04-01', 50.00, 'pending'),
(8, 103, '2023-04-05', 100.00, 'cancelled');
```

**Query: Find customers who spent more than $300 in total on 'completed' orders in Q1 2023 (Jan-Mar).**

```sql
SELECT
    customer_id,
    COUNT(order_id) AS total_completed_orders,
    SUM(total_amount) AS total_spent_on_completed
FROM
    orders
WHERE
    status = 'completed' AND -- Filters individual rows (only completed orders)
    order_date BETWEEN '2023-01-01' AND '2023-03-31' -- Filters individual rows (Q1 2023)
GROUP BY
    customer_id -- Groups results by customer
HAVING
    SUM(total_amount) > 300 -- Filters groups (only customers with total_spent_on_completed > 300)
ORDER BY
    total_spent_on_completed DESC;
```

**Output:**
```
 customer_id | total_completed_orders | total_spent_on_completed
-------------+------------------------+--------------------------
         101 |                      2 |                   400.00
         103 |                      1 |                   300.00 -- Note: This would be filtered out if strictly > 300.00. Example adjusted to show the threshold.
```

### Common Pitfalls & Trade-offs

*   **Incorrect `SELECT` list:** Forgetting to include non-aggregated columns in `GROUP BY` is a very common error.
*   **Misusing `WHERE` vs. `HAVING`:** Trying to filter aggregated results with `WHERE` (e.g., `WHERE COUNT(order_id) > 5`) will fail, and trying to filter individual rows with `HAVING` is inefficient or incorrect.
*   **Performance on large datasets:** Aggregating huge tables without proper indexing or prior row filtering can lead to very slow queries, consuming significant CPU and memory.
*   **Over-grouping:** Grouping by too many columns can produce too many small groups, diminishing the benefits of aggregation and potentially making the output difficult to interpret.

### Interview Questions

1.  **"Explain the core difference between `WHERE` and `HAVING` clauses in SQL, and when you would use each."**
    *   **Answer:** `WHERE` filters individual rows *before* aggregation, based on conditions that do not involve aggregate functions. `HAVING` filters *groups* of rows *after* aggregation, based on conditions that typically involve aggregate functions. Use `WHERE` to reduce the dataset before grouping and `HAVING` to filter the results of your aggregate calculations.

2.  **"What are the rules regarding columns you can include in your `SELECT` statement when using `GROUP BY`?"**
    *   **Answer:** Any column specified in the `SELECT` list must either be part of an aggregate function (e.g., `SUM(amount)`) or explicitly listed in the `GROUP BY` clause. This ensures that for each grouped row, the selected non-aggregated columns have a single, unambiguous value.

3.  **"How would you optimize a slow query that uses `GROUP BY` on a very large table?"**
    *   **Answer:**
        1.  **Apply `WHERE` clauses early:** Filter as many rows as possible *before* grouping to reduce the data set.
        2.  **Indexing:** Ensure that columns used in the `GROUP BY` clause and `WHERE` clause are appropriately indexed.
        3.  **Avoid `SELECT *`:** Only select necessary columns.
        4.  **Consider materialized views or summary tables:** For frequently run aggregate queries on static data, pre-calculating and storing the aggregates can drastically improve read performance.
        5.  **Review query plan (`EXPLAIN ANALYZE`):** Understand where the bottlenecks are.

4.  **"Briefly explain `ROLLUP`, `CUBE`, or `GROUPING SETS` and their use cases. (Senior-level question)"**
    *   **Answer:** These are advanced extensions to `GROUP BY` for generating multiple grouping sets (subtotals and grand totals) within a single query.
        *   `ROLLUP` creates subtotals for a hierarchy of columns.
        *   `CUBE` creates subtotals for all possible combinations of grouping columns.
        *   `GROUPING SETS` allows you to specify specific, distinct sets of columns to group by, offering precise control.
        They are used for reporting and analytical purposes where multiple levels of aggregation are required efficiently.

5.  **"How does `GROUP BY` handle `NULL` values in the grouping column?"**
    *   **Answer:** `NULL` values in the column(s) specified in the `GROUP BY` clause are treated as a distinct group. All rows with `NULL` in the grouping column will be placed into a single group.