---
topic: TypeScript
section: Advanced Types and Generics
subtopic: Handling `null` and `undefined` with `strictNullChecks`
level: Intermediate
---

## Handling `null` and `undefined` with `strictNullChecks`
### Core Concepts

*   **`strictNullChecks` Flag:** A TypeScript compiler option (`tsconfig.json`) that, when enabled, makes `null` and `undefined` distinct types.
    *   They are no longer implicitly assignable to any type (e.g., `string` cannot accept `null` without explicitly being `string | null`).
    *   Crucial for catching common runtime errors (e.g., `TypeError: Cannot read property 'x' of null`).
*   **Purpose:** Enhances type safety by forcing developers to explicitly handle cases where values might be `null` or `undefined`, preventing accidental dereferencing.

### Key Details & Nuances

*   **Union Types:** When `strictNullChecks` is on, if a variable can be `null` or `undefined`, its type must explicitly include `null` or `undefined` (e.g., `string | null`, `number | undefined`, `boolean | null | undefined`).
*   **Type Narrowing:** The process by which TypeScript reduces the set of possible types for a variable based on runtime checks. Essential for safely working with nullable types. Common narrowing techniques include:
    *   **Truthiness Checks:** `if (value)`, `if (!value)`
    *   **Equality Checks:** `if (value !== null)`, `if (value !== undefined)`
    *   **`typeof` Operator:** `if (typeof value === 'string')`
    *   **`instanceof` Operator:** `if (value instanceof MyClass)`
    *   **Optional Chaining (`?.`):** Safely accesses properties or calls methods on potentially `null` or `undefined` objects.
    *   **Nullish Coalescing Operator (`??`):** Provides a default value only when the expression on the left is `null` or `undefined` (not just falsy like `||`).
*   **Non-Null Assertion Operator (`!`):** Tells the TypeScript compiler that an expression is *definitely not* `null` or `undefined` at a certain point.
    *   **Use with Caution:** Bypasses type safety, should only be used when the developer has more specific runtime knowledge than the compiler. Overuse defeats the purpose of `strictNullChecks`.
*   **Definite Assignment Assertion (`!:`):** Used in class properties or variable declarations to indicate that a variable will *definitely* be assigned a value before it's used, even if the compiler can't prove it.
    *   `let x!: number;`
    *   Common in frameworks like Angular where properties are initialized in lifecycle hooks.

### Practical Examples

```typescript
// --- tsconfig.json example snippet ---
// {
//   "compilerOptions": {
//     "strictNullChecks": true,
//     // ... other options
//   }
// }

interface User {
    id: number;
    name: string;
    email?: string | null; // email can be string, undefined, or null
}

function getUserEmail(user: User): string | null {
    // 1. Using type narrowing with explicit checks
    if (user.email !== undefined && user.email !== null) {
        return user.email.toLowerCase(); // TypeScript knows user.email is string here
    }
    return null;
}

function displayUserName(user: User | null): string {
    // 2. Type narrowing with truthiness check
    if (user) { // user is narrowed to User
        return user.name;
    }
    return "Guest";
}

function processUser(user: User | null) {
    // 3. Optional Chaining for safe access
    const userEmailLength = user?.email?.length; // userEmailLength is number | undefined

    console.log(`User email length: ${userEmailLength ?? 'N/A'}`); // 4. Nullish Coalescing for default value
}

// 5. Non-null assertion operator (use sparingly!)
function logMandatoryEmail(user: User) {
    // Assume we know email is always set here due to external logic or validation
    // TypeScript would normally complain if email could be null/undefined for .toLowerCase()
    const email = user.email!.toLowerCase(); // Asserting email is not null/undefined
    console.log(`Mandatory email: ${email}`);
}

const u1: User = { id: 1, name: "Alice" };
const u2: User = { id: 2, name: "Bob", email: "bob@example.com" };
const u3: User = { id: 3, name: "Charlie", email: null };

console.log(getUserEmail(u1)); // null
console.log(getUserEmail(u2)); // bob@example.com
console.log(getUserEmail(u3)); // null

console.log(displayUserName(u1)); // Alice
console.log(displayUserName(null)); // Guest

processUser(u1); // User email length: N/A
processUser(u2); // User email length: 15
processUser(u3); // User email length: N/A

logMandatoryEmail(u2); // Mandatory email: bob@example.com
// logMandatoryEmail(u1); // This would cause runtime error but TS allows due to '!'
```

### Common Pitfalls & Trade-offs

*   **Overuse of Non-Null Assertion (`!`):**
    *   **Pitfall:** Defeats the purpose of `strictNullChecks`, reintroduces the very runtime errors it aims to prevent. Makes code harder to reason about from a type perspective.
    *   **Trade-off:** Provides a quick fix for type errors, useful in specific scenarios where the developer has guaranteed runtime knowledge the compiler lacks (e.g., after a rigorous validation step, or interacting with poorly typed external libraries). Prioritize type narrowing or better type definitions.
*   **Migration Difficulty:** Enabling `strictNullChecks` in a large, existing codebase not originally designed with it can introduce a high volume of new type errors, requiring significant refactoring.
    *   **Trade-off:** Short-term pain for long-term gain in code reliability and maintainability. Consider enabling gradually or for new modules.
*   **Readability vs. Safety:** Extensive null checks can sometimes make code more verbose.
    *   **Trade-off:** Improved safety and fewer runtime bugs generally outweigh increased verbosity. Modern TS features like optional chaining (`?.`) and nullish coalescing (`??`) significantly mitigate verbosity.

### Interview Questions

1.  **Question:** Explain the purpose and benefits of `strictNullChecks` in TypeScript. How does it improve code quality?
    **Answer:** `strictNullChecks` is a compiler option that treats `null` and `undefined` as distinct types, preventing them from being implicitly assigned to other types (e.g., `string` cannot be `null`). This forces developers to explicitly handle potential `null`/`undefined` values, eliminating a common class of runtime errors like `TypeError: Cannot read property 'x' of undefined`. It makes type definitions more precise, improves type safety, and leads to more robust and predictable code.

2.  **Question:** Describe different strategies for safely handling potentially `null` or `undefined` values when `strictNullChecks` is enabled. Provide examples.
    **Answer:** The primary strategy is **type narrowing**. This includes:
    *   **Truthiness checks:** `if (value)` or `if (value !== null && value !== undefined)`.
    *   **Optional Chaining (`?.`):** `user?.profile?.name`.
    *   **Nullish Coalescing Operator (`??`):** `const name = user.name ?? 'Guest'`.
    *   **`typeof` guards:** `if (typeof value === 'string')`.
    *   The goal is to provide the TypeScript compiler with enough information to deduce the precise type of a variable at a given point, allowing safe operations.

3.  **Question:** When is it appropriate to use the non-null assertion operator (`!`), and what are its potential downsides?
    **Answer:** The non-null assertion operator `!` (`myValue!`) should be used **sparingly** and only when the developer has **guaranteed runtime knowledge** that a value is non-null/non-undefined, but TypeScript cannot infer it. Examples include values assigned through complex logic, or after external validation.
    **Downsides:** It bypasses TypeScript's type safety, effectively telling the compiler "trust me, I know this isn't null." If the assumption is wrong, it reintroduces the very runtime `TypeError` that `strictNullChecks` aims to prevent, making the code less reliable and harder to debug.

4.  **Question:** Compare and contrast the `||` (logical OR) operator with the `??` (nullish coalescing) operator when providing default values in TypeScript.
    **Answer:**
    *   **`||` (Logical OR):** Returns the right-hand operand if the left-hand operand is any "falsy" value (i.e., `false`, `0`, `''` (empty string), `null`, `undefined`, `NaN`).
    *   **`??` (Nullish Coalescing):** Returns the right-hand operand only if the left-hand operand is `null` or `undefined`. It treats `false`, `0`, and `''` as "truthy" (non-nullish) values.
    **Use Case:** `??` is preferred when you want to provide a default *only* for `null` or `undefined`, and intentionally allow `false`, `0`, or `''` as valid values. `||` is useful when any falsy value should trigger the default.