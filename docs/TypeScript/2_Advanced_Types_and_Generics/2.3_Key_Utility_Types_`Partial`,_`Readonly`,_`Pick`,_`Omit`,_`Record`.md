---
topic: TypeScript
section: Advanced Types and Generics
subtopic: Key Utility Types: `Partial`, `Readonly`, `Pick`, `Omit`, `Record`
level: Intermediate
---

## Key Utility Types: `Partial`, `Readonly`, `Pick`, `Omit`, `Record`
### Core Concepts

*   **TypeScript Utility Types:** Built-in generic types that facilitate common type transformations. They are compile-time constructs, meaning they have no runtime impact.
*   **`Partial<Type>`:** Creates a type with all properties of `Type` set to optional. Useful for scenarios where you need to work with a subset of an object's properties or update operations.
*   **`Readonly<Type>`:** Creates a type with all properties of `Type` set to `readonly`. Useful for ensuring immutability of an object's properties after creation.
*   **`Pick<Type, Keys>`:** Constructs a type by selecting a set of properties `Keys` (a union of string literals) from `Type`. Useful for creating simpler types containing only relevant fields.
*   **`Omit<Type, Keys>`:** Constructs a type by taking all properties from `Type` and then removing a set of `Keys` (a union of string literals). The inverse of `Pick`. Useful for creating types by excluding specific fields.
*   **`Record<Keys, Type>`:** Constructs an object type whose property keys are `Keys` (a union of string literals or a `string`/`number`/`symbol` literal type) and whose property values are `Type`. Useful for defining dictionary-like objects or mappings.

### Key Details & Nuances

*   **Generic Nature:** All these utility types are generics, accepting one or more type arguments to perform their transformations.
*   **Compile-time Only:** These types exist purely at design time to provide strong typing and prevent common errors. They compile away to regular JavaScript.
*   **Immutability vs. Readonly:** `Readonly` ensures that properties cannot be reassigned after initialization. It does not enforce deep immutability; nested objects' properties can still be modified unless explicitly made `Readonly`.
*   **Use Cases:**
    *   **`Partial`:** Function arguments for optional updates (e.g., `updateUser(id: string, updates: Partial<User>)`), form data.
    *   **`Readonly`:** Data Transfer Objects (DTOs) that should not be modified after creation, state objects in functional programming.
    *   **`Pick`/`Omit`:** Creating specific request/response DTOs from larger domain models, deriving types for database queries or API payloads where only specific fields are needed/excluded.
    *   **`Record`:** Mapping configurations, defining enum-like objects with specific values, creating lookup tables.
*   **Chaining/Composition:** These utility types can be combined for more complex type transformations (e.g., `Partial<Readonly<User>>`).

### Practical Examples

```typescript
// Define a base User type
interface User {
  id: string;
  name: string;
  email: string;
  age?: number; // Optional property
  settings: { theme: string; notifications: boolean };
}

// 1. Partial<Type>
type PartialUser = Partial<User>;
// All properties are now optional: { id?: string; name?: string; email?: string; age?: number; settings?: { theme: string; notifications: boolean } }

const userUpdates: PartialUser = {
  name: "Jane Doe",
  age: 30,
};

function updateUser(userId: string, updates: PartialUser) {
  // Logic to update user, e.g., in a database
  console.log(`Updating user ${userId} with:`, updates);
}
updateUser("123", userUpdates);

// 2. Readonly<Type>
type ImmutableUser = Readonly<User>;
// All properties are now readonly: { readonly id: string; readonly name: string; readonly email: string; readonly age?: number; readonly settings: { theme: string; notifications: boolean } }

const immutableUser: ImmutableUser = {
  id: "456",
  name: "John Smith",
  email: "john@example.com",
  settings: { theme: "dark", notifications: true },
};

// immutableUser.name = "New Name"; // Error: Cannot assign to 'name' because it is a read-only property.
// immutableUser.settings.theme = "light"; // No error! Readonly is shallow.

// 3. Pick<Type, Keys>
type UserProfile = Pick<User, "name" | "email">;
// Type is now: { name: string; email: string; }

const profile: UserProfile = {
  name: "Alice",
  email: "alice@example.com",
};

// 4. Omit<Type, Keys>
type UserWithoutSensitiveData = Omit<User, "email" | "age">;
// Type is now: { id: string; name: string; settings: { theme: string; notifications: boolean } }

const publicUser: UserWithoutSensitiveData = {
  id: "789",
  name: "Bob",
  settings: { theme: "light", notifications: false },
};

// 5. Record<Keys, Type>
type RolePermissions = Record<"admin" | "editor" | "viewer", string[]>;
// Type is now: { admin: string[]; editor: string[]; viewer: string[]; }

const permissions: RolePermissions = {
  admin: ["read", "write", "delete"],
  editor: ["read", "write"],
  viewer: ["read"],
};

type StatusCodeDescriptions = Record<number, string>;
const httpDescriptions: StatusCodeDescriptions = {
  200: "OK",
  404: "Not Found",
  500: "Internal Server Error",
};
```

### Common Pitfalls & Trade-offs

*   **Shallow Immutability (`Readonly`):** A common misconception is that `Readonly` creates deeply immutable objects. It only makes the direct properties of the type `readonly`. For deep immutability, one would need recursive `Readonly` types or libraries like Immer/Immutable.js.
*   **Misunderstanding Key Types:** `Pick`, `Omit`, and `Record` expect their `Keys` argument to be string literal unions, `keyof any` (for `Record`), or specific `string`/`number`/`symbol` types. Passing a generic `string` might not always yield the desired specific type.
*   **Overuse/Underuse:** While powerful, don't create overly complex type transformations when a simple interface definition suffices. Conversely, neglecting them can lead to redundant type definitions or weaker type safety.
*   **No Runtime Impact:** Remember these are compile-time only. They don't generate any extra JavaScript code or performance overhead at runtime. Any type checks happen during compilation.

### Interview Questions

1.  **Question:** Explain the primary difference between `Pick<Type, Keys>` and `Omit<Type, Keys>`. Provide a scenario where each would be more appropriate.
    **Answer:** `Pick` constructs a type by *including* only the specified `Keys` from `Type`, while `Omit` constructs a type by *excluding* the specified `Keys` from `Type`. `Pick` is suitable when you have a large type and need a small subset of its properties (e.g., creating a user profile type from a full user object). `Omit` is better when you need most properties from a type but want to exclude a few specific ones, such as sensitive data before sending an object over a network.

2.  **Question:** How does `Partial<Type>` assist in building robust API request bodies for update operations? What is a potential pitfall if not used carefully?
    **Answer:** `Partial<Type>` is excellent for update operations because it makes all properties optional. This allows you to send only the fields that are being updated, without requiring the client to send the entire object. A potential pitfall is that if the API expects `null` or `undefined` for specific fields to indicate removal or reset, `Partial` alone won't differentiate between a field not being sent (optional) and a field explicitly sent as `undefined` (which might be intended as "remove this value"). This requires careful API design and validation.

3.  **Question:** Describe a real-world scenario where `Record<Keys, Type>` would be the ideal utility type to use.
    **Answer:** `Record<Keys, Type>` is ideal for defining object maps or dictionaries where the keys are known or belong to a specific set, and the values are of a consistent type. For example, configuring different logging levels for various application modules:
    ```typescript
    type ModuleLogSettings = Record<"auth" | "database" | "api", "info" | "debug" | "error">;
    const appLogs: ModuleLogSettings = {
        auth: "debug",
        database: "info",
        api: "error"
    };
    ```
    This ensures that only specified module names can be used as keys and only valid log levels can be assigned as values.

4.  **Question:** You have a `User` interface. You need a new type `DeepReadonlyUser` where all properties, including those of nested objects, are immutable. Explain why `Readonly<User>` alone is insufficient and how you might approach this.
    **Answer:** `Readonly<User>` only enforces shallow immutability, meaning it makes the direct properties of `User` `readonly`. If `User` has nested objects (e.g., `settings: { theme: string }`), `Readonly<User>` will make `settings` itself `readonly`, but `immutableUser.settings.theme` can still be modified. To achieve deep immutability, one would typically create a recursive `DeepReadonly` utility type or use a library that handles deep immutability (like Immer, although Immer focuses on immutability by copying, not type enforcement). A basic recursive type might look like `type DeepReadonly<T> = { readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]; };`.