---
topic: TypeScript
section: Advanced Types and Generics
subtopic: Class Typing: `implements`, `public`/`private`/`protected`, `readonly` properties
level: Intermediate
---

## Class Typing: `implements`, `public`/`private`/`protected`, `readonly` properties
### Core Concepts

*   **`implements` Clause:**
    *   Enables a class to explicitly verify that it satisfies a given interface or set of interfaces.
    *   A compile-time check: TypeScript ensures the class has all the required members (properties and methods) with compatible types as defined in the interface.
    *   Does *not* change the runtime behavior of the class; interfaces are type-only constructs and are erased during compilation to JavaScript.

*   **Access Modifiers (`public`, `private`, `protected`):**
    *   Control the visibility and accessibility of class members (properties, methods, constructors).
    *   **`public` (default):** Members are accessible from anywhere (inside the class, subclasses, and outside instances).
    *   **`private`:** Members are accessible only within the declaring class itself. Not accessible from subclasses or instances outside the class.
    *   **`protected`:** Members are accessible within the declaring class and its subclasses (derived classes), but not from instances outside the class hierarchy.

*   **`readonly` Properties:**
    *   Specifies that a property can only be assigned a value during its declaration or within the class's constructor.
    *   Once initialized, its value cannot be changed.
    *   Primarily used to enforce immutability for specific properties, enhancing code predictability and safety.

### Key Details & Nuances

*   **`implements` Nuances:**
    *   A class can `implements` multiple interfaces (e.g., `class MyClass implements IFlyable, ISwimmable`).
    *   Interfaces describe the *public* shape of a class. `implements` only checks public members; it does not enforce private/protected members defined in an interface (as interfaces don't define those).
    *   `implements` provides a strong contract, useful for dependency injection and ensuring consistency across different implementations of a common behavior.

*   **Access Modifier Specifics:**
    *   **`public`:** The default access modifier. If you don't specify one, a member is public.
    *   **`private` (TypeScript's):**
        *   Enforced *only at compile-time* by TypeScript. At runtime, these properties/methods are still accessible as standard JavaScript properties (e.g., `instance._privateProp`). This is a key distinction from native JavaScript `#private` fields.
        *   Useful for internal helper methods or data that should not be exposed externally.
    *   **`protected`:**
        *   Ideal for methods or properties that are part of a class's internal logic but need to be accessible by subclasses for extension or specific behavior override, while remaining hidden from external consumers.
        *   Often used in conjunction with abstract classes or base classes in an inheritance hierarchy.

*   **`readonly` Deep Dive:**
    *   **Shallow Immutability:** `readonly` only prevents reassignment of the property itself. If the property's value is an object or array, its *contents* can still be modified (e.g., `readonly arr: number[]` allows `arr.push(5)` but not `arr = [1,2]`). For deep immutability, consider libraries like Immer or deep freezing objects.
    *   **Constructor Assignment:** `readonly` properties *must* be initialized at declaration or in the constructor. TypeScript checks this.
    *   **Constructor Parameter Properties:** A concise way to declare and initialize class properties.
        ```typescript
        class Greeter {
            constructor(public readonly name: string) {
                // 'name' is automatically declared as a public readonly property
                // and initialized with the constructor argument.
            }
        }
        ```

### Practical Examples

```typescript
// Define an interface
interface ILogger {
    log(message: string): void;
    logError(error: Error): void;
}

// Define a base class to demonstrate protected
class BaseService {
    protected serviceId: string;
    constructor(id: string) {
        this.serviceId = id;
    }
    protected getServiceInfo(): string {
        return `Service ID: ${this.serviceId}`;
    }
}

// Implement the interface and extend the base class
class ConsoleLogger extends BaseService implements ILogger {
    // public: default, accessible anywhere
    public readonly name: string = "ConsoleLogger";
    private readonly maxLogLength: number = 100; // private: accessible only within this class
    protected logLevel: string = "INFO"; // protected: accessible within this class and subclasses

    constructor(loggerId: string) {
        super(loggerId);
    }

    // Implements ILogger.log
    public log(message: string): void {
        const truncatedMessage = message.substring(0, this.maxLogLength);
        console.log(`[${this.name} - ${this.logLevel}] ${truncatedMessage}`);
        console.log(`Using base service info: ${this.getServiceInfo()}`); // Access protected method from base
    }

    // Implements ILogger.logError
    public logError(error: Error): void {
        console.error(`[${this.name} - ERROR] ${error.message}`);
    }

    // Private method
    private getTimestamp(): string {
        return new Date().toISOString();
    }
}

// A subclass to demonstrate protected access
class EnhancedLogger extends ConsoleLogger {
    constructor(loggerId: string) {
        super(loggerId);
        this.logLevel = "DEBUG"; // Accessible because it's protected in ConsoleLogger
    }

    public debug(message: string): void {
        console.log(`[DEBUG] ${this.getTimestamp()} - ${message}`); // Cannot access private getTimestamp() directly
        // Instead, need to call via public method if available, or make it protected
        this.log(message); // Using inherited public log method
    }
}


const logger = new ConsoleLogger("main-logger");
logger.log("This is a test message.");
logger.logError(new Error("Something went wrong!"));

// --- Demonstrating access restrictions ---

// logger.maxLogLength; // Error: Property 'maxLogLength' is private
// logger.getTimestamp(); // Error: Property 'getTimestamp' is private
// logger.logLevel; // Error: Property 'logLevel' is protected

const enhancedLogger = new EnhancedLogger("enhanced-logger");
enhancedLogger.debug("Debugging an issue.");
// enhancedLogger.serviceId; // Error: Property 'serviceId' is protected
```

### Common Pitfalls & Trade-offs

*   **TypeScript `private` vs. JavaScript `#private` Fields:**
    *   **TypeScript `private`:** A compile-time construct. At runtime, the property is still publicly accessible (e.g., `instance.myPrivateProperty`). This is useful for type safety during development but offers no runtime privacy guarantees.
    *   **JavaScript `#private`:** A true runtime private field (e.g., `class MyClass { #myPrivateField; }`). Introduced in ES2020. These fields are genuinely inaccessible from outside the class instance at runtime.
    *   **Trade-off:** Use TS `private` for development-time type safety; use JS `#private` for true runtime encapsulation where security or strict information hiding is critical.

*   **`readonly` vs. Deep Immutability:**
    *   **Pitfall:** Assuming `readonly` guarantees that the *contents* of an object or array property cannot be changed. It only prevents reassignment of the reference itself.
    *   **Trade-off:** For true deep immutability, extra steps are required (e.g., `Object.freeze()`, immutable data structures, or libraries). This adds complexity for performance or memory management considerations.

*   **Over-use of `private`/`protected`:**
    *   Can lead to overly rigid class designs, making refactoring or extending functionality difficult.
    *   **Trade-off:** Balance encapsulation with flexibility. Sometimes, a `protected` member is better than `private` if subclasses are expected to interact with it, even if it's not part of the public API. Prefer composition over inheritance when strong encapsulation is desired without complex hierarchies.

*   **`implements` on a Class:**
    *   A class can implement another class. This means the implementing class must satisfy the *public* interface of the class it implements. It does *not* inherit implementation.
    *   **Pitfall:** Confusing `implements ClassA` with `extends ClassA`. `implements` is for type compatibility; `extends` is for inheritance of implementation and type.

### Interview Questions

1.  **Question:** Explain the difference between `implements` and `extends` in the context of TypeScript classes. When would you choose one over the other?
    **Answer:** `extends` is for *inheritance*, meaning a class inherits the implementation (properties and methods) and type from a base class. `implements` is for *type checking*, meaning a class guarantees it conforms to the structure (public properties and methods) defined by an interface or another class's public shape, without inheriting any implementation. You choose `extends` when you want to reuse code and establish an "is-a" relationship. You choose `implements` when you want to enforce a contract or guarantee a specific set of capabilities, often for polymorphism or dependency injection, without dictating the implementation details.

2.  **Question:** Describe the purpose and scope of `public`, `private`, and `protected` access modifiers in TypeScript classes. Provide a scenario where `protected` would be the most appropriate choice.
    **Answer:**
    *   `public` members are accessible from anywhere.
    *   `private` members are accessible only within the declaring class.
    *   `protected` members are accessible within the declaring class and its subclasses.
    *   **Scenario for `protected`:** Consider a `BaseRepository` class with a `protected connectToDatabase()` method. This method needs to be called by derived classes (e.g., `UserRepository`, `ProductRepository`) to establish a database connection, but it should not be callable directly from outside the class hierarchy (e.g., `new UserRepository().connectToDatabase()` should be prevented). Making `connectToDatabase()` protected allows subclasses to use it while encapsulating it from external consumers.

3.  **Question:** What is the key difference between TypeScript's `private` keyword and JavaScript's `#private` fields? When would you prefer one over the other?
    **Answer:** TypeScript's `private` keyword provides *compile-time* type checking; it prevents access errors during development, but the property remains accessible at runtime in the compiled JavaScript. JavaScript's `#private` fields (a recent addition to the language) provide *true runtime encapsulation*; they are genuinely inaccessible from outside the class instance in the compiled JavaScript, offering stronger privacy guarantees. You prefer TS `private` for simple type safety and developer guidance, and JS `#private` when strong runtime encapsulation or security is a critical requirement.

4.  **Question:** How does the `readonly` modifier function in TypeScript classes, and what are its limitations regarding immutability?
    **Answer:** The `readonly` modifier in TypeScript ensures that a class property can only be assigned a value during its declaration or within the class's constructor. After initialization, its value cannot be reassigned. Its primary limitation is that it provides *shallow immutability*. If a `readonly` property holds an object or an array, `readonly` prevents reassigning the reference to a new object/array, but it *does not* prevent modifications to the *contents* of that object or array (e.g., adding/removing items from an array or changing properties of an object). For deep immutability, additional measures like `Object.freeze()` or immutable data structures are required.

5.  **Question:** Explain the concept of a constructor parameter property in TypeScript. Provide a brief example.
    **Answer:** A constructor parameter property is a TypeScript shorthand that allows you to declare a class property, initialize it with a constructor argument, and specify its access modifier (`public`, `private`, `protected`, `readonly`) all in one line within the constructor's parameter list. It reduces boilerplate by automatically creating the property and assigning the incoming argument to it.
    **Example:**
    ```typescript
    class User {
        constructor(public id: number, private _name: string, readonly createdAt: Date) {
            // No need for:
            // this.id = id;
            // this._name = _name;
            // this.createdAt = createdAt;
        }
        getName() { return this._name; }
    }
    const user = new User(1, "Alice", new Date());
    console.log(user.id); // Accessible
    // console.log(user._name); // Error: _name is private
    // user.createdAt = new Date(); // Error: createdAt is readonly
    ```