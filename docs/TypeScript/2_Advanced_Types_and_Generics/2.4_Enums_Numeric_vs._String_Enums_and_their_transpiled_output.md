---
topic: TypeScript
section: Advanced Types and Generics
subtopic: Enums: Numeric vs. String Enums and their transpiled output
level: Intermediate
---

## Enums: Numeric vs. String Enums and their transpiled output
### Core Concepts

*   **Enums (Enumerated Types):** TypeScript enums provide a way to define a set of named constants. They improve code readability and maintainability by allowing you to work with descriptive names instead of magic numbers or strings.
*   **Numeric Enums:** Assign numerical values to members. By default, the first member is `0`, and subsequent members auto-increment. Can be manually initialized.
*   **String Enums:** Assign string literal values to members. Each member *must* be manually initialized with a string literal.

### Key Details & Nuances

*   **Numeric Enums:**
    *   **Auto-incrementing:** If the first member is uninitialized, it defaults to `0`. If initialized, subsequent members auto-increment from its value.
    *   **Reverse Mapping:** TypeScript generates a "reverse mapping" for numeric enums in the transpiled JavaScript, allowing you to get the name of an enum member from its value (e.g., `Direction[2]` might return `"Down"`).
    *   **Type Safety (Limited):** A numeric enum member can be assigned any number, not just valid enum values, which can lead to runtime issues. `let d: DirectionNumeric = 100; // No TS error`
*   **String Enums:**
    *   **No Auto-incrementing:** All members *must* be explicitly initialized with unique string literals.
    *   **No Reverse Mapping:** String enums do not generate reverse mappings, saving some runtime overhead.
    *   **Better Readability & Serialization:** Often preferred for scenarios where the constant values are meaningful strings (e.g., status codes, event types) or when serializing data (e.g., sending over a network).
    *   **Type Safety (Stronger):** You can only assign one of the valid string enum values to an enum variable. `let d: DirectionString = "UP"; // OK. let d2: DirectionString = "OTHER"; // TS Error`
*   **`const` Enums:**
    *   **Compile-time Optimization:** Declared with the `const` keyword (`const enum MyEnum {...}`). These enums are completely removed at compile-time.
    *   **Inlining:** References to `const` enum members are inlined directly into the JavaScript output, meaning no runtime object is created.
    *   **Limitations:** Cannot have reverse mapping. Cannot be iterated over at runtime. Cannot be accessed using bracket notation (e.g., `MyEnum['KEY']`). Useful for purely compile-time constant definitions.

### Practical Examples

```typescript
// TypeScript Enum Definitions

// Numeric Enum: Auto-incrementing and manual initialization
enum DirectionNumeric {
    Up = 1, // Starts at 1
    Down,   // Becomes 2
    Left = 4, // Starts at 4
    Right   // Becomes 5
}

// String Enum: Each member must be explicitly initialized
enum HttpMethodString {
    GET = "GET",
    POST = "POST",
    PUT = "PUT",
    DELETE = "DELETE"
}

// Const Enum: Values inlined at compile time, no runtime object
const enum LoggingLevelConst {
    INFO,    // Becomes 0
    WARN,    // Becomes 1
    ERROR    // Becomes 2
}

// --- Usage Examples ---
let myDirection: DirectionNumeric = DirectionNumeric.Left;
console.log(myDirection); // Output: 4
console.log(DirectionNumeric[myDirection]); // Output: Left (Reverse mapping)

let requestMethod: HttpMethodString = HttpMethodString.POST;
console.log(requestMethod); // Output: POST
// console.log(HttpMethodString["POST"]); // This works in TS, but no reverse mapping means HttpMethodString["POST"] is just "POST"
// console.log(HttpMethodString["GET"] === "GET"); // True

let logLevel: LoggingLevelConst = LoggingLevelConst.ERROR;
console.log(logLevel); // Output: 2 (value is directly inlined in JS)
// console.log(LoggingLevelConst[logLevel]); // Compile error: A const enum member can only be accessed using a string literal.
```

**Transpiled JavaScript Output (`tsc --target es5 --strict --noImplicitAny --module commonjs YourFile.ts`)**

```javascript
// Transpiled from DirectionNumeric
var DirectionNumeric;
(function (DirectionNumeric) {
    DirectionNumeric[DirectionNumeric["Up"] = 1] = "Up";
    DirectionNumeric[DirectionNumeric["Down"] = 2] = "Down";
    DirectionNumeric[DirectionNumeric["Left"] = 4] = "Left";
    DirectionNumeric[DirectionNumeric["Right"] = 5] = "Right";
})(DirectionNumeric || (DirectionNumeric = {}));
// Notice how each numeric value maps back to its string name, and vice-versa.

// Transpiled from HttpMethodString
var HttpMethodString;
(function (HttpMethodString) {
    HttpMethodString["GET"] = "GET";
    HttpMethodString["POST"] = "POST";
    HttpMethodString["PUT"] = "PUT";
    HttpMethodString["DELETE"] = "DELETE";
})(HttpMethodString || (HttpMethodString = {}));
// Notice no reverse mapping generated.

// Transpiled from LoggingLevelConst (if used in console.log)
// console.log(2 /* ERROR */);
// If not used, no code is emitted for `const enum`. The values are inlined where used.
```

### Common Pitfalls & Trade-offs

*   **Numeric Enums:**
    *   **Runtime Overhead:** The generated JavaScript object for numeric enums is larger due to reverse mappings, consuming more memory at runtime.
    *   **Accidental Assignment:** Can be assigned any number, potentially leading to invalid states if not validated at runtime.
    *   **Fragility to Reordering:** Adding or reordering uninitialized members in the middle of a numeric enum can unintentionally change the values of subsequent members, breaking existing code or serialized data.
*   **String Enums:**
    *   **No Reverse Mapping:** Cannot get the string name from the string value directly (e.g., `HttpMethodString["GET"]` is "GET", but `HttpMethodString["UNKNOWN_METHOD"]` is undefined and doesn't map a value back to a name).
    *   **Larger Bundle Size (Slightly):** Each string literal must be explicitly stored.
*   **`const` Enums:**
    *   **Limited Runtime Use:** Cannot be iterated, accessed dynamically, or used where a runtime object is required (e.g., `Object.values(MyEnum)`).
    *   **No Tree-shaking of Unused Members (Potentially):** Since values are inlined, if you only use one member of a large `const` enum, the other members won't be part of the compiled output. However, if an entire enum structure is needed (e.g., for introspection), `const` enums are not suitable.

### Interview Questions

1.  **When would you choose a `string` enum over a `numeric` enum in TypeScript? What are the primary advantages and disadvantages of each?**
    *   **Answer:** Choose `string` enums when values are meaningful strings (e.g., `HttpMethod`, `UserRole`), for better readability, and when serializing/deserializing data. They offer stronger type safety and no reverse mapping overhead. Disadvantages include no auto-incrementing and slightly larger bundle size. Numeric enums are useful for simple integer-based flags or indexes. They have auto-incrementing and reverse mapping, but suffer from weaker type safety (allowing arbitrary numbers) and runtime overhead for reverse mapping.
2.  **Explain the concept of "reverse mapping" in TypeScript enums. Which type of enum supports it, and what is its implication for the transpiled JavaScript output?**
    *   **Answer:** Reverse mapping allows you to retrieve the *name* of an enum member given its *value*. For example, if `Direction.Up` is `1`, `Direction[1]` would return `"Up"`. Only **numeric enums** support reverse mapping. This feature requires TypeScript to generate additional JavaScript code (a mapping from value back to name) in the transpiled output, which adds to the runtime object size and memory footprint. String enums do not have this overhead as they lack reverse mapping.
3.  **Compare and contrast a regular TypeScript enum with a `const` enum in terms of their compilation, runtime behavior, and use cases.**
    *   **Answer:** A regular TypeScript enum (numeric or string) creates a runtime JavaScript object that can be inspected, iterated, and accessed dynamically. `const` enums, however, are entirely removed at compile-time, with their member values inlined directly into the JavaScript output. This means `const` enums have zero runtime overhead and result in smaller bundle sizes for individual member accesses. The trade-off is that `const` enums cannot be iterated or accessed dynamically at runtime (e.g., using `Object.values` or `MyEnum['KEY']`). They are best suited for truly constant values that are only needed at compile-time.
4.  **Discuss the type safety implications of using numeric enums in TypeScript. How does it differ from string enums in this regard?**
    *   **Answer:** Numeric enums in TypeScript offer *weaker* type safety compared to string enums. While you define them with specific named constants, a variable typed as a numeric enum can be assigned *any* number at runtime without a TypeScript compilation error (e.g., `let myEnumVar: MyNumericEnum = 100;` is valid). This can lead to unexpected behavior if code assumes the variable holds a valid enum value. String enums, conversely, provide *stronger* type safety because a variable typed as a string enum can only be assigned one of its predefined string literal values. Assigning any other string will result in a compile-time error.