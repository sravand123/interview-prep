---
topic: TypeScript
section: Advanced Types and Generics
subtopic: Generic Constraints (`extends` keyword)
level: Intermediate
---

## Generic Constraints (`extends` keyword)
### Core Concepts
*   **Purpose**: In TypeScript generics, the `extends` keyword is used to define a **generic constraint**. It specifies an **upper bound** for the types that a generic type parameter (e.g., `T`) can be.
*   **Enforcement**: It enforces that `T` must be assignable to the type specified after `extends`. This ensures that any operations performed on `T` within the generic context are type-safe and valid for all allowed types.
*   **Type Safety & IntelliSense**: By constraining `T`, TypeScript can guarantee that `T` will have certain properties or methods, enabling static type checking and providing better IntelliSense.

### Key Details & Nuances
*   **Upper Bound**: `T extends U` means `T` must be a subtype of `U`. It does not mean `T` must *be* `U` itself.
*   **Accessing Properties**: You can only safely access properties or call methods on a generic type `T` if those properties/methods are guaranteed to exist by its `extends` constraint.
    ```typescript
    interface HasLength {
      length: number;
    }

    function logLength<T extends HasLength>(arg: T): void {
      console.log(arg.length); // OK: 'length' is guaranteed by the constraint
    }

    // function logName<T>(arg: T): void {
    //   console.log(arg.name); // Error: Property 'name' does not exist on type 'T'.
    // }
    ```
*   **`keyof` Operator Integration**: Often combined with `keyof` to create flexible, type-safe generic functions for object property access.
    ```typescript
    function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
      return obj[key];
    }
    ```
*   **Distinction from Class/Interface Inheritance**: The `extends` keyword has a dual meaning in TypeScript:
    *   **Generic Constraints**: Defines an assignability relationship for type parameters.
    *   **Class/Interface Inheritance**: Defines an inheritance relationship for classes and interfaces.
    *   Context always clarifies its meaning.
*   **Conditional Types (`T extends U ? A : B`)**: While `extends` is used, its role here is for a type check within a conditional type, not for defining a generic constraint for `T` itself. This is a common point of confusion.

### Practical Examples
#### 1. Generic function ensuring argument has a specific property
This example shows how `extends` ensures that a generic type `T` always has a `name` property, allowing safe access within the function.

```typescript
interface NamedEntity {
  id: string;
  name: string;
}

/**
 * Logs the name of any object that conforms to the NamedEntity interface.
 * @param item An object that must have 'id' and 'name' properties.
 */
function logItemName<T extends NamedEntity>(item: T): void {
  console.log(`Item ID: ${item.id}, Name: ${item.name}`);
}

// ✅ Valid usage:
const user = { id: 'u1', name: 'Alice', email: 'alice@example.com' };
logItemName(user); // Output: Item ID: u1, Name: Alice

const product = { id: 'p1', name: 'Laptop', price: 1200 };
logItemName(product); // Output: Item ID: p1, Name: Laptop

// ❌ Invalid usage (Type Error: Argument of type '{ code: string; value: number; }' is not assignable to parameter of type 'NamedEntity'):
// const itemWithoutName = { code: 'c1', value: 100 };
// logItemName(itemWithoutName);
```

#### 2. Generic function for safe object property retrieval
This example uses `extends keyof T` to ensure that the `key` argument is a valid key of the `obj` argument, providing strong type safety.

```typescript
/**
 * Safely retrieves a property from an object using a generic key.
 * @param obj The object from which to retrieve the property.
 * @param key The key of the property to retrieve, must be a key of obj.
 * @returns The value of the specified property.
 */
function getObjectProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = {
  firstName: 'John',
  lastName: 'Doe',
  age: 30
};

// ✅ Valid usage:
const firstName = getObjectProperty(person, 'firstName'); // type: string
console.log(firstName); // Output: John

const age = getObjectProperty(person, 'age'); // type: number
console.log(age); // Output: 30

// ❌ Invalid usage (Type Error: Argument of type '"address"' is not assignable to parameter of type '"firstName" | "lastName" | "age"'):
// const address = getObjectProperty(person, 'address');
```

### Common Pitfalls & Trade-offs
*   **Over-constraining**: Making generic types too restrictive reduces their reusability. Balance specificity with generality.
*   **Under-constraining**: Not constraining enough can lead to `any` inference or runtime errors because TypeScript can't guarantee the existence of properties/methods.
*   **Confusing with Inheritance**: As mentioned, remember the context distinguishes `extends` for constraints vs. inheritance.
*   **Performance**: Generic constraints primarily impact compile-time type checking, not runtime performance in JavaScript.
*   **Readability**: Complex constraints can sometimes make type signatures harder to read. Use type aliases or interfaces for complex types.

### Interview Questions
1.  **What is the primary purpose of using the `extends` keyword in TypeScript generic constraints?**
    *   **Answer:** Its primary purpose is to define an upper bound for a generic type parameter, ensuring that the type argument supplied to the generic must be assignable to (a subtype of) the constrained type. This guarantees that certain properties or methods are available on the generic type, enabling type-safe operations and better tooling support within the generic context.

2.  **How does `T extends keyof U` differ conceptually from `T extends SomeInterface` when defining generic constraints?**
    *   **Answer:** `T extends SomeInterface` constrains `T` to be a type that satisfies all the properties and methods defined in `SomeInterface`. It's about ensuring `T` has a specific *structure*.
    *   `T extends keyof U` constrains `T` to be a literal string or symbol type that represents one of the property names (keys) of type `U`. It's about ensuring `T` is a *valid property key* for `U`, not about `T` itself having a specific structure.

3.  **Can you provide a practical scenario where generic constraints with `extends` would be crucial for maintaining type safety in a utility function, beyond simple property access?**
    *   **Answer:** Consider a generic `merge` function that combines two objects. Without `extends` constraints, TypeScript might not correctly infer the return type or prevent merging incompatible types. By constraining both input objects to be `object` (or a more specific base interface), and ensuring the return type correctly combines the properties, `extends` guarantees type-safe merging and accurate resulting types. For example, `function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U { ... }` ensures both inputs are objects and the output is a correctly intersected type.

4.  **What happens if you try to access a property on a generic type parameter `T` that is *not* guaranteed by its `extends` constraint?**
    *   **Answer:** TypeScript will produce a compile-time error. For example, if you have `function process<T>(item: T)` and try to access `item.name`, TypeScript will flag an error because `T` is unconstrained and therefore `name` is not guaranteed to exist on `T`. This is precisely why generic constraints (`T extends SomeType`) are used: to tell TypeScript what properties or methods *are* guaranteed to exist, allowing safe access.