---
topic: TypeScript
section: Advanced Types and Generics
subtopic: Indexed Access Types and `keyof`
level: Intermediate
---

## Indexed Access Types and `keyof`
### Core Concepts

*   **`keyof` Type Operator:**
    *   Returns a *union type* of all public property names (keys) of a given type.
    *   Syntactically: `keyof Type`.
    *   Example: `keyof { a: string, b: number }` results in `"a" | "b"`.
    *   Primarily used for constraining generic types to valid property names.

*   **Indexed Access Types:**
    *   Allows you to look up the type of a property on another type using a key.
    *   Syntactically: `Type[Key]`.
    *   Example: `User['name']` returns the type of the `name` property from the `User` type.
    *   The `Key` can be a literal type, a union of literal types, or a generic type parameter constrained by `keyof`.

### Key Details & Nuances

*   **Type Safety:** Both `keyof` and Indexed Access Types are compile-time constructs that provide robust type safety, ensuring operations on object properties are valid according to their defined types.
*   **`keyof` Behavior:**
    *   For object types and interfaces, `keyof` yields a union of string literal types corresponding to their public properties.
    *   For array types (e.g., `keyof any[]`), it returns `number | "length" | "toString" | ...` (numeric indices plus array methods).
    *   For class instances, `keyof` only includes *public* properties and methods; it excludes `private` and `protected` members.
    *   `keyof any` evaluates to `string | number | symbol`.
    *   `keyof unknown` and `keyof void` evaluate to `never`.
*   **Indexed Access Type Behavior:**
    *   Can be nested to access types of deeply nested properties (e.g., `User['address']['street']`).
    *   Supports union types for the key: `Type[Key1 | Key2]` will result in `Type[Key1] | Type[Key2]`.
    *   Commonly used with generics where the key is a type parameter constrained by `keyof`.

### Practical Examples

```typescript
type User = {
    id: number;
    name: string;
    email?: string; // Optional property
    address: {
        street: string;
        city: string;
    };
    readonly createdAt: Date;
};

// 1. Using keyof to get a union of property names
type UserPropertyNames = keyof User; // Type: "id" | "name" | "email" | "address" | "createdAt"

// 2. Using Indexed Access Types to get specific property types
type UserIdType = User["id"]; // Type: number
type UserAddressType = User["address"]; // Type: { street: string; city: string; }
type UserCityType = User["address"]["city"]; // Type: string
type UserEmailType = User["email"]; // Type: string | undefined

// 3. Combining keyof and Indexed Access Types in a generic function
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

const currentUser: User = {
    id: 101,
    name: "Alice Smith",
    address: { street: "123 Main St", city: "Anytown" },
    createdAt: new Date()
};

const userName = getProperty(currentUser, "name"); // userName is inferred as string
const userId = getProperty(currentUser, "id");     // userId is inferred as number
const userAddress = getProperty(currentUser, "address"); // userAddress is inferred as { street: string; city: string; }

// Type safety in action:
// getProperty(currentUser, "age"); // TypeScript error: Argument of type '"age"' is not assignable to parameter of type 'keyof User'.
```

### Common Pitfalls & Trade-offs

*   **Runtime vs. Compile-time:** These types are purely compile-time constructs. While they provide type safety, they do not change JavaScript's runtime behavior. Dynamic property access still relies on the property existing at runtime.
*   **`keyof` on Class Instances and Private/Protected Members:** A common misunderstanding is that `keyof` on a class instance type will include private or protected members. It won't, as it reflects the *publicly accessible* keys.
*   **`keyof any` vs. `keyof unknown`:** `keyof any` (`string | number | symbol`) is often too broad and can hide errors. `keyof unknown` correctly evaluates to `never`, which is safer when dealing with truly unknown types.
*   **Dynamic Keys:** While you can use `keyof` with generic constraints, if the `key` itself is truly dynamic (e.g., from user input), TypeScript's type system can only provide limited safety without runtime validation.

### Interview Questions

1.  **Question:** "Explain the primary difference and relationship between `keyof` and Indexed Access Types in TypeScript. Provide a scenario where you'd typically use them together."
    **Answer:** `keyof` is a type operator that extracts a union of string literal types representing all public property names of a given type. Indexed Access Types (e.g., `Type[Key]`) allow you to look up the type of a specific property within another type using a key. They are typically used together in generic functions to ensure type safety when accessing properties dynamically. For instance, in a `getProperty<T, K extends keyof T>(obj: T, key: K): T[K]` function, `keyof T` constrains `K` to be a valid key of `T`, and `T[K]` ensures the return type matches the property's actual type.

2.  **Question:** "Consider a type `interface Config { port: number; host: string; }`. What would `keyof Config` return, and how would you get the type of `host` using an Indexed Access Type?"
    **Answer:** `keyof Config` would return the union type `"port" | "host"`. To get the type of `host`, you would use `Config["host"]`, which would resolve to `string`.

3.  **Question:** "How does TypeScript's `keyof` operator behave differently for class instances compared to plain object types or interfaces, specifically regarding private or protected members?"
    **Answer:** For plain object types or interfaces, `keyof` includes all declared properties. However, for class instances, `keyof` only returns the names of the *public* properties and methods. It explicitly excludes `private` and `protected` members, aligning with their runtime inaccessibility from outside the class.

4.  **Question:** "You have a generic function `function updateProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) { /* ... */ }`. Explain how the types `K extends keyof T` and `T[K]` ensure type safety in this function signature."
    **Answer:** `K extends keyof T` ensures that the `key` parameter *must* be a valid property name (a string literal from the union of keys) of the `obj` parameter. This prevents passing non-existent keys. `value: T[K]` then dictates that the `value` parameter's type *must* exactly match the type of the property identified by `key` on the object `T`. Together, these two constraints guarantee that you can only update an existing property with a value of the correct type, enforcing strong type checking at compile-time.