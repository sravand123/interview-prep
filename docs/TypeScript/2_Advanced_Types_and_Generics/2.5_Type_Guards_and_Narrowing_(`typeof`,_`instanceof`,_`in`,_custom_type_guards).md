---
topic: TypeScript
section: Advanced Types and Generics
subtopic: Type Guards and Narrowing (`typeof`, `instanceof`, `in`, custom type guards)
level: Intermediate
---

## Type Guards and Narrowing (`typeof`, `instanceof`, `in`, custom type guards)
### Core Concepts
*   **Type Guards (or Type Narrowing):** A TypeScript feature that allows you to narrow down the type of a variable within a conditional block (e.g., `if`/`else`, `switch`, `try`/`catch`).
*   **Purpose:** To inform the TypeScript compiler about a more specific type for a variable, enabling safer property access and method calls without requiring type assertions (`as Type`). This leverages TypeScript's **Control Flow Analysis**.

### Key Details & Nuances
*   **`typeof` Type Guard:**
    *   Checks the JavaScript runtime type of a value.
    *   **Applicable for:** Primitive types (`string`, `number`, `boolean`, `symbol`, ``bigint``, `undefined`, `function`, `object`).
    *   **Nuance:** `typeof null` returns `"object"`, which can be a common pitfall. Always check for `null` explicitly or use `!value` for truthiness checks.
    *   **Example:** `if (typeof value === 'string') { /* value is string */ }`

*   **`instanceof` Type Guard:**
    *   Checks if an object is an instance of a specific class.
    *   **Applicable for:** Classes (constructors).
    *   **Nuance:** Works with inheritance. If `Dog extends Animal`, `dog instanceof Animal` is true.
    *   **Example:** `if (obj instanceof MyClass) { /* obj is MyClass */ }`

*   **`in` Operator Type Guard:**
    *   Checks if a property exists on an object.
    *   **Applicable for:** Objects, especially useful with union types that have distinct properties.
    *   **Nuance:** Does not check the value of the property, only its presence. Can be used for "discriminated unions" where a common property helps distinguish types.
    *   **Example:** `if ('propertyName' in obj) { /* obj has propertyName */ }`

*   **Custom Type Guards (User-Defined Type Guards):**
    *   Functions that return a boolean and have a special **type predicate** return signature: `parameterName is Type`.
    *   **Purpose:** To define custom logic for narrowing types when `typeof`, `instanceof`, or `in` are insufficient (e.g., checking specific property values, structural checks).
    *   **Declaration:** `function isMyType(value: any): value is MyType { ... }`
    *   **Usage:** When `isMyType(variable)` returns `true`, TypeScript treats `variable` as `MyType` within that scope.
    *   **Nuance:** The type predicate is crucial; without it, TypeScript only knows the function returns `boolean`, not that it narrows a type.

*   **Control Flow Analysis:** TypeScript statically analyzes code execution paths (`if`/`else`, loops, `switch`, `try`/`catch`) to automatically infer and narrow types based on conditional checks. This is the underlying mechanism that makes all type guards effective.

### Practical Examples

```typescript
// --- Defining types for demonstration ---
interface Circle {
    kind: "circle";
    radius: number;
}

interface Square {
    kind: "square";
    sideLength: number;
    color?: string; // Optional property
}

class Triangle {
    constructor(public base: number, public height: number) {}
}

type Shape = Circle | Square | Triangle | string | number | null;

// --- Custom Type Guard ---
function isTriangle(shape: any): shape is Triangle {
    // A robust check might include `typeof shape === 'object' && shape !== null`
    return shape instanceof Triangle;
}

function isSquare(shape: any): shape is Square {
    // Check for discriminator 'kind' and specific property 'sideLength'
    return typeof shape === 'object' && shape !== null && 'kind' in shape && shape.kind === 'square';
}

// --- Function demonstrating various type guards and narrowing ---
function getShapeInfo(shape: Shape) {
    // 1. typeof guard
    if (typeof shape === 'string') {
        console.log(`It's a string: "${shape.toUpperCase()}"`); // shape is string
        return;
    }

    if (typeof shape === 'number') {
        console.log(`It's a number: ${shape.toFixed(2)}`); // shape is number
        return;
    }

    // Handle null explicitly due to typeof null === 'object'
    if (shape === null) {
        console.log("It's null.");
        return;
    }

    // At this point, shape is Circle | Square | Triangle

    // 2. instanceof guard (using custom type guard function for clarity)
    if (isTriangle(shape)) {
        console.log(`It's a Triangle with base ${shape.base} and height ${shape.height}.`); // shape is Triangle
        return;
    }

    // 3. 'in' operator guard and discriminated union narrowing
    // We already know shape is not Triangle, string, number, or null
    if (shape.kind === 'circle') { // shape is narrowed to Circle based on 'kind' property
        console.log(`It's a Circle with radius ${shape.radius}.`); // shape is Circle
        return;
    }

    // Now, by exclusion, shape must be Square (or we've missed a type)
    if (isSquare(shape)) { // Using custom type guard for Square
        console.log(`It's a Square with side length ${shape.sideLength}.`); // shape is Square
        if ('color' in shape && shape.color) { // 'in' operator for optional property
            console.log(`  And its color is: ${shape.color}`);
        }
        return;
    }

    // Fallback for unexpected types (should not be reached if all unions are covered)
    console.log("Unknown shape or type:", shape);
}

// --- Testing the function ---
getShapeInfo("hello world");
getShapeInfo(123.456);
getShapeInfo(new Triangle(5, 10));
getShapeInfo({ kind: "circle", radius: 7 });
getShapeInfo({ kind: "square", sideLength: 4, color: "red" });
getShapeInfo({ kind: "square", sideLength: 3 });
getShapeInfo(null);
// getShapeInfo({ unknownProp: true }); // TS Error: Argument of type '{ unknownProp: boolean; }' is not assignable to parameter of type 'Shape'.
```

### Common Pitfalls & Trade-offs
*   **`typeof null === 'object'`:** A classic JavaScript quirk. Always explicitly check for `null` if you need to differentiate objects from `null`.
*   **Misunderstanding `in` vs. Property Access:** `in` checks for existence (including inherited properties), `obj.prop !== undefined` checks for a defined value (but doesn't work for properties that *are* `undefined`). `in` is safer for discriminated unions.
*   **Over-reliance on `any`:** Bypasses type checking and the benefits of narrowing. Prefer type guards and unions.
*   **Complex Nested Logic:** While powerful, deeply nested `if` statements with type guards can become hard to read and maintain. Consider refactoring with helper functions (custom type guards) or using patterns like discriminated unions.
*   **Type Guard Performance:** Type guards themselves are minimal runtime overhead (simple checks). The benefit is compile-time safety; they do not significantly impact runtime performance compared to the operations they enable.

### Interview Questions
1.  **Explain the difference between `typeof` and `instanceof` type guards. When would you choose one over the other?**
    *   **Answer:** `typeof` checks the *runtime primitive type* (string, number, boolean, symbol, bigint, undefined, function, object). It's best for basic primitive value checks. `instanceof` checks if an object is an *instance of a specific class or constructor function* in its prototype chain. It's used for distinguishing between different class instances or inherited types. You choose `typeof` for primitives and `instanceof` for objects that are instances of classes.
2.  **How do custom type guards work, and why are they essential for complex type hierarchies? Provide a scenario where you'd definitely need one.**
    *   **Answer:** Custom type guards are functions with a special "type predicate" return signature (e.g., `value is MyType`). This predicate tells TypeScript that if the function returns `true`, the `value` parameter can be narrowed to `MyType` within the scope. They are essential when `typeof`, `instanceof`, or `in` are insufficient, such as when you need to check specific property values, call methods, or perform complex structural validation. A scenario is validating a JSON object fetched from an API against a complex interface that isn't a class instance, where you need to ensure specific nested properties or a combination of values are present and correct before safely using the object.
3.  **Describe a scenario where the `in` operator would be the most suitable type guard. How does it compare to checking `object.property !== undefined`?**
    *   **Answer:** The `in` operator is most suitable for distinguishing between members of a union type where each member has a *distinct, unique property* (a "discriminator"), or when checking for the mere *existence* of a property, including those with `undefined` values. For example, in a union `type Result = { success: true; data: any; } | { success: false; error: string; }`, checking `if ('success' in result)` or `if (result.success)` is effective. It compares to `object.property !== undefined` by being more robust: `in` checks if the property *exists* on the object (or its prototype chain), whereas `object.property !== undefined` only checks if the property's *value is not `undefined`*. If `object.property` legitimately holds `undefined` as a value, the latter check would incorrectly narrow the type.
4.  **Beyond the built-in guards, what is TypeScript's control flow analysis and how does it relate to narrowing?**
    *   **Answer:** Control flow analysis (CFA) is TypeScript's powerful static analysis engine that examines the execution path of your code. It tracks variable assignments, conditional statements (`if`/`else`, `switch`, `try`/`catch`), loops, and returns, using this information to infer and refine the types of variables at different points in your code. Type guards are special constructs that CFA understands; when a type guard is applied within a conditional, CFA knows to narrow the type of the variable within that specific code block, effectively "knowing" that `value` is now a `string` after `if (typeof value === 'string')`. This allows for type-safe operations without explicit casting.
5.  **Discuss the benefits of discriminated unions and how type guards facilitate working with them.**
    *   **Answer:** Discriminated unions are a powerful pattern where a union type consists of several object types, and each object type shares a common, literal property (the "discriminator") that has a unique string or number literal value for each member of the union. The benefit is type safety and exhaustive checking; TypeScript can use the discriminator property to precisely narrow down the type of the object. Type guards (especially the `in` operator or direct property access `if (obj.kind === 'foo')`) are crucial for working with discriminated unions, as they allow TypeScript's control flow analysis to automatically infer the specific type within conditional blocks, providing strong type checking and enabling the compiler to flag cases where all union members haven't been handled (e.g., in a `switch` statement without a `default` or an `assertNever` check).