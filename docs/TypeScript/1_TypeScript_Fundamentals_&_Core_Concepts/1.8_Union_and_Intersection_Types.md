---
topic: TypeScript
section: TypeScript Fundamentals & Core Concepts
subtopic: Union and Intersection Types
level: Beginner
---

## Union and Intersection Types
### Core Concepts

*   **Union Types (`|`)**:
    *   Represents a value that can be *one of several types*. It's an "OR" relationship.
    *   Syntax: `TypeA | TypeB | TypeC`.
    *   Purpose: Provides flexibility by allowing a variable or parameter to accept different data shapes or types, enhancing type safety in scenarios where data can vary.
    *   Example: `string | number` means a variable can hold either a string or a number.

*   **Intersection Types (`&`)**:
    *   Represents a type that combines *all properties of multiple types* into a single new type. It's an "AND" relationship.
    *   Syntax: `TypeA & TypeB & TypeC`.
    *   Purpose: Enables composition of types by merging existing ones, useful for creating complex types from simpler building blocks or for mixins.
    *   Example: `Person & Employee` means an object must have all properties from `Person` and all properties from `Employee`.

### Key Details & Nuances

*   **Union Type Behavior**:
    *   **Common Properties**: When accessing properties of a union type, TypeScript only allows access to properties that are common to *all* types in the union without explicit narrowing.
    *   **Type Narrowing**: To access type-specific properties, you *must* use type guards (e.g., `typeof`, `instanceof`, `in` operator, user-defined type guards `is`) to narrow down the type within a specific code block. This is crucial for runtime safety.

*   **Intersection Type Behavior**:
    *   **Property Combination**: All non-conflicting properties from intersected types are combined into the new type.
    *   **Conflicting Properties**:
        *   **Same Primitive Property, Different Types**: If two intersected types have a property with the same name but different primitive types (e.g., `id: string` and `id: number`), the resulting type for that property becomes `never`. This means no value can ever satisfy this type.
        *   **Same Non-Primitive Property, Different Types**: If they have the same property name with object types, TypeScript tries to combine them recursively as an intersection. This can lead to complex or `never` types if deeply nested structures conflict.
        *   **Same Property, Same Type**: No conflict, the property is included.

### Practical Examples

```typescript
// --- Union Type Example with Narrowing ---

type Result = { success: true; data: string } | { success: false; error: Error };

function handleResult(res: Result) {
    if (res.success) {
        // TypeScript narrows 'res' to { success: true; data: string }
        console.log("Success:", res.data); // 'data' is accessible
    } else {
        // TypeScript narrows 'res' to { success: false; error: Error }
        console.error("Error:", res.error.message); // 'error' is accessible
    }
}

handleResult({ success: true, data: "Operation completed." });
handleResult({ success: false, error: new Error("Failed to load data.") });

// --- Intersection Type Example ---

interface HasId {
    id: string;
}

interface HasName {
    name: string;
}

interface HasEmail {
    email: string;
}

// UserProfile is an intersection of HasId, HasName, and HasEmail
type UserProfile = HasId & HasName & HasEmail;

const user: UserProfile = {
    id: "uuid-123",
    name: "Alice Smith",
    email: "alice@example.com",
};

console.log(user.id, user.name, user.email);

// --- Intersection Type with conflicting primitive property (results in 'never') ---
type TypeA = { value: string };
type TypeB = { value: number };

type ConflictingType = TypeA & TypeB; // 'value' here becomes 'string & number' which is 'never'

// const badValue: ConflictingType = { value: "hello" }; // Error: Type 'string' is not assignable to type 'never'.
// const badValue2: ConflictingType = { value: 123 }; // Error: Type 'number' is not assignable to type 'never'.

// This type can only be satisfied if 'value' is both a string AND a number, which is impossible.
```

### Common Pitfalls & Trade-offs

*   **Forgetting Union Type Narrowing**: A very common mistake is trying to access properties that are not common across all union members without first narrowing the type, leading to compilation errors. Always anticipate runtime types for unions.
*   **Conflicting Properties in Intersections**: Unintentionally creating `never` types when intersecting types with same-named primitive properties but different types. This makes the resulting type impossible to instantiate. Be aware of how TypeScript resolves property conflicts.
*   **Union vs. Polymorphism/Interfaces**: Sometimes a union type (`Cat | Dog`) can achieve similar flexibility to an interface with multiple implementations (e.g., `interface Animal { makeSound(): void; }` with `Cat` and `Dog` implementing `Animal`). The choice depends on whether you're modeling distinct, unrelated types (union) or types that share a common contract/behavior (interface/polymorphism).
*   **Intersection vs. Interface Extension (`extends`)**:
    *   `extends` implies an "is-a" relationship (inheritance), where the extending interface adds to or overrides properties of the base interface. It's often used for hierarchical type definitions.
    *   Intersection (`&`) implies a "has-a" relationship (composition), combining independent type definitions. It's more flexible for combining disparate features without creating an inheritance hierarchy. Use `&` for mixins or combining orthogonal concerns.

### Interview Questions

1.  **Explain the difference between a union type and an intersection type in TypeScript, providing a scenario where each would be appropriate.**
    *   **Answer**: A union type (`A | B`) represents a value that can be *either* type `A` *or* type `B`. It allows flexibility, like a function parameter accepting `string | number`. An intersection type (`A & B`) represents a type that has *all properties* of both `A` *and* `B` combined. It's for composition, like creating a `SuperUser` type that has all properties of `User` and `Admin`.

2.  **When working with union types, how do you safely access properties that are not common to all types in the union? Illustrate with an example.**
    *   **Answer**: You must use **type narrowing (or type guards)**. TypeScript's control flow analysis infers the specific type within conditional blocks. Common type guards include `typeof` (for primitives), `instanceof` (for classes), the `in` operator (for property existence), or custom user-defined type guards (`is` keyword).
    *   *Example (see practical examples section above for `handleResult` function):* Using `if (res.success)` narrows the `res` type, allowing access to `res.data` or `res.error`.

3.  **What happens if you intersect two types that have a property with the same name but different primitive types (e.g., `string` and `number`)? What about if they are object types?**
    *   **Answer**: If intersecting types have a property with the same name but different primitive types (e.g., `type A = { id: string } & { id: number }`), the resulting type for that property becomes `never`. This is because no value can simultaneously be both a `string` and a `number`. If they are object types, TypeScript attempts to recursively intersect those object types. For example, `type A = { config: { timeout: number } } & { config: { retries: number } }` would result in `config: { timeout: number; retries: number; }`. However, if the nested object types also have conflicting primitive properties, that conflict would then result in `never` for that nested property.

4.  **Compare and contrast extending an `interface` with using an intersection type. When would you prefer one over the other?**
    *   **Answer**:
        *   **`interface extends`**: Establishes an "is-a" relationship (inheritance). An extending interface adds to or overrides members of the base interface. It's suitable for creating hierarchies or refining an existing type. Preferred when you want to model a subtype or enforce a common contract.
        *   **Intersection (`&`)**: Establishes a "has-a" relationship (composition). It merges properties from multiple independent types into a new, combined type. It's suitable for combining orthogonal concerns or creating mixins. Preferred when you want to compose a new type from existing, unrelated parts without implying an inheritance hierarchy, or when working with type aliases.