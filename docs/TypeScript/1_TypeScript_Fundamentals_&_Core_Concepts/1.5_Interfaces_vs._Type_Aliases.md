---
topic: TypeScript
section: TypeScript Fundamentals & Core Concepts
subtopic: Interfaces vs. Type Aliases
level: Beginner
---

## Interfaces vs. Type Aliases
### Core Concepts
*   **Interfaces**: Primarily used to **define the shape of an object**. They act as contracts that objects or classes must adhere to. They are a core part of TypeScript's structural type system and are often preferred for defining public APIs.
*   **Type Aliases**: Used to **create a new name for any type**. This includes primitive types, union types, intersection types, tuple types, function types, and object types. They are more versatile for composing complex types.

### Key Details & Nuances
*   **Declaration Merging**:
    *   **Interfaces**: Support **declaration merging**. If you declare the same interface multiple times in the same scope, TypeScript will merge their members into a single interface. This is crucial for extending existing type definitions (e.g., augmenting global types, adding properties to a `Window` object).
    *   **Type Aliases**: **Do not support declaration merging**. A type alias can only be defined once in a given scope. Redeclaring it will result in an error.
*   **Extending vs. Intersecting**:
    *   **Interfaces**: Use the `extends` keyword to inherit members from other interfaces. This is idiomatic for an object-oriented "inheritance" pattern.
        ```typescript
        interface Person { name: string; }
        interface Employee extends Person { employeeId: number; }
        ```
    *   **Type Aliases**: Use the `&` (intersection) operator to combine types. This is more akin to "composition" of types.
        ```typescript
        type PersonType = { name: string; };
        type EmployeeType = PersonType & { employeeId: number; };
        ```
*   **Class Implementation**:
    *   **Interfaces**: Classes can `implement` interfaces, ensuring they adhere to the interface's contract. This is a common pattern in object-oriented design.
    *   **Type Aliases**: Classes can `implement` a type alias *if* that type alias defines an object literal type (e.g., `type MyType = { prop: string; }`). However, this is less common and interfaces are generally preferred for this explicit contract. Classes cannot implement type aliases for primitives, unions, or intersections of primitives.
*   **Representing Non-Object Types**:
    *   **Interfaces**: Can **only describe object shapes** (including callable and constructable types). They cannot be used for primitives, unions, or tuples directly.
    *   **Type Aliases**: Can **represent any type**, including primitives (`type ID = string;`), unions (`type Status = "active" | "inactive";`), intersections, and tuples (`type Coords = [number, number];`).

### Practical Examples

```typescript
// --- Interfaces ---

// 1. Defining an object shape
interface User {
  id: number;
  name: string;
}

// 2. Extending an interface
interface Admin extends User {
  role: 'admin';
  permissions: string[];
}

// 3. Declaration Merging (demonstrates a key interface feature)
interface Config {
  apiUrl: string;
}

interface Config { // TypeScript merges this with the above Config
  timeout: number;
}

const appConfig: Config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000 // 'timeout' is now part of Config due to merging
};

// 4. Class implementing an interface
class CustomerService implements User {
  constructor(public id: number, public name: string) {}
  greet() { return `Hello, ${this.name}`; }
}


// --- Type Aliases ---

// 1. Aliasing a primitive type
type UserID = string;
let userId: UserID = "abc-123";

// 2. Defining a union type
type APIStatus = "success" | "error" | "pending";
let status: APIStatus = "success";

// 3. Defining an object shape (similar to interface)
type Product = {
  productId: number;
  productName: string;
  price: number;
};

// 4. Intersecting types (composition)
type Purchasable = {
  quantity: number;
};
type OrderItem = Product & Purchasable; // Combines properties of Product and Purchasable

const item: OrderItem = {
  productId: 1,
  productName: "Laptop",
  price: 1200,
  quantity: 1
};

// 5. Defining a tuple type
type Coordinates = [number, number, number];
const myLocation: Coordinates = [10, 20, 30];
```

### Common Pitfalls & Trade-offs
*   **Indiscriminate Usage**: New developers often use `type` for everything because it's more flexible. While generally fine, it misses opportunities for better expressiveness or leveraging `declaration merging` when interfaces are more suitable.
*   **Confusion between `extends` and `&`**: `extends` is for inheritance (primarily with interfaces), while `&` is for composition (combining properties from multiple types, often used with type aliases). They achieve similar results for object shapes but reflect different design philosophies.
*   **When to choose**:
    *   **Use `interface` when**:
        *   Defining object shapes that might be `implemented` by classes.
        *   You need `declaration merging` (e.g., for library augmentation, adding properties to global objects).
        *   You're defining public APIs where explicit contracts are beneficial.
    *   **Use `type` alias when**:
        *   You need to alias primitive, union, intersection, or tuple types.
        *   You need to define complex types using combinations of existing types in a more functional, compositional way.
        *   You want a short, readable name for a complex type expression.

### Interview Questions
1.  **When would you *definitely* choose an `interface` over a `type` alias in TypeScript?**
    *   **Answer**: The primary reason to *definitely* choose an `interface` is for **declaration merging**. This allows you to define the same interface multiple times, and TypeScript will combine them into a single definition. This is invaluable for augmenting existing library types or global objects (e.g., adding properties to `Window`). Additionally, when a class needs to `implement` a contract, `interface` is the idiomatic and clearer choice.
2.  **When would you *definitely* choose a `type` alias over an `interface`?**
    *   **Answer**: You must use a `type` alias when you need to define a type that is **not an object shape**. This includes aliasing primitive types (e.g., `type ID = string`), union types (e.g., `type Status = "success" | "error"`), intersection types that combine non-object types, or tuple types (e.g., `type Coords = [number, number]`). Interfaces cannot represent these kinds of types directly.
3.  **Explain the concept of "declaration merging" in TypeScript and how it applies to `interface` and `type` aliases.**
    *   **Answer**: Declaration merging is a TypeScript feature where the compiler merges two or more separate declarations with the same name into a single definition. This is a core feature for **interfaces** and namespaces. For interfaces, if you declare two interfaces with the same name, their members are combined. This is incredibly useful for extending existing types (e.g., adding a custom property to `window.myApp` by redeclaring the `Window` interface). **Type aliases, however, do not support declaration merging**; redeclaring a type alias with the same name will result in a compile-time error.
4.  **Can a class `implement` a `type` alias? Explain the nuances.**
    *   **Answer**: Yes, a class can `implement` a `type` alias, but *only if* that type alias defines an object literal type (e.g., `type MyType = { method: () => void; }`). In such a case, the type alias behaves similarly to an interface in terms of enforcing a contract on the class. However, classes **cannot implement** type aliases that represent primitive types, union types, or intersection types that do not resolve to a clear object shape. Interfaces are the idiomatic and generally preferred choice for defining class contracts due to their explicit purpose and `implements` keyword synergy.
5.  **Describe a scenario where using `&` (intersection type) with a `type` alias would be more appropriate or clearer than using `extends` with an `interface`.**
    *   **Answer**: Intersection types (`&`) with type aliases are often more appropriate when you want to **compose types in a flexible, non-hierarchical way**, especially when dealing with unions or non-object types. For example, if you have `type Logger = { log: (msg: string) => void; }` and `type ErrorHandler = { handleError: (err: Error) => void; }`, you could create a `type Service = Logger & ErrorHandler;`. This composition explicitly states that a `Service` has *both* logging and error-handling capabilities without implying an inheritance relationship, which `extends` would. It's particularly powerful when combining types that don't inherently share a "is-a" relationship but rather a "has-a" relationship of capabilities.