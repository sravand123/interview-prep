---
topic: TypeScript
section: TypeScript Fundamentals & Core Concepts
subtopic: Basic Types: `string`, `number`, `boolean`, `null`, `undefined`, `any`, `unknown`, `void`, `never`
level: Beginner
---

## Basic Types: `string`, `number`, `boolean`, `null`, `undefined`, `any`, `unknown`, `void`, `never`
### Core Concepts

*   **Primitive Types:**
    *   `string`: Textual data (e.g., `"hello"`, `'world'`).
    *   `number`: Numeric data (integers, floats, `NaN`, `Infinity`). TypeScript numbers are floating-point like JavaScript.
    *   `boolean`: Logical values (`true` or `false`).
*   **Absence of Value:**
    *   `null`: Represents an intentional absence of any object value.
    *   `undefined`: Represents a variable that has been declared but not yet assigned a value, a missing object property, or an unprovided function argument.
*   **Special Types for Flexibility & Safety:**
    *   `any`: Opt-out of type checking. A variable of type `any` can hold any value, and you can perform any operation on it without compile-time errors.
    *   `unknown`: A type-safe counterpart to `any`. A variable of type `unknown` can hold any value, but you *must* narrow its type (e.g., using type guards) before performing operations on it.
    *   `void`: Represents the absence of a return value for a function.
    *   `never`: Represents the type of values that never occur. This is typically used for functions that never return (e.g., always throw an error, infinite loop) or for values that make a code path unreachable (exhaustive checking).

### Key Details & Nuances

*   **`strictNullChecks` Compiler Option:**
    *   **Critical:** When enabled (highly recommended), `null` and `undefined` are not implicitly assignable to other types (`string`, `number`, etc.). This forces explicit handling of null/undefined possibilities (e.g., `string | null`, optional chaining `?.`), preventing common runtime errors.
    *   Without it, `null` and `undefined` are assignable to `any` type, which can lead to runtime issues.
*   **`any` vs. `unknown`:**
    *   `any`: Provides maximum flexibility but sacrifices all type safety. Use sparingly for migrating JS projects or highly dynamic data with known risks.
    *   `unknown`: Provides maximum type safety for values of uncertain type. Forces developers to explicitly check and narrow the type before use, making code more robust and predictable. Prefer `unknown` over `any` when dealing with external, untyped data (e.g., API responses).
*   **`void` vs. `undefined` Return Types:**
    *   `void` indicates a function's return value should be ignored. It's a *type*.
    *   `undefined` is an *actual value*. A function can explicitly `return undefined;`, in which case its return type is `undefined`, not `void`. A function declared as `(): void` *can* implicitly return `undefined`, but its *type* is `void`.
*   **`never` Use Cases:**
    *   **Functions that never return:** E.g., `function foo(): never { throw new Error(); }` or `function bar(): never { while(true) {} }`.
    *   **Exhaustive Type Checking:** Used in `switch` statements or conditional types to ensure all possible cases of a union type are handled. If a new case is introduced to the union and not handled, TypeScript will flag the `never` branch as unreachable, ensuring type safety.
*   **Type Inference:** TypeScript automatically infers the most specific type for a variable based on its initial value if no explicit type annotation is provided (e.g., `let count = 10;` infers `count` as `number`). This reduces boilerplate while maintaining type safety.

### Practical Examples

```typescript
// --- Basic Types ---
let productName: string = "Laptop";
let price: number = 1200.50;
let inStock: boolean = true;
let discount: null = null; // Explicitly null
let shippingAddress: undefined; // Declared but not assigned, type is undefined

// --- 'any' vs 'unknown' ---
let dataFromAPI: any = JSON.parse('{"id": 1, "name": "Test"}');
console.log(dataFromAPI.name); // OK at compile time, potential runtime error if 'name' doesn't exist

let unknownPayload: unknown = JSON.parse('{"status": "success", "value": 123}');
// console.log(unknownPayload.value); // Error: Object is of type 'unknown'.

if (typeof unknownPayload === 'object' && unknownPayload !== null && 'value' in unknownPayload) {
  // Type is narrowed to { value: unknown, ... }
  const val = (unknownPayload as { value: unknown }).value; 
  if (typeof val === 'number') {
    console.log(`Value is a number: ${val.toFixed(2)}`); // OK, type narrowed to number
  }
}

// --- 'void' ---
function greetUser(name: string): void {
  console.log(`Hello, ${name}!`);
  // return "something"; // Error: Type 'string' is not assignable to type 'void'.
}
greetUser("Alice");

// --- 'never' ---
function raiseError(message: string): never {
  throw new Error(message);
}

// Function that never completes (infinite loop)
function infiniteProcess(): never {
  while (true) {
    // ... do something forever ...
  }
}

// Exhaustive checking with 'never'
type Status = 'success' | 'failure' | 'pending';

function handleStatus(status: Status): string {
  switch (status) {
    case 'success':
      return "Operation successful.";
    case 'failure':
      return "Operation failed.";
    case 'pending':
      return "Operation is pending.";
    default:
      // This line ensures all 'Status' types are handled.
      // If a new 'Status' is added (e.g., 'aborted') and not handled above,
      // TypeScript will error here because 'status' could be 'aborted', not 'never'.
      const exhaustiveCheck: never = status; 
      throw new Error(`Unhandled status: ${exhaustiveCheck}`);
  }
}
```

### Common Pitfalls & Trade-offs

*   **Overuse of `any`**: The most common pitfall. While convenient for quick coding, it defeats the purpose of TypeScript, hides bugs until runtime, makes refactoring difficult, and hampers tooling support. **Trade-off:** Faster initial development vs. long-term maintainability, bug prevention, and code robustness.
*   **Ignoring `strictNullChecks`**: Not enabling this compiler option (which is `false` by default in some older `tsconfig.json` setups) leads to `null` and `undefined` values propagating unchecked, resulting in common runtime `TypeError` issues often seen in plain JavaScript.
*   **Confusing `void` and `undefined` Return Types**: Misunderstanding that `void` is a type indicating *no meaningful return*, while `undefined` is an *actual value*. A function explicitly returning `undefined` has a return type of `undefined`, not `void`.
*   **Not Leveraging `unknown` for External Data**: When consuming data from external sources (APIs, user input), using `any` is risky. Failing to use `unknown` and apply appropriate type guards means foregoing crucial type safety exactly where it's needed most. **Trade-off:** More explicit type narrowing code vs. significantly reduced runtime errors from unexpected data.
*   **Misunderstanding `never`**: It's not just "a function that doesn't return anything" (that's `void`). `never` implies that the function *cannot possibly* return, or that a code path is fundamentally unreachable.

### Interview Questions

1.  **Question:** Explain the primary differences and use cases for `any` and `unknown` in TypeScript. When would you choose one over the other?
    **Answer:** `any` allows you to completely opt out of TypeScript's type checking for a variable, letting you perform any operation on it without compile-time errors. It's useful for quick migrations or highly dynamic libraries where types are genuinely unknown. `unknown`, conversely, is a type-safe `any`. While it can hold any value, you *must* explicitly narrow its type using type guards (`typeof`, `instanceof`, `if` checks, or type assertions) before performing operations. You should choose `unknown` when dealing with data of uncertain origin (e.g., API responses, user input) to ensure robust type checking and prevent runtime errors, reserving `any` for cases where type safety is genuinely impractical or during early migration phases.

2.  **Question:** In TypeScript, what's the difference between `null` and `undefined`? How does the `strictNullChecks` compiler option affect their usage?
    **Answer:** `undefined` typically indicates a variable that has been declared but not assigned a value, a missing property on an object, or a function parameter that wasn't provided. `null` represents an *intentional absence* of any object value. With `strictNullChecks` enabled (which is highly recommended), `null` and `undefined` are not automatically assignable to other types (like `string` or `number`). This forces developers to explicitly handle their potential presence (e.g., by using union types like `string | null | undefined` or optional chaining `?.`), which significantly reduces the risk of common runtime null/undefined reference errors.

3.  **Question:** Describe scenarios where `void` and `never` would be the appropriate return types for a function.
    **Answer:** `void` is used when a function performs an action but does not return any meaningful value that should be used by the caller. Examples include functions that print to the console (`console.log`), modify a DOM element, or trigger a side effect without producing a result. `never` is used when a function *literally cannot return*â€”it either always throws an error (e.g., `function handleError(): never { throw new Error(); }`), enters an infinite loop (`function endlessLoop(): never { while(true) {} }`), or is part of an exhaustive type check ensuring all cases of a union have been handled (making a code path truly unreachable).

4.  **Question:** When processing data received from an external API, you encounter a field that could legitimately be a `string`, `number`, or sometimes even missing. How would you type and safely handle such a field in TypeScript?
    **Answer:** I would type the field using a union type that includes `string`, `number`, and `undefined` (or `null` if the API might return `null`), for example: `dataField?: string | number;`. To safely handle it, I would first check for its existence (`if (data.dataField !== undefined)`) and then use type guards (`typeof`) to narrow its type before performing operations specific to `string` or `number`:
    ```typescript
    interface ApiResponse {
      dataField?: string | number;
    }

    function processData(response: ApiResponse) {
      if (response.dataField !== undefined) {
        if (typeof response.dataField === 'string') {
          console.log("String data:", response.dataField.toUpperCase());
        } else if (typeof response.dataField === 'number') {
          console.log("Number data:", response.dataField.toFixed(2));
        } else {
          // This 'else' should theoretically be unreachable if the type is exactly string | number | undefined,
          // but can catch unexpected types if the actual data deviates.
          const unhandled: never = response.dataField; // Triggers TS error if type isn't narrowed to never
          console.error("Unexpected type for dataField:", unhandled);
        }
      } else {
        console.log("dataField is missing.");
      }
    }
    ```