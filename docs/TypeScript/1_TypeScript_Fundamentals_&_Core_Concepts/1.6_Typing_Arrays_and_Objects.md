---
topic: TypeScript
section: TypeScript Fundamentals & Core Concepts
subtopic: Typing Arrays and Objects
level: Beginner
---

## Typing Arrays and Objects
### Core Concepts
*   **Type Annotation:** Explicitly defining the expected data type for variables, function parameters, and return values. For arrays and objects, this involves specifying the type of elements/values they contain or their structural shape.
*   **Arrays:** Represent ordered collections of elements. In TypeScript, arrays are typically homogeneous, meaning all elements are of the same declared type.
*   **Objects:** Represent collections of key-value pairs, where keys are usually strings (or symbols) and values can be any type. TypeScript allows defining the expected `shape` of an object, including its properties and their types, and whether they are optional.

### Key Details & Nuances
*   **Array Typing Syntax:**
    *   **Type[] (Shorthand):** `string[]` for an array of strings. Most common and concise.
    *   **Array<Type> (Generic):** `Array<number>` for an array of numbers. Explicitly uses the generic `Array` interface.
*   **Tuple Types:**
    *   Arrays with a fixed number of elements whose types are known at specific positions.
    *   Syntax: `[type1, type2, ..., typeN]`. Enforces order and length.
    *   Useful for representing fixed-size records (e.g., `[string, number]` for `[name, age]`).
*   **`readonly` Arrays:**
    *   `readonly string[]` or `ReadonlyArray<number>`.
    *   Indicates that array elements cannot be added, removed, or modified after initialization.
    *   Compile-time check; runtime JS array operations still exist but TS prevents their use on `readonly` arrays.
*   **Object Typing Methods:**
    *   **Inline Type Annotation:** Directly specifies the object's shape when declaring a variable (e.g., `{ name: string, age: number }`). Good for simple, one-off types.
    *   **`interface`:** Defines a named type for an object's shape.
        *   Supports `extends` for inheritance and `implements` for classes.
        *   Supports "declaration merging" (multiple interfaces with the same name are merged).
        *   Preferred for defining public APIs or complex object shapes.
    *   **`type` alias:** Defines a named alias for any type, including object shapes.
        *   More versatile than `interface`; can alias primitives, union types, intersection types, tuples, etc.
        *   Supports intersection (`&`) for combining types.
        *   Cannot be `implements` by classes directly (only the resulting object shape). No declaration merging.
    *   **Optional Properties:** Use `propertyName?: Type` to indicate a property may or may not exist on the object.
    *   **Index Signatures:** `[key: string]: Type` allows defining the type for properties whose names are not known beforehand but whose values share a common type. Useful for dictionaries or hash maps.
*   **Structural Typing:** TypeScript is a structurally typed language. Two types are compatible if their members are compatible, regardless of their nominal names. This applies heavily to objects: if an object has all the required properties of an interface/type, it's considered compatible.

### Practical Examples

```typescript
// --- Array Typing ---
// Shorthand syntax
const names: string[] = ["Alice", "Bob", "Charlie"];
console.log(names);

// Generic Array type
const ages: Array<number> = [25, 30, 22];
console.log(ages);

// Readonly Array
const immutableNumbers: readonly number[] = [1, 2, 3];
// immutableNumbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'.
console.log(immutableNumbers);

// Tuple Type
const userTuple: [number, string, boolean] = [101, "Alice", true];
// userTuple = [102, "Bob"]; // Error: Source has 2 elements, but target requires 3.
console.log(userTuple);

// --- Object Typing ---
// Inline Object Type
const employee: { id: number; name: string; email?: string } = {
  id: 1,
  name: "John Doe",
};
console.log(employee);

// Using Interface
interface Product {
  id: number;
  name: string;
  price: number;
  description?: string; // Optional property
}

const laptop: Product = {
  id: 101,
  name: "Gaming Laptop",
  price: 1200,
};
console.log(laptop);

// Using Type Alias
type User = {
  id: number;
  username: string;
  isActive: boolean;
};

const newUser: User = {
  id: 201,
  username: "user123",
  isActive: true,
};
console.log(newUser);

// Object with Index Signature (Dictionary-like)
interface StringMap {
  [key: string]: string; // Keys are strings, values are strings
}

const translations: StringMap = {
  hello: "Hola",
  world: "Mundo",
};
console.log(translations["hello"]);

// Nested Object Typing
interface Address {
  street: string;
  city: string;
  zipCode: string;
}

interface Customer {
  id: number;
  name: string;
  billingAddress: Address; // Nested object
  shippingAddresses: Address[]; // Array of nested objects
}

const customer1: Customer = {
  id: 301,
  name: "Jane Smith",
  billingAddress: {
    street: "123 Main St",
    city: "Anytown",
    zipCode: "12345",
  },
  shippingAddresses: [
    {
      street: "123 Main St",
      city: "Anytown",
      zipCode: "12345",
    },
    {
      street: "456 Oak Ave",
      city: "Otherville",
      zipCode: "67890",
    },
  ],
};
console.log(customer1.shippingAddresses[1].city);
```

### Common Pitfalls & Trade-offs
*   **Overuse of `any`:** Bypasses type checking, defeating TypeScript's purpose. Leads to runtime errors that could have been caught at compile-time.
*   **Misunderstanding Tuples vs. Arrays:** Tuples enforce fixed length and order; regular arrays do not. Using a plain array when a tuple is intended can lead to incorrect assumptions about data structure.
*   **`interface` vs. `type`:**
    *   **Interface:** Generally preferred for defining object shapes due to `extends`, `implements`, and declaration merging, which are beneficial for library authors and large codebases.
    *   **Type Alias:** More flexible for complex type compositions (unions, intersections, mapping types, literal types) and aliasing non-object types. Cannot be "implemented" directly by classes, nor does it merge declarations.
*   **Immutability with `readonly`:** `readonly` arrays and properties provide compile-time safety. They do not enforce runtime immutability (e.g., if a `readonly` array is passed to a function written in plain JavaScript, it can still be mutated).
*   **Implicit `any`:** When TypeScript cannot infer a type (e.g., an uninitialized variable, function parameter without annotation in `--noImplicitAny` mode), it might default to `any`, which is a common source of type errors.

### Interview Questions
1.  **Explain the primary differences between using an `interface` and a `type` alias to define an object's shape in TypeScript. When would you prefer one over the other?**
    *   **Answer:** `interface` is used solely for defining object shapes and has features like `extends` for inheritance and declaration merging. `type` aliases are more versatile; they can define aliases for any type (primitives, unions, intersections, tuples, object shapes) but lack declaration merging and can't be `implements` directly. Prefer `interface` for defining public APIs and extensible object shapes. Use `type` for unions, intersections, literal types, or when aliasing a primitive.
2.  **When would you use a tuple type in TypeScript, and how does it differ from a standard array type? Provide an example.**
    *   **Answer:** A tuple type is used when you need an array with a fixed number of elements, where each element has a known type at a specific position. It enforces both the length and the order of types. A standard array, conversely, only enforces that all elements are of a single, specified type, and its length is dynamic. Example: `[string, number, boolean]` could represent `[username, id, isAdmin]`, whereas `(string | number | boolean)[]` would allow any mix and length.
3.  **Describe how TypeScript's structural typing applies to objects, and what are its implications for type compatibility?**
    *   **Answer:** TypeScript is structurally typed, meaning two types are compatible if their members are compatible, irrespective of their names. For objects, this implies that if an object (or a type) has all the required properties of another object type (an interface or type alias), and those properties' types are compatible, then it is considered assignable. The implication is greater flexibility: types don't need to explicitly declare they implement an interface, only structurally match it. This can sometimes lead to unexpected compatibility if types accidentally match structure but are semantically different.
4.  **What are `readonly` arrays and object properties in TypeScript, and why might you use them?**
    *   **Answer:** `readonly` is a type modifier that, when applied to array types (e.g., `readonly string[]` or `ReadonlyArray<T>`) or object properties, prevents modification after initialization at compile-time. For arrays, this means methods like `push`, `pop`, `splice`, or direct index assignment are disallowed. For properties, it means they cannot be reassigned. You use them to enforce immutability at the type level, making code safer, more predictable, and easier to reason about, especially in functional programming paradigms or when passing data that should not be altered by a consumer.
5.  **How would you type an object where the keys are not known beforehand, but all values are guaranteed to be of a specific type (e.g., numbers)?**
    *   **Answer:** You would use an **index signature**. An index signature defines the type for properties whose names are unknown. For an object where all keys are strings and all values are numbers, you'd define it as `interface MyDictionary { [key: string]: number; }` or `type MyDictionary = { [key: string]: number; };`. This allows accessing properties using bracket notation (e.g., `myDictionary['someKey']`) while ensuring type safety for the values.