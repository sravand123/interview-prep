---
topic: TypeScript
section: Type System Mastery & Architectural Patterns
subtopic: Conditional Types and the `infer` keyword
level: Advanced
---

## Conditional Types and the `infer` keyword
### Core Concepts

*   **Conditional Types (`T extends U ? X : Y`)**:
    *   Allow types to be chosen based on a condition: if type `T` is assignable to type `U`, then the type is `X`; otherwise, it's `Y`.
    *   Similar to a ternary operator but operating at the type level.
    *   Fundamental for creating flexible and polymorphic types that adapt to their inputs.
*   **`infer` Keyword**:
    *   Used *only* within the `extends` clause of a conditional type.
    *   Enables *type inference* within the condition. It declares a new type variable that "captures" a part of the type being checked.
    *   If the type matches the pattern, the inferred type is used in the `true` branch (`X`). If it doesn't match, the `infer` keyword has no effect, and the `false` branch (`Y`) is taken.
    *   Acts like a placeholder for a type that TypeScript needs to deduce.

### Key Details & Nuances

*   **Type Variable Scope**: An `infer`'d type variable (`InferedType`) is only available in the `true` branch of the conditional type (`T extends SomeType<InferedType> ? InferedType : OtherType`).
*   **Built-in Utilities**: `infer` is the core mechanism behind many powerful built-in TypeScript utility types:
    *   `ReturnType<T>`: Infers the return type of a function.
    *   `Parameters<T>`: Infers the parameter types of a function as a tuple.
    *   `InstanceType<T>`: Infers the instance type of a constructor function.
    *   `Awaited<T>`: Infers the unwrapped type of a Promise.
*   **Distributional Conditional Types**: When a conditional type operates on a union type, it "distributes" over the union. Each member of the union is evaluated individually.
    ```typescript
    type BoxedValue<T> = T extends string ? { value: T } : T;
    type Result = BoxedValue<string | number>;
    // Result is { value: string } | number; the conditional type distributes.
    ```
    To prevent distribution, wrap the `extends` clause operands in square brackets: `[T] extends [U] ? X : Y`.
*   **Ambiguity and Overloads**: `infer` will generally pick the *last* signature in an overloaded function. To infer from specific overloads, more complex conditional types or function signature analysis might be needed.
*   **`infer` Location**: `infer` can appear in various positions within the `extends` clause pattern:
    *   `infer R` (return type)
    *   `(...args: infer A)` (parameters)
    *   `Array<infer E>` (array element type)

### Practical Examples

```typescript
// 1. Extracting Return Type (similar to built-in ReturnType<T>)
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function greet(name: string, age: number): string {
    return `Hello ${name}, you are ${age} years old.`;
}

type GreetReturn = MyReturnType<typeof greet>; // type GreetReturn = string
type NonFunctionReturn = MyReturnType<number>; // type NonFunctionReturn = never

// 2. Extracting Parameters (similar to built-in Parameters<T>)
type MyParameters<T> = T extends (...args: infer P) => any ? P : never;

type GreetParams = MyParameters<typeof greet>; // type GreetParams = [name: string, age: number]
type VoidFuncParams = MyParameters<() => void>; // type VoidFuncParams = []

// 3. Unpacking a Promise Type
type UnpackPromise<T> = T extends Promise<infer U> ? U : T;

type PromiseString = UnpackPromise<Promise<string>>; // type PromiseString = string
type DirectNumber = UnpackPromise<number>;      // type DirectNumber = number
type NestedPromise = UnpackPromise<Promise<Promise<boolean>>>; // type NestedPromise = Promise<boolean>
// Note: This only unwraps one level. For full unwrap, recursion is needed.

// 4. Recursive Promise Unpacking (Advanced)
type DeepUnpackPromise<T> = T extends Promise<infer U> ? DeepUnpackPromise<U> : T;

type DeepPromiseString = DeepUnpackPromise<Promise<Promise<string>>>; // type DeepPromiseString = string
```

### Common Pitfalls & Trade-offs

*   **Over-Engineering**: Using complex conditional types for simple type transformations can decrease readability. Sometimes, a direct type union or intersection is clearer.
*   **Readability**: Highly nested or complex conditional types with multiple `infer` statements can be challenging to read and debug. Prioritize clarity.
*   **Incomplete Inference**: `infer` only works when the pattern *fully matches*. If a function type is `(arg: any) => any` but you expect `(arg: string) => number`, `infer` might still succeed but yield `any` for the parts that couldn't be more specifically inferred, leading to less type safety.
*   **Non-Distribution Intent**: Forgetting to wrap union types in `[]` when you *don't* want distributional behavior can lead to unexpected type unions.
*   **Performance (Compile Time)**: While rarely a major bottleneck for typical applications, extremely complex and deeply recursive conditional types can increase TypeScript compilation times for very large codebases. This is a rare edge case.

### Interview Questions

1.  **Question**: Explain the purpose of `infer` within a conditional type. Provide a use case where `infer` is invaluable.
    **Answer**: `infer` allows us to "capture" or "extract" a specific type from within another type during a type-level pattern match. It declares a new type variable within the `extends` clause of a conditional type. If the type being checked matches the pattern, the captured type is then available for use in the "true" branch of the conditional type. It's invaluable for creating generic utility types that introspect and transform other types, such as extracting a function's return type (`ReturnType<T>`) or its parameters (`Parameters<T>`) for type-safe manipulation or derived types.

2.  **Question**: How do `Conditional Types` differ from JavaScript's ternary operator, `condition ? expr1 : expr2`?
    **Answer**: While syntactically similar, conditional types operate entirely at the *type level* during compile-time, selecting between two *types* (`X` or `Y`) based on a type relationship (`T extends U`). The JavaScript ternary operator, in contrast, operates at the *runtime value level*, evaluating a boolean expression to choose between two *values* (`expr1` or `expr2`). Conditional types allow for type-level programming and metaprogramming in TypeScript, enabling highly flexible and adaptable type definitions.

3.  **Question**: Describe what a "Distributional Conditional Type" is and how you can prevent this behavior if it's not desired.
    **Answer**: A distributional conditional type occurs when the type parameter (`T`) in a conditional type (`T extends U ? X : Y`) is a union type (e.g., `string | number`). In this scenario, TypeScript "distributes" the conditional type over each member of the union. For example, `(A | B) extends U ? X : Y` becomes `(A extends U ? X : Y) | (B extends U ? X : Y)`. To prevent this distribution, you can wrap the type parameter in a tuple: `[T] extends [U] ? X : Y`. This makes `T` a single type (a tuple type), preventing the conditional logic from applying to each individual union member.

4.  **Question**: You need to define a type that extracts the element type from an array, or returns the type itself if it's not an array. How would you implement this using `infer`?
    **Answer**:
    ```typescript
    type ExtractArrayElementType<T> = T extends (infer E)[] ? E : T;

    type StringArrayElement = ExtractArrayElementType<string[]>; // type StringArrayElement = string
    type NumberVar = ExtractArrayElementType<number>;           // type NumberVar = number
    type MixedArrayElement = ExtractArrayElementType<Array<string | boolean>>; // type MixedArrayElement = string | boolean
    ```
    This conditional type checks if `T` extends an array type `(infer E)[]`. If it does, `infer E` captures the element type, which is then returned. Otherwise, if `T` is not an array, `T` itself is returned.