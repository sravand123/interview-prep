---
topic: TypeScript
section: Type System Mastery & Architectural Patterns
subtopic: Mapped Types and Template Literal Types
level: Advanced
---

## Mapped Types and Template Literal Types
### Core Concepts

*   **Mapped Types:**
    *   **Definition:** A powerful feature allowing you to create new object types by iterating over the properties of an existing object type and transforming them.
    *   **Syntax:** Uses a `[K in KeyUnion]: Type` structure, often combined with `keyof` to get all keys from a type.
    *   **Purpose:** Essential for building flexible, generic utility types (e.g., `Partial`, `Required`, `Readonly`, `Pick`, `Omit`, `Record`). They enable deriving new types programmatically from existing ones, promoting type reuse and reducing boilerplate.

*   **Template Literal Types:**
    *   **Definition:** String literal types that allow embedding type variables within backticks (`` ` ``), similar to JavaScript's template literals.
    *   **Syntax:** `type MyString = `${Prefix}-${SomeType}${Suffix}`;`
    *   **Purpose:** Enables creation of new string literal types based on patterns or combinations of existing string literals. This is incredibly useful for defining strict naming conventions (e.g., event names, API endpoints, CSS class names), ensuring type safety for string-based identifiers.

*   **Synergy:** Mapped Types and Template Literal Types frequently complement each other, especially when using **key remapping (`as` clause)** in Mapped Types to generate new property keys based on dynamic string patterns.

### Key Details & Nuances

*   **Mapped Type Modifiers:**
    *   `readonly` / `+readonly` / `-readonly`: Used to add, ensure presence, or remove the `readonly` modifier on properties.
    *   `?` / `+?` / `-?`: Used to add, ensure presence, or remove the optional (`?`) modifier on properties.
    *   These are foundational for `Partial`, `Required`, `Readonly` utility types.
*   **Key Remapping (`as` clause, TS 4.1+):**
    *   The `as` clause within a mapped type (`[K in KeyUnion as NewKeyType]: Type`) allows you to transform the *keys* of the new type, not just their values.
    *   `NewKeyType` can be any type that resolves to a `string | number | symbol` literal type. This is where Template Literal Types shine.
    *   Conditional types (`K extends SomePattern ? ... : ...`) are frequently used within the `as` clause for advanced key transformations.
*   **Intrinsic String Manipulation Types:**
    *   TypeScript provides built-in utility types for common string casing transformations:
        *   `Uppercase<StringType>`: Converts all characters to uppercase.
        *   `Lowercase<StringType>`: Converts all characters to lowercase.
        *   `Capitalize<StringType>`: Converts the first character to uppercase.
        *   `Uncapitalize<StringType>`: Converts the first character to lowercase.
    *   These are indispensable when used with Template Literal Types and key remapping to achieve precise naming conventions (e.g., `foo` -> `onFooChange`).
*   **Inference with Template Literal Types (`infer`):**
    *   Template Literal Types can be used in conjunction with conditional types and the `infer` keyword to extract parts of a string literal.
    *   Example: `T extends `${infer Prefix}Id` ? Prefix : never` extracts the `Prefix` from a string ending with `Id`. This is powerful for parsing string patterns at the type level.

### Practical Examples

```typescript
// --- Mapped Type with Key Remapping & Template Literal Types ---

type User = {
  id: string;
  firstName: string;
  lastName: string;
  age: number;
};

// Define a type that transforms property names into event handler names
// e.g., 'id' -> 'onIdChange', 'firstName' -> 'onFirstNameChange'
type ChangeHandlers<T> = {
  // K in keyof T: Iterate over keys of T (e.g., 'id', 'firstName')
  // as `on${Capitalize<string & K>}Change`: Remap the key using a Template Literal Type
  //   - `string & K` ensures K is treated as a string literal for Capitalize
  //   - Capitalize<...>: Converts the first letter of the key to uppercase
  //   - The result is a new string literal like 'onIdChange'
  [K in keyof T as `on${Capitalize<string & K>}Change`]: (newValue: T[K]) => void;
};

type UserChangeHandlers = ChangeHandlers<User>;
/*
// UserChangeHandlers will be:
{
    onIdChange: (newValue: string) => void;
    onFirstNameChange: (newValue: string) => void;
    onLastNameChange: (newValue: string) => void;
    onAgeChange: (newValue: number) => void;
}
*/

const handlers: UserChangeHandlers = {
    onIdChange: (id) => console.log(`ID changed to ${id}`),
    onFirstNameChange: (name) => console.log(`First name changed to ${name}`),
    onLastNameChange: (name) => console.log(`Last name changed to ${name}`),
    onAgeChange: (age) => console.log(`Age changed to ${age}`),
};

// --- Template Literal Type for strict API routes ---

type Resource = 'users' | 'products' | 'orders';
type Action = 'create' | 'read' | 'update' | 'delete';

// Creates string literal types like '/api/users/read', '/api/products/create'
type ApiRoute = `/api/${Resource}/${Action}`;

const userReadRoute: ApiRoute = '/api/users/read';
// const invalidRoute: ApiRoute = '/api/customers/read'; // Error: 'customers' is not a valid Resource

// --- Using `infer` with Template Literal Types ---

type ExtractPrefix<S extends string> =
  S extends `${infer Prefix}Service` ? Prefix : never;

type UserServicePrefix = ExtractPrefix<'UserService'>; // 'User'
type ProductServicePrefix = ExtractPrefix<'ProductService'>; // 'Product'
type NoServiceSuffix = ExtractPrefix<'NoSuffix'>; // never
```

### Common Pitfalls & Trade-offs

*   **Complexity vs. Readability:** While powerful, deeply nested or highly generic Mapped Types and Template Literal Types can significantly decrease code readability and maintainability for developers unfamiliar with advanced TypeScript. Strive for a balance.
*   **Performance Impact:** Very complex type manipulations, especially those involving large unions or recursive operations with `infer`, can lead to increased type-checking times, impacting developer experience.
*   **Over-engineering:** Don't resort to complex type transformations if simpler intersections, unions, or basic utility types (`Partial`, `Pick`) suffice.
*   **Runtime Disconnect:** TypeScript types exist only at compile-time. Ensure your runtime logic correctly handles values that adhere to these complex types. If deriving a runtime string, you might still need runtime validation (e.g., regex) in addition to type safety.
*   **Inference Limitations:** While `infer` is powerful, it has limitations. It might not always infer exactly what you expect, especially with very ambiguous or highly complex patterns. Debugging complex type inference can be challenging.

### Interview Questions

1.  **Q:** Explain the primary use cases for TypeScript's Mapped Types and Template Literal Types. How do they complement each other in practical scenarios?
    *   **A:** Mapped Types are primarily used for transforming existing object types, allowing you to derive new types by iterating over properties and modifying their types or optionality (e.g., `Partial<T>`, `Readonly<T>`). Template Literal Types create new string literal types based on patterns, enforcing strict naming conventions for things like event names or API paths. They complement each other when Mapped Types utilize Template Literal Types to perform **key remapping** (e.g., transforming a property `id` into a new key like `onIdChange` in a new type) or to generate a union of specific string values for property keys.

2.  **Q:** Describe a scenario where you would use the `as` clause in a Mapped Type. What problem does it solve that regular Mapped Types cannot?
    *   **A:** The `as` clause, introduced in TypeScript 4.1, is used for **key remapping** within a Mapped Type. A regular Mapped Type can only transform the *values* of properties, keeping the original keys. The `as` clause allows you to transform the *keys themselves*. A common scenario is generating event handler names from an interface's properties (e.g., `User { id: string; }` to `UserHandlers { onIdChange: (id: string) => void; }`). It solves the problem of needing to derive new property names systematically from existing ones, often combining with Template Literal Types and intrinsic string utilities.

3.  **Q:** What are TypeScript's intrinsic string manipulation types (`Uppercase`, `Lowercase`, `Capitalize`, `Uncapitalize`), and how are they typically used with Template Literal Types? Provide a brief example.
    *   **A:** These are built-in utility types that perform common casing transformations on string literal types at the type level.
        *   `Uppercase<S>`: Converts `S` to all caps.
        *   `Lowercase<S>`: Converts `S` to all lowercase.
        *   `Capitalize<S>`: Capitalizes the first character of `S`.
        *   `Uncapitalize<S>`: Uncapitalizes the first character of `S`.
        They are typically used within Template Literal Types (often combined with the `as` clause in Mapped Types) to construct new string literal types with precise casing.
        *   **Example:** To transform `userId` into `getUserId` for a getter function name:
            ```typescript
            type Prop = 'userId' | 'productId';
            type Getter<P extends Prop> = `get${Capitalize<P>}`;
            type UserIdGetter = Getter<'userId'>; // "getUserId"
            ```

4.  **Q:** You have a type `type LogLevel = 'info' | 'warn' | 'error';`. How would you define a type `LogEntry<Level extends LogLevel>` such that `LogEntry<'info'>` is `'INFO_MESSAGE'`, `LogEntry<'warn'>` is `'WARN_MESSAGE'`, etc.?
    *   **A:**
        ```typescript
        type LogLevel = 'info' | 'warn' | 'error';

        type LogEntry<Level extends LogLevel> = `${Uppercase<Level>}_MESSAGE`;

        type InfoLog = LogEntry<'info'>;   // "INFO_MESSAGE"
        type WarnLog = LogEntry<'warn'>;   // "WARN_MESSAGE"
        type ErrorLog = LogEntry<'error'>; // "ERROR_MESSAGE"
        ```