---
topic: SQL
section: Data Manipulation & Basic Retrieval
subtopic: `DELETE FROM ... WHERE`: Removing specific rows
level: Beginner
---

## `DELETE FROM ... WHERE`: Removing specific rows
### Core Concepts
*   The `DELETE FROM` statement is a Data Manipulation Language (DML) command used to remove one or more rows from a table.
*   The `WHERE` clause is crucial for specifying which rows to delete. Without a `WHERE` clause, `DELETE FROM` will remove *all* rows from the specified table.

### Key Details & Nuances
*   **Transactional Nature:**
    *   `DELETE` operations are transactional. This means they can be rolled back if an error occurs or if the changes are not intended to be permanent (e.g., using `ROLLBACK` after a `BEGIN TRANSACTION`).
    *   Adheres to ACID properties (Atomicity, Consistency, Isolation, Durability).
*   **Foreign Key Constraints:**
    *   Behavior depends on the `ON DELETE` action defined in the foreign key constraint:
        *   `ON DELETE RESTRICT` (or `NO ACTION`): Prevents deletion of a parent row if child rows exist.
        *   `ON DELETE CASCADE`: Deletes child rows automatically when the parent row is deleted.
        *   `ON DELETE SET NULL`: Sets the foreign key column in child rows to `NULL` when the parent row is deleted (requires the foreign key column to be nullable).
*   **Performance Considerations:**
    *   **Indexing:** The `WHERE` clause should ideally use indexed columns for efficient row identification, especially on large tables.
    *   **Locking:** `DELETE` operations acquire locks on the rows being deleted, and potentially table/page locks, which can impact concurrency. Deleting large numbers of rows can lead to long-running transactions and blocking.
    *   **Logging:** Deletions are typically logged in the database's transaction log for recovery purposes. Large deletes generate substantial log entries.
*   **`DELETE` vs. `TRUNCATE`:** (Common interview distinction)
    *   **`DELETE FROM`**: DML command, transactional, logs individual row deletions, fires triggers, can use `WHERE` clause, slower for entire table.
    *   **`TRUNCATE TABLE`**: DDL command, non-transactional (cannot be rolled back in most databases), logs page deallocations (minimal logging), does not fire `DELETE` triggers, removes all rows rapidly, resets identity columns.

### Practical Examples

**1. Basic Deletion:**
Removes rows from the `Orders` table where the `status` is 'cancelled'.

```sql
DELETE FROM Orders
WHERE status = 'cancelled';
```

**2. Deleting Based on Related Data (Subquery/JOIN):**
Removes users who have not logged in for over 1 year and are marked as 'inactive'.

```sql
-- Using a subquery (common and often portable)
DELETE FROM Users
WHERE last_login_date < DATE('now', '-1 year')
  AND status = 'inactive';

-- Using a JOIN (syntax varies by RDBMS, e.g., MySQL syntax shown)
-- DELETE U FROM Users U
-- JOIN UserActivity UA ON U.user_id = UA.user_id
-- WHERE UA.last_activity_date < DATE('now', '-1 year')
--   AND U.status = 'inactive';
```

**3. Returning Deleted Rows (PostgreSQL `RETURNING` clause):**
Useful for auditing or further processing of deleted data.

```sql
DELETE FROM Products
WHERE quantity = 0 AND last_updated < NOW() - INTERVAL '6 months'
RETURNING product_id, product_name, deleted_at;
```

### Common Pitfalls & Trade-offs
*   **Forgetting `WHERE` Clause:** The most dangerous pitfall, leading to the deletion of all rows in a table. Always `SELECT` first with the same `WHERE` clause to verify the rows targeted for deletion.
*   **Performance Bottlenecks:** Deleting large numbers of rows without proper indexing or within a single, long transaction can cause significant performance degradation due due to extensive locking and logging. Consider batching large deletes.
*   **Cascade Delete Unexpected Behavior:** While convenient, `ON DELETE CASCADE` can inadvertently delete large amounts of related data if not fully understood and carefully managed.
*   **Lack of Transactional Control:** Performing `DELETE` operations without explicit transactions (`BEGIN TRANSACTION`/`COMMIT`/`ROLLBACK`) removes the safety net for recovery from errors or unintended deletions.

### Interview Questions
1.  **"Explain the key differences between `DELETE FROM`, `TRUNCATE TABLE`, and `DROP TABLE`. When would you use each?"**
    *   **Answer:** `DELETE FROM` is DML, row-by-row, transactional, uses `WHERE`, fires triggers, slow for whole table. `TRUNCATE TABLE` is DDL, non-transactional (usually), faster for whole table, minimal logging, resets identity, doesn't fire `DELETE` triggers. `DROP TABLE` is DDL, removes the entire table schema and data, non-transactional. Use `DELETE` for specific rows or if you need transactionality/triggers, `TRUNCATE` for fast full-table removal without specific row conditions/triggers, and `DROP` to completely remove a table definition.

2.  **"How do foreign key constraints affect `DELETE` operations? Provide an example of how you might handle deleting a parent record with existing child records."**
    *   **Answer:** Foreign keys can `RESTRICT` (prevent deletion), `CASCADE` (delete children), or `SET NULL` (set child FK to NULL). To handle, either ensure no child records exist (manually delete them first), define `ON DELETE CASCADE` if that behavior is desired, or use `ON DELETE SET NULL` if the child FK can be null and doesn't break integrity. The choice depends on business logic; `RESTRICT` is safest by default.

3.  **"You need to delete millions of rows from a large table. What are the performance considerations and how would you approach this to minimize impact on the database?"**
    *   **Answer:** Performance considerations include long transaction times, extensive locking, high transaction log generation, and potential for deadlocks. Approach this by:
        *   **Batching Deletes:** Delete in smaller chunks (e.g., 10,000 rows at a time) within separate transactions to reduce lock duration and log size.
        *   **Indexing:** Ensure `WHERE` clause columns are indexed.
        *   **Off-Peak Hours:** Schedule the operation during low database activity.
        *   **Temporary Tables (Advanced):** For very large deletes, consider copying desired data to a new table, dropping the old, and renaming the new (effectively a `CREATE TABLE AS SELECT` then `DROP` then `RENAME`). This avoids logging individual row deletions.

4.  **"Imagine you accidentally executed `DELETE FROM Users;` on a production database without a `WHERE` clause. What steps would you take immediately and for recovery?"**
    *   **Answer:**
        1.  **Immediate:** If within an explicit transaction, immediately `ROLLBACK`. If not, identify the exact time of the incident.
        2.  **Containment:** Disable write access to the affected table/database to prevent further data changes.
        3.  **Recovery:**
            *   **Point-in-Time Recovery:** Restore the database from the most recent full backup to a point *just before* the accidental delete, then apply transaction logs up to that point. This is the most robust method for full data integrity.
            *   **Log Mining (if applicable):** Some databases allow "mining" the transaction log to undo specific operations, but this is complex and database-specific.
            *   **Data Import (if backup of *just* the table exists):** If only that table was affected and you have a recent logical backup (e.g., `pg_dump` of just the table), you might be able to restore just that table, being careful with foreign key constraints.
        4.  **Post-Mortem:** Analyze why the mistake happened (e.g., lack of proper permissions, no confirmation, executing directly on prod, inadequate testing, insufficient tooling) and implement preventative measures.