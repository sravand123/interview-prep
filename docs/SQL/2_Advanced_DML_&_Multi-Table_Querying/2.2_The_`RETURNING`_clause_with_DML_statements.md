---
topic: SQL
section: Advanced DML & Multi-Table Querying
subtopic: The `RETURNING` clause with DML statements
level: Intermediate
---

## The `RETURNING` clause with DML statements
### Core Concepts
*   **Purpose**: The `RETURNING` clause allows DML (Data Manipulation Language) statements (`INSERT`, `UPDATE`, `DELETE`) to return data from the rows that were affected by the operation.
*   **Atomic Operations**: It enables performing a modification and immediately retrieving information about the modified data (e.g., generated IDs, updated timestamps, old values) within a single, atomic database round-trip.
*   **Efficiency**: Reduces the need for subsequent `SELECT` queries to fetch the affected data, improving performance and simplifying application logic.

### Key Details & Nuances
*   **Supported Statements**:
    *   `INSERT ... RETURNING`: Returns data from the newly inserted rows. Commonly used to retrieve auto-generated primary keys (e.g., `id`, `uuid`) or default values (e.g., `created_at`).
    *   `UPDATE ... RETURNING`: Returns data from the rows *after* they have been updated. Can retrieve both old and new values in some database systems (e.g., PostgreSQL using `OLD` and `NEW` aliases in triggers, though `RETURNING` itself returns new values).
    *   `DELETE ... RETURNING`: Returns data from the rows *before* they were deleted. Useful for auditing or logging deleted content.
*   **Column Selection**:
    *   `RETURNING *`: Returns all columns of the affected rows.
    *   `RETURNING column_name, another_column`: Returns specific columns.
    *   `RETURNING expression`: Can return the result of an expression involving the affected columns (e.g., `RETURNING id, created_at + INTERVAL '1 hour' as expiry_time`).
*   **Database Compatibility**:
    *   **PostgreSQL**: Fully supports `RETURNING` for `INSERT`, `UPDATE`, `DELETE`. This is the most common database where this feature is discussed.
    *   **SQL Server**: Uses the `OUTPUT` clause, which offers similar functionality but with slightly different syntax and capabilities (e.g., `OUTPUT INSERTED.column_name`, `OUTPUT DELETED.column_name`).
    *   **MySQL**: Does *not* have a direct `RETURNING` or `OUTPUT` clause for `UPDATE` or `DELETE`. For `INSERT`, `LAST_INSERT_ID()` (session-specific) or similar functions are used after the `INSERT` to retrieve the auto-generated ID.

### Practical Examples

```typescript
// Assuming a Node.js environment with a PostgreSQL client (e.g., 'pg' or 'knex')

// 1. INSERT and return the generated ID and a default timestamp
async function createUser(name: string, email: string) {
  const query = `
    INSERT INTO users (name, email)
    VALUES ($1, $2)
    RETURNING id, created_at;
  `;
  // In a real application, you'd use a connection pool or ORM
  const result = await dbClient.query(query, [name, email]);
  console.log('New user created:', result.rows[0]);
  // Example output: { id: 123, created_at: '2023-10-27T10:00:00.000Z' }
  return result.rows[0];
}

// 2. UPDATE a product's price and return the new price and updated timestamp
async function updateProductPrice(productId: number, newPrice: number) {
  const query = `
    UPDATE products
    SET price = $1, updated_at = NOW()
    WHERE id = $2
    RETURNING id, name, price, updated_at;
  `;
  const result = await dbClient.query(query, [newPrice, productId]);
  if (result.rows.length > 0) {
    console.log('Product updated:', result.rows[0]);
    return result.rows[0];
  } else {
    console.log('Product not found.');
    return null;
  }
}

// 3. DELETE a session and return the session ID and associated user ID for logging
async function deleteSession(sessionId: string) {
  const query = `
    DELETE FROM sessions
    WHERE session_id = $1
    RETURNING session_id, user_id;
  `;
  const result = await dbClient.query(query, [sessionId]);
  if (result.rows.length > 0) {
    console.log('Session deleted:', result.rows[0]);
    return result.rows[0];
  } else {
    console.log('Session not found.');
    return null;
  }
}

// Example usage (assuming dbClient is initialized)
// createUser('Alice', 'alice@example.com');
// updateProductPrice(456, 129.99);
// deleteSession('abc-123-def');
```

### Common Pitfalls & Trade-offs
*   **Database Portability**: Code relying on `RETURNING` (or `OUTPUT`) is not universally portable across all relational databases. This requires conditional logic or ORM abstraction for multi-database support.
*   **Over-Returning Data**: Returning `*` (all columns) for a table with many columns can increase network traffic and memory usage, especially for operations affecting many rows. Select only the necessary columns.
*   **Large Result Sets**: While generally efficient, using `RETURNING` for DML operations that affect millions of rows could still result in transferring a very large dataset back to the application, which might not always be desired or efficient.
*   **Security Implications**: Ensure that sensitive data is not inadvertently returned to the client-side or logs if not intended.

### Interview Questions
1.  **Question**: Explain the primary advantage of using the `RETURNING` clause over executing a separate `SELECT` statement after a DML operation.
    **Answer**: The primary advantage is **atomicity and reduced round-trips**. By combining the DML operation and data retrieval into a single query, it ensures that the data returned accurately reflects the state *immediately after* the modification, preventing race conditions or needing to manage transactions explicitly for this simple case. It also minimizes network latency by requiring only one communication round-trip to the database instead of two.

2.  **Question**: In which DML statements can `RETURNING` be used, and what type of data would you typically expect to retrieve from each?
    **Answer**:
    *   `INSERT`: Typically used to retrieve auto-generated primary keys (e.g., `id`), default values (e.g., `created_at`), or system-generated fields (e.g., `UUID`).
    *   `UPDATE`: Used to retrieve the *new* state of the updated rows, such as the new value of a modified column or an `updated_at` timestamp.
    *   `DELETE`: Used to retrieve the data from the rows *before* they were deleted, which is useful for logging, auditing, or displaying what was removed.

3.  **Question**: Discuss the compatibility of the `RETURNING` clause across different popular relational database systems like PostgreSQL, SQL Server, and MySQL.
    **Answer**:
    *   **PostgreSQL**: Fully supports `RETURNING` for `INSERT`, `UPDATE`, and `DELETE` statements. It's the standard for this feature.
    *   **SQL Server**: Does not have a `RETURNING` clause but provides similar functionality through its `OUTPUT` clause, which can return `INSERTED` (new values) or `DELETED` (old values) virtual tables.
    *   **MySQL**: Lacks a direct `RETURNING` or `OUTPUT` clause for `UPDATE` or `DELETE`. For `INSERT` operations where an auto-increment ID is needed, one typically uses `LAST_INSERT_ID()` *after* the insert, which is session-specific.

4.  **Question**: Describe a scenario where using `RETURNING` would be highly beneficial for application development, especially in a microservices or API context.
    **Answer**: Consider an API endpoint for creating a new user (`POST /users`). The database generates a unique user ID and sets a `created_at` timestamp. After the `INSERT` operation, the API needs to immediately return this generated ID and timestamp to the client, along with other user details, as part of the response payload. Using `INSERT ... RETURNING id, created_at` allows the API to get all necessary information in a single database call, simplifying the code, improving response time, and ensuring data consistency.

5.  **Question**: When might you decide *not* to use the `RETURNING` clause, even if it's supported by your database?
    **Answer**: You might opt not to use `RETURNING` if:
    *   The DML operation affects an extremely large number of rows, and you do not need the returned data for each row, as transferring a massive result set could impact performance.
    *   You are performing a bulk operation where the specific details of individual affected rows are irrelevant (e.g., a nightly cleanup job).
    *   You are working with a database system (like MySQL) that doesn't natively support `RETURNING` or an equivalent, and adding client-side logic to emulate it is deemed too complex for the given benefit.
    *   Security concerns: If returning certain columns could expose sensitive data unnecessarily to the application layer.